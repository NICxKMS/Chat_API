{"version":3,"file":"static/js/app-large-31743c5a.86d2e1ce98.v2_0_1.js","mappings":"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","sources":["utils/chunkOptimizer.js","hooks/useProfilePicture.js","hooks/useMediaQuery.js","hooks/useLocalStorage.js","reportWebVitals.js","serviceWorkerRegistration.js","index.js","utils/performance.js","contexts/StreamingEventsContext.js","hooks/useSettingsController.js","utils/messageHelpers.js","hooks/useCacheToggle.js","firebaseConfig.js","utils/formatters.js","hooks/useChatLogic.js","utils/network.js","contexts/ThemeContext.js","contexts/ToastContext.js"],"sourcesContent":["/**\n * Chunk Optimization Utility\n * Helps with intelligent loading and grouping of small chunks\n */\n\n// Track loaded chunks to avoid duplicate loading\nconst loadedChunks = new Set();\nconst loadingChunks = new Map();\n\n/**\n * Intelligent chunk loader that groups small imports together\n * @param {Object} importMap - Map of import functions\n * @param {Object} options - Loading options\n */\nexport const loadChunkGroup = async (importMap, options = {}) => {\n  const {\n    groupName = 'default',\n    priority = 0,\n    timeout = 5000,\n    retries = 2,\n  } = options;\n\n  // Check if already loaded\n  if (loadedChunks.has(groupName)) {\n    return Promise.resolve();\n  }\n\n  // Check if currently loading\n  if (loadingChunks.has(groupName)) {\n    return loadingChunks.get(groupName);\n  }\n\n  const loadPromise = loadWithRetry(importMap, groupName, retries, timeout);\n  loadingChunks.set(groupName, loadPromise);\n\n  try {\n    await loadPromise;\n    loadedChunks.add(groupName);\n    loadingChunks.delete(groupName);\n  } catch (error) {\n    loadingChunks.delete(groupName);\n    throw error;\n  }\n\n  return loadPromise;\n};\n\n/**\n * Load chunks with retry logic\n */\nconst loadWithRetry = async (importMap, groupName, retries, timeout) => {\n  let lastError;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(`Timeout loading ${groupName}`)), timeout);\n      });\n\n      const loadPromise = Promise.all(\n        Object.entries(importMap).map(async ([key, importFn]) => {\n          try {\n            const module = await importFn();\n            console.log(`✓ Loaded ${groupName}.${key}`);\n            return { key, module };\n          } catch (error) {\n            console.warn(`✗ Failed to load ${groupName}.${key}:`, error);\n            throw error;\n          }\n        })\n      );\n\n      await Promise.race([loadPromise, timeoutPromise]);\n      console.log(`✓ Chunk group '${groupName}' loaded successfully`);\n      return;\n    } catch (error) {\n      lastError = error;\n      if (attempt < retries) {\n        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff\n        console.warn(`Retry ${attempt + 1}/${retries} for ${groupName} in ${delay}ms`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Preload chunks during idle time with intelligent scheduling\n */\nexport const idlePreloadChunks = (chunkGroups, options = {}) => {\n  const {\n    maxConcurrent = 2,\n    priorityDelay = 100,\n    idleTimeout = 5000,\n  } = options;\n\n  let currentlyLoading = 0;\n  const queue = Object.entries(chunkGroups)\n    .sort(([, a], [, b]) => (a.priority || 0) - (b.priority || 0));\n\n  const processQueue = () => {\n    if (currentlyLoading >= maxConcurrent || queue.length === 0) {\n      return;\n    }\n\n    const [groupName, config] = queue.shift();\n    currentlyLoading++;\n\n    const delay = (config.priority || 0) * priorityDelay;\n\n    setTimeout(() => {\n      requestIdleCallback(async () => {\n        try {\n          await loadChunkGroup(config.imports, {\n            groupName,\n            timeout: idleTimeout,\n            ...config.options,\n          });\n        } catch (error) {\n          console.warn(`Idle preload failed for ${groupName}:`, error);\n        } finally {\n          currentlyLoading--;\n          processQueue(); // Process next in queue\n        }\n      }, { timeout: idleTimeout });\n    }, delay);\n  };\n\n  // Start processing\n  processQueue();\n  processQueue(); // Start with max concurrent if possible\n};\n\n/**\n * Smart chunk bundler that groups small modules together\n */\nexport const createSmallChunkBundle = (modules, bundleName = 'small-bundle') => {\n  const bundleImport = () => Promise.all(\n    modules.map(async (moduleImport) => {\n      try {\n        return await moduleImport();\n      } catch (error) {\n        console.warn(`Failed to load module in ${bundleName}:`, error);\n        return null;\n      }\n    })\n  ).then(results => results.filter(Boolean));\n\n  return {\n    [bundleName]: bundleImport,\n  };\n};\n\n/**\n * Monitor chunk loading performance\n */\nexport const createChunkMonitor = () => {\n  const metrics = {\n    loadTimes: new Map(),\n    failures: new Map(),\n    totalLoaded: 0,\n    totalFailed: 0,\n  };\n\n  return {\n    startLoad: (chunkName) => {\n      metrics.loadTimes.set(chunkName, performance.now());\n    },\n\n    endLoad: (chunkName, success = true) => {\n      const startTime = metrics.loadTimes.get(chunkName);\n      if (startTime) {\n        const duration = performance.now() - startTime;\n        if (success) {\n          metrics.totalLoaded++;\n          console.log(`📊 Chunk '${chunkName}' loaded in ${duration.toFixed(2)}ms`);\n        } else {\n          metrics.totalFailed++;\n          metrics.failures.set(chunkName, (metrics.failures.get(chunkName) || 0) + 1);\n          console.warn(`📊 Chunk '${chunkName}' failed after ${duration.toFixed(2)}ms`);\n        }\n        metrics.loadTimes.delete(chunkName);\n      }\n    },\n\n    getMetrics: () => ({\n      ...metrics,\n      loadTimes: Object.fromEntries(metrics.loadTimes),\n      failures: Object.fromEntries(metrics.failures),\n    }),\n\n    reset: () => {\n      metrics.loadTimes.clear();\n      metrics.failures.clear();\n      metrics.totalLoaded = 0;\n      metrics.totalFailed = 0;\n    },\n  };\n};\n\n/**\n * Adaptive loading strategy based on network conditions\n */\nexport const createAdaptiveLoader = () => {\n  const getNetworkInfo = () => {\n    if ('connection' in navigator) {\n      const conn = navigator.connection;\n      return {\n        effectiveType: conn.effectiveType,\n        downlink: conn.downlink,\n        rtt: conn.rtt,\n        saveData: conn.saveData,\n      };\n    }\n    return { effectiveType: '4g', downlink: 10, rtt: 100, saveData: false };\n  };\n\n  const getLoadingStrategy = () => {\n    const network = getNetworkInfo();\n    \n    if (network.saveData || network.effectiveType === 'slow-2g' || network.effectiveType === '2g') {\n      return {\n        maxConcurrent: 4,\n        priorityDelay: 500,\n        timeout: 10000,\n        skipNonEssential: true,\n      };\n    }\n    \n    if (network.effectiveType === '3g') {\n      return {\n        maxConcurrent: 8,\n        priorityDelay: 200,\n        timeout: 8000,\n        skipNonEssential: false,\n      };\n    }\n    \n    // 4g or better\n    return {\n      maxConcurrent: 16,\n      priorityDelay: 100,\n      timeout: 5000,\n      skipNonEssential: false,\n    };\n  };\n\n  return {\n    getStrategy: getLoadingStrategy,\n    getNetworkInfo,\n  };\n};\n\n// Export utilities\nexport default {\n  loadChunkGroup,\n  idlePreloadChunks,\n  createSmallChunkBundle,\n  createChunkMonitor,\n  createAdaptiveLoader,\n}; ","import { useState, useEffect } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n// Time-to-live for cache entries (1 day in milliseconds)\nconst TTL = 24 * 60 * 60 * 1000;\n\n/**\n * Custom hook to fetch and cache user profile picture with a 1-day TTL.\n * @param {string} imageUrl - The URL to fetch the profile picture from.\n * @returns {{ profilePicture: string | null, loading: boolean, error: any }}\n */\nexport const useProfilePicture = (imageUrl) => {\n  const cacheKey = `profilePicture_${imageUrl}`;\n  // cachedEntry is either null, a string (legacy), or { data, timestamp }\n  const [cachedEntry, setCachedEntry] = useLocalStorage(cacheKey, null);\n  const [profilePicture, setProfilePicture] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (!imageUrl) {\n      // No URL: clear state\n      setProfilePicture(null);\n      setLoading(false);\n      return;\n    }\n\n    // Validate cache entry\n    let entry = cachedEntry;\n    if (entry) {\n      // Legacy format: string\n      if (typeof entry === 'string') {\n        const wrapped = { data: entry, timestamp: Date.now() };\n        setCachedEntry(wrapped);\n        entry = wrapped;\n      }\n      // TTL check\n      if (\n        entry.timestamp &&\n        Date.now() - entry.timestamp < TTL &&\n        entry.data\n      ) {\n        setProfilePicture(entry.data);\n        setLoading(false);\n        return;\n      }\n      // Expired cache\n      setCachedEntry(null);\n    }\n\n    // Fetch and cache new image\n    setLoading(true);\n    fetch(imageUrl)\n      .then((response) => {\n        if (!response.ok) throw new Error(`Failed to fetch image: ${response.status}`);\n        return response.blob();\n      })\n      .then(\n        (blob) =>\n          new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n          })\n      )\n      .then((dataUrl) => {\n        if (!isMounted) return;\n        const entryToCache = { data: dataUrl, timestamp: Date.now() };\n        setCachedEntry(entryToCache);\n        setProfilePicture(dataUrl);\n      })\n      .catch((err) => {\n        if (!isMounted) return;\n        console.error('Error fetching and caching profile image:', err);\n        setError(err);\n      })\n      .finally(() => {\n        if (!isMounted) return;\n        setLoading(false);\n      });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [imageUrl, cachedEntry, setCachedEntry]);\n\n  return { profilePicture, loading, error };\n}; ","import { useState, useEffect, useMemo } from 'react';\n\n// Define breakpoint constants in a single source of truth\nexport const BREAKPOINTS = {\n  mobile: '640px',\n  tablet: '1023px',\n  desktop: '1024px',\n  settings: '550px'\n};\n\n// Cached media query listeners\nconst mediaQueryListeners = new Map();\n\n/**\n * Custom hook that returns true if the current viewport matches the provided media query\n * @param {string} query - Media query string e.g., \"(max-width: 1024px)\"\n * @returns {boolean} - True if the media query matches\n */\nexport const useMediaQuery = (query) => {\n  // Initialize with the current match state\n  const [matches, setMatches] = useState(() => {\n    // Check for window to avoid SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    // Avoid running in SSR context\n    if (typeof window === 'undefined') {\n      return undefined;\n    }\n\n    // Check if we already have a listener for this query\n    if (!mediaQueryListeners.has(query)) {\n      // Create media query list\n      const mediaQueryList = window.matchMedia(query);\n      \n      // Create listener registry for this query\n      mediaQueryListeners.set(query, {\n        mediaQueryList,\n        listeners: new Set()\n      });\n    }\n    \n    const queryData = mediaQueryListeners.get(query);\n    const { mediaQueryList, listeners } = queryData;\n\n    // Initial check\n    setMatches(mediaQueryList.matches);\n\n    // Define listener function\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener to registry\n    listeners.add(listener);\n\n    // Modern browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener);\n      return () => {\n        mediaQueryList.removeEventListener('change', listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    } \n    // Legacy support for older browsers (e.g., IE, older Safari)\n    else if (mediaQueryList.addListener) {\n      mediaQueryList.addListener(listener);\n      return () => {\n        mediaQueryList.removeListener(listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    }\n\n    return undefined;\n  }, [query]);\n\n  return matches;\n};\n\n/**\n * Pre-configured hooks for common breakpoints\n */\nexport const useIsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.mobile})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsTablet = () => {\n  const query = useMemo(() => \n    `(min-width: calc(${BREAKPOINTS.mobile} + 1px)) and (max-width: ${BREAKPOINTS.tablet})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsDesktop = () => {\n  const query = useMemo(() => `(min-width: ${BREAKPOINTS.desktop})`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Special hook for settings components\n */\nexport const useIsSettingsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.settings})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsSettingsDesktop = () => {\n  const query = useMemo(() => `(min-width: calc(${BREAKPOINTS.settings} + 1px))`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Get a consistent breakpoint value across the app\n * @returns {{mobile: string, tablet: string, desktop: string, settings: string}}\n */\nexport const useBreakpoints = () => {\n  return BREAKPOINTS;\n}; ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","import './utils/polyfills';\nimport React, { Suspense, lazy } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './styles/common/colors.css';\nimport './styles/common/tokens.css';\nimport './styles/theme.css';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { ToastProvider } from './contexts/ToastContext';\nimport { LoadingProvider } from './contexts/LoadingContext';\nimport GlobalLoadingIndicator from './components/common/GlobalLoadingIndicator';\n\n// Lazy-load the App component to reduce initial bundle size\nconst App = lazy(() => import(/* webpackChunkName: \"app-shell\" */ './App'));\n\n// Set initial theme class on <body> so theme mappings (light-mode/dark-mode) take effect\nconst prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n// Apply body class for index.css mappings\ndocument.body.classList.add(prefersDark ? 'dark-mode' : 'light-mode');\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <ToastProvider>\n      <LoadingProvider>\n        <Suspense fallback={\n          <div style={{ \n            display: 'flex', \n            justifyContent: 'center', \n            alignItems: 'center', \n            height: '100vh' \n          }}>\n            Loading...\n          </div>\n        }>\n          <App />\n        </Suspense>\n        <GlobalLoadingIndicator />\n      </LoadingProvider>\n    </ToastProvider>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  POST_INTERACTIVE_PRELOAD_START: 'post-interactive-preload-start',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","import React, { createContext, useContext, useRef, useCallback, useMemo, useEffect } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { fetchWithRetry } from '../utils/network';\nimport debounce from 'lodash.debounce';\n// Inline worker via worker-loader to avoid separate chunk files\nimport StreamProcessorWorker from '../workers/streamProcessor.js';\n\n// Create a context for streaming events and logic\nconst StreamingEventsContext = createContext();\n\nexport const useStreamingEvents = () => {\n  const context = useContext(StreamingEventsContext);\n  if (context === undefined) {\n    throw new Error('useStreamingEvents must be used within a StreamingEventsProvider');\n  }\n  return context;\n};\n\nexport const StreamingEventsProvider = ({ children }) => {\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics } = usePerformanceMetrics();\n\n  // Refs for streaming\n  const streamingTextRef = useRef('');\n  const currentRequestIdRef = useRef(null);\n  const abortControllerRef = useRef(null);\n  const isStreamingRef = useRef(false);\n  const firstTokenReceivedRef = useRef(false);\n\n  // Debounced content updater\n  const debouncedUpdateChat = useMemo(\n    () => debounce((content) => updateChatWithContent(content), 20),\n    [updateChatWithContent]\n  );\n\n  // SSE parsing worker setup\n  const streamWorkerUrlRef = useRef(null);\n  const streamWorkerRef = useRef(null);\n  const getOrCreateStreamWorker = useCallback(() => {\n    if (!streamWorkerRef.current) {\n      streamWorkerRef.current = new StreamProcessorWorker();\n    }\n    return streamWorkerRef.current;\n  }, []);\n\n  const parseStreamChunk = useCallback((chunk) => new Promise((resolve, reject) => {\n    const worker = getOrCreateStreamWorker();\n    worker.onmessage = (e) => resolve(e.data);\n    worker.onerror = reject;\n    worker.postMessage(chunk);\n  }), [getOrCreateStreamWorker]);\n\n  // Stream a message using fetch SSE\n  const streamMessageWithFetch = useCallback(async (message, editIndex = null) => {\n    // Generate and store a client-side requestId for this stream\n    const requestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = requestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = `${selectedModel.provider}/${selectedModel.id}`;\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        const original = prev[editIndex];\n        // Preserve original id/timestamp, only update content\n        userMessage = { ...original, content: message };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    resetPerformanceMetrics();\n    startPerformanceTimer();\n    firstTokenReceivedRef.current = false;\n    setIsWaitingForResponse(true);\n    setError(null);\n    streamingTextRef.current = '';\n    isStreamingRef.current = true;\n    addMessageToHistory('assistant', '');\n    let timeoutId = setTimeout(() => {\n      abortControllerRef.current?.abort('timeout');\n      setError('Connection timed out');\n      setIsWaitingForResponse(false);\n    }, 60000);\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      // Build API history without the placeholder assistant message (empty content)\n      const historyForApi = chatHistoryRef.current\n        .slice(0, -1)\n        .map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now() - 1 });\n      }\n      const payload = {\n        requestId,\n        model: modelId,\n        messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'text/event-stream', 'Cache-Control': 'no-cache' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/stream', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload), signal: abortController.signal, cache: 'no-store'\n      });\n      if (!response.ok) throw new Error(`API error: ${response.status}`);\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder('utf-8');\n      let accumulatedContent = '';\n      while (true) {\n        const { done, value } = await reader.read();\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n          abortControllerRef.current?.abort();\n          setError('Connection timed out');\n          setIsWaitingForResponse(false);\n        }, 60000);\n        if (done) {\n          // handle leftover buffer\n          break;\n        }\n        const chunk = decoder.decode(value, { stream: true });\n\n        console.log('Received stream chunk:', chunk);\n\n        try {\n          const msgs = await parseStreamChunk(chunk);\n          for (const msg of msgs) {\n            // Handle server-sent error payload\n            if (msg.rawChunk?.error || msg.finishReason === 'error') {\n              const errMsg = msg.rawChunk?.error?.message || 'Error occurred during generation';\n              console.error('Error in SSE payload:', errMsg);\n              setError(errMsg);\n              setChatHistory(prev => {\n                const newHistory = [...prev];\n                const lastMsg = newHistory[newHistory.length - 1];\n                if (lastMsg && lastMsg.role === 'assistant') {\n                  lastMsg.content += `\\n\\n**Error:** ${errMsg}`;\n                  if (lastMsg.metrics) {\n                    lastMsg.metrics.isComplete = true;\n                    lastMsg.metrics.error = true;\n                  }\n                }\n                return newHistory;\n              });\n              return null;\n            }\n            // Append any content from the chunk\n            if (msg.content) {\n              // Record time to first token once\n              if (!firstTokenReceivedRef.current) {\n                updatePerformanceMetrics(1);\n                firstTokenReceivedRef.current = true;\n              }\n              accumulatedContent += msg.content;\n              streamingTextRef.current = accumulatedContent;\n              debouncedUpdateChat(accumulatedContent);\n            }\n            // Always use server-reported completion tokens for metrics\n            const completionTokens = msg.usage?.completionTokens ?? 0;\n            updatePerformanceMetrics(completionTokens, msg.isDone, msg.usage, msg.finishReason);\n          }\n        } catch {}\n      }\n      debouncedUpdateChat.flush();\n      updateChatWithContent(streamingTextRef.current);\n      return streamingTextRef.current;\n    } catch (error) {\n      console.error('Error streaming message:', error);\n      setError(error.message);\n      // Show the server error content as the assistant's message\n      setChatHistory(prev => {\n        const newHistory = [...prev];\n        const lastMsg = newHistory[newHistory.length - 1];\n        if (lastMsg && lastMsg.role === 'assistant') {\n          lastMsg.content += `\\n\\n**Error:** ${error.message || 'Error occurred during generation'}`;\n          if (lastMsg.metrics) {\n            lastMsg.metrics.isComplete = true;\n            lastMsg.metrics.error = true;\n          }\n        }\n        return newHistory;\n      });\n      return null;\n    } finally {\n      clearTimeout(timeoutId);\n      isStreamingRef.current = false;\n      setIsWaitingForResponse(false);\n      // Do not auto-call stop endpoint here; only explicit stop should trigger it\n      currentRequestIdRef.current = null;\n    }\n  }, [\n    apiUrl, selectedModel, getModelAdjustedSettings, idToken,\n    chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent,\n    debouncedUpdateChat, setError, setIsWaitingForResponse,\n    resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics,\n    parseStreamChunk\n  ]);\n\n  const stopStreaming = useCallback(async () => {\n    if (abortControllerRef.current) abortControllerRef.current.abort('user_stopped');\n    const reqId = currentRequestIdRef.current;\n    if (reqId) {\n      const headers = { 'Content-Type': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      try {\n        await fetchWithRetry(new URL('/api/chat/stop', apiUrl).toString(), {\n          method: 'POST', headers, body: JSON.stringify({ requestId: reqId })\n        });\n      } catch {} finally {\n        currentRequestIdRef.current = null;\n        abortControllerRef.current = null;\n      }\n    }\n    isStreamingRef.current = false;\n    setIsWaitingForResponse(false);\n    return true;\n  }, [apiUrl, idToken, setIsWaitingForResponse]);\n\n  const value = useMemo(() => ({\n    streamMessageWithFetch,\n    stopStreaming,\n    parseStreamChunk,\n    streamingTextRef,\n    isStreaming: () => isStreamingRef.current\n  }), [streamMessageWithFetch, stopStreaming, parseStreamChunk]);\n\n  return (\n    <StreamingEventsContext.Provider value={value}>\n      {children}\n    </StreamingEventsContext.Provider>\n  );\n}; ","import { useSettings } from '../contexts/SettingsContext';\nimport { useCacheToggle } from './useCacheToggle';\nimport { useAuth } from '../contexts/AuthContext';\n\n/**\n * Hook to provide consolidated settings control logic\n * @returns {Object} settings controller with settings, updateSetting, resetSettings, cacheEnabled, toggleCache, and currentUser\n */\nexport const useSettingsController = () => {\n  const {\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings\n  } = useSettings();\n  const { cacheEnabled, toggleCache } = useCacheToggle();\n  const { currentUser } = useAuth();\n\n  return {\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings,\n    cacheEnabled,\n    toggleCache,\n    currentUser\n  };\n}; ","export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\n// Fetch Firebase configuration from environment variables\nconst firebaseConfig = {\n  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.REACT_APP_FIREBASE_APP_ID,\n  // measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID // Optional\n};\n\nlet app = null;\nlet auth = null;\n\nexport const initializeFirebase = () => {\n  if (app) return { app, auth };\n\n  if (\n    firebaseConfig.apiKey &&\n    firebaseConfig.authDomain &&\n    firebaseConfig.projectId &&\n    firebaseConfig.appId\n  ) {\n    try {\n      app = initializeApp(firebaseConfig);\n      auth = getAuth(app);\n      console.log(\"Firebase initialized successfully.\");\n    } catch (error) {\n      console.error(\"Firebase initialization failed:\", error);\n      app = null;\n      auth = null;\n    }\n  } else {\n    console.warn(\n      \"Firebase configuration environment variables are missing. \" +\n      \"Please set REACT_APP_FIREBASE_API_KEY, REACT_APP_FIREBASE_AUTH_DOMAIN, \" +\n      \"REACT_APP_FIREBASE_PROJECT_ID, and REACT_APP_FIREBASE_APP_ID in your .env file.\"\n    );\n  }\n  \n  return { app, auth };\n};\n\nexport const getFirebaseAuth = () => {\n  if (!auth) {\n    const { auth: newAuth } = initializeFirebase();\n    return newAuth;\n  }\n  return auth;\n};\n\nexport const getFirebaseApp = () => {\n  if (!app) {\n    const { app: newApp } = initializeFirebase();\n    return newApp;\n  }\n  return app;\n}; ","/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  // eslint-disable-next-line no-useless-escape\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","import { useCallback } from 'react';\nimport { useChatState } from '../contexts/ChatStateContext';\nimport { useChatControl } from '../contexts/ChatControlContext';\nimport { useModel } from '../contexts/ModelContext';\nimport { useSettings } from '../contexts/SettingsContext';\n\n// Helper to generate unique IDs\nconst generateUniqueId = () => {\n  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n};\n\n/**\n * Custom Hook for Chat Container Logic\n * Encapsulates state management, API calls, and event handlers \n * related to the chat interface.\n */\nexport const useChatLogic = () => {\n  const {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    currentMessageMetrics: metrics\n  } = useChatState();\n  const { sendMessage: submitMessage, clearChat: resetChat, downloadChatHistory } = useChatControl();\n  \n  const { selectedModel } = useModel();\n  const { settings } = useSettings();\n  \n  // Enhanced function to handle sending messages, including edits\n  const handleSendMessage = useCallback(async (message, editedMessage = null) => {\n    const isEditing = !!editedMessage;\n    \n    // Handle both string and array payloads for content validation\n    const messageContent = Array.isArray(message) \n      ? message.map(part => part.type === 'text' ? part.text : '').join(' ').trim()\n      : message;\n\n    if (!messageContent && !Array.isArray(message)) return;\n    if (!selectedModel) return;\n    \n    try {\n      if (isEditing) {\n        // Get or create unique identifier for the message\n        const editMsgId = editedMessage.uniqueId || editedMessage.id || editedMessage.timestamp;\n        // Find the index of the message being edited with a single pass\n        const editIndex = chatHistory.findIndex(msg =>\n          [msg.uniqueId, msg.id, msg.timestamp].includes(editMsgId) ||\n          (typeof msg.content === 'string' && msg.content === editedMessage.content && msg.role === 'user')\n        );\n        if (editIndex === -1) {\n          return;\n        }\n        // Ensure the message to be submitted has the correct uniqueId\n        const finalMessage = Array.isArray(message) ? message : { type: 'text', text: message };\n        \n        // Add uniqueId to message\n        if (Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = editMsgId;\n        } else {\n          finalMessage.uniqueId = editMsgId;\n        }\n        \n        // Call the submitMessage function with the truncated history index\n        await submitMessage(finalMessage, editIndex);\n      } else {\n        // For new messages, generate a unique ID\n        const uniqueId = generateUniqueId();\n        \n        // Add uniqueId to new message\n        const finalMessage = Array.isArray(message) \n          ? message.map(part => ({...part, uniqueId}))\n          : message;\n          \n        if (!Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = uniqueId;\n        }\n        \n        // Normal message submission with uniqueId\n        await submitMessage(finalMessage);\n      }\n    } catch (err) {\n      console.error(`Error ${isEditing ? 'editing' : 'submitting'} message:`, err);\n    }\n  }, [selectedModel, submitMessage, chatHistory]);\n\n  // Return values needed by the ChatContainer component\n  return {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics,\n    selectedModel,\n    settings,\n    handleSendMessage,\n    resetChat, \n    downloadChatHistory,\n  };\n}; ","export async function fetchWithRetry(input, init = {}, retries = 3, backoff = 500) {\n  let attempt = 0;\n  while (true) {\n    try {\n      const response = await fetch(input, init);\n      if (!response.ok) {\n        throw new Error(`Network error: ${response.status}`);\n      }\n      return response;\n    } catch (error) {\n      if (attempt >= retries) {\n        throw error;\n      }\n      // Exponential backoff with jitter\n      const delay = backoff * Math.pow(2, attempt) + Math.random() * 100;\n      await new Promise(res => setTimeout(res, delay));\n      attempt++;\n    }\n  }\n} ","import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n\n// Create theme context\nconst ThemeContext = createContext();\n\n// Custom hook for using theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n\n// Theme provider component\nexport const ThemeProvider = ({ children }) => {\n  // Initialize theme from localStorage or default to 'dark'\n  const [theme, setTheme] = useState(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return savedTheme || 'dark';\n  });\n\n  // Toggle between light and dark themes\n  const toggleTheme = useCallback(() => {\n    setTheme(prevTheme => {\n      const newTheme = prevTheme === 'dark' ? 'light' : 'dark';\n      localStorage.setItem('theme', newTheme);\n      return newTheme;\n    });\n  }, []);\n\n  // Apply theme class to body element\n  useEffect(() => {\n    document.body.classList.remove('light-mode', 'dark-mode');\n    document.body.classList.add(`${theme}-mode`);\n  }, [theme]);\n\n  // Context value - memoized to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme, toggleTheme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useReducer, useCallback } from 'react';\nimport ToastContainer from '../components/common/ToastNotification';\n\n// Create context for toast notifications\nconst ToastContext = createContext();\n\n// Hook to use toast context\nexport const useToast = () => {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within a ToastProvider');\n  }\n  return context;\n};\n\n// Action types\nconst ADD_TOAST = 'ADD_TOAST';\nconst REMOVE_TOAST = 'REMOVE_TOAST';\n\n// Reducer to manage toast list\nfunction toastReducer(state, action) {\n  switch (action.type) {\n    case ADD_TOAST:\n      return [...state, action.payload];\n    case REMOVE_TOAST:\n      return state.filter(toast => toast.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// Provider component that holds toast state and renders toasts\nexport const ToastProvider = ({ children }) => {\n  const [toasts, dispatch] = useReducer(toastReducer, []);\n\n  // Function to show a toast\n  const showToast = useCallback(({ type, message, duration = 3000 }) => {\n    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);\n    dispatch({ type: ADD_TOAST, payload: { id, type, message, duration } });\n    // Auto-dismiss toast after duration\n    setTimeout(() => dispatch({ type: REMOVE_TOAST, payload: id }), duration);\n    return id;\n  }, []);\n\n  // Function to manually dismiss a toast\n  const dismissToast = useCallback(id => {\n    dispatch({ type: REMOVE_TOAST, payload: id });\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ showToast, dismissToast }}>\n      {children}\n      <ToastContainer toasts={toasts} dismissToast={dismissToast} />\n    </ToastContext.Provider>\n  );\n}; "],"names":["loadedChunks","Set","loadingChunks","Map","loadChunkGroup","async","importMap","options","arguments","length","undefined","groupName","priority","timeout","retries","has","Promise","resolve","get","loadPromise","loadWithRetry","set","add","delete","error","lastError","attempt","timeoutPromise","_","reject","setTimeout","Error","all","Object","entries","map","key","importFn","_ref","module","race","delay","Math","pow","idlePreloadChunks","chunkGroups","maxConcurrent","priorityDelay","idleTimeout","currentlyLoading","queue","sort","_ref2","_ref3","a","b","processQueue","config","shift","requestIdleCallback","imports","createSmallChunkBundle","modules","bundleName","bundleImport","moduleImport","then","results","filter","Boolean","createChunkMonitor","metrics","loadTimes","failures","totalLoaded","totalFailed","startLoad","chunkName","performance","now","endLoad","success","getMetrics","fromEntries","reset","clear","createAdaptiveLoader","getNetworkInfo","navigator","conn","connection","effectiveType","downlink","rtt","saveData","getStrategy","getLoadingStrategy","network","skipNonEssential","useProfilePicture","imageUrl","cacheKey","cachedEntry","setCachedEntry","useLocalStorage","profilePicture","setProfilePicture","useState","loading","setLoading","setError","useEffect","isMounted","entry","wrapped","data","timestamp","Date","fetch","response","ok","status","blob","reader","FileReader","onloadend","result","onerror","readAsDataURL","dataUrl","entryToCache","catch","err","finally","BREAKPOINTS","mediaQueryListeners","useMediaQuery","query","matches","setMatches","window","matchMedia","mediaQueryList","listeners","queryData","listener","event","addEventListener","removeEventListener","size","addListener","removeListener","useIsDesktop","useMemo","useIsSettingsMobile","initialValue","initialValueRef","useRef","storedValue","setStoredValue","item","localStorage","getItem","JSON","parse","current","setValue","useCallback","value","valueToStore","Function","setItem","stringify","isLocalhost","location","hostname","match","registerValidSW","swUrl","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","App","lazy","prefersDark","onPerfEntry","document","body","classList","ReactDOM","getElementById","render","_jsx","React","children","ToastProvider","_jsxs","LoadingProvider","Suspense","fallback","style","display","justifyContent","alignItems","height","GlobalLoadingIndicator","getCLS","getFID","getFCP","getLCP","getTTFB","URL","process","href","origin","headers","contentType","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","waitingServiceWorker","waiting","target","postMessage","type","PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","POST_INTERACTIVE_PRELOAD_START","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","measures","trackPaintMetrics","PerformanceObserver","getEntries","forEach","markName","name","mark","measureName","measure","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clearMarks","clearMeasures","logMetrics","StreamingEventsContext","createContext","useStreamingEvents","context","useContext","StreamingEventsProvider","apiUrl","useApi","selectedModel","useModel","getModelAdjustedSettings","useSettings","idToken","useAuth","chatHistoryRef","setChatHistory","addMessageToHistory","updateChatWithContent","useChatHistory","setIsWaitingForResponse","useChatStatus","resetPerformanceMetrics","startPerformanceTimer","updatePerformanceMetrics","usePerformanceMetrics","streamingTextRef","currentRequestIdRef","abortControllerRef","isStreamingRef","firstTokenReceivedRef","debouncedUpdateChat","debounce","content","streamWorkerRef","getOrCreateStreamWorker","StreamProcessorWorker","parseStreamChunk","chunk","worker","onmessage","e","streamMessageWithFetch","message","editIndex","requestId","crypto","randomUUID","random","toString","substring","isEditing","Number","isInteger","modelId","provider","id","userMessage","prev","truncated","slice","original","timeoutId","_abortControllerRef$c","abort","abortController","AbortController","adjusted","historyForApi","m","systemPrompt","role","unshift","payload","model","messages","temperature","max_tokens","top_p","frequency_penalty","presence_penalty","fetchWithRetry","method","signal","cache","getReader","decoder","TextDecoder","accumulatedContent","done","read","clearTimeout","_abortControllerRef$c2","decode","stream","msgs","msg","_msg$rawChunk","_msg$usage$completion","_msg$usage","rawChunk","finishReason","_msg$rawChunk2","_msg$rawChunk2$error","errMsg","newHistory","lastMsg","isComplete","completionTokens","usage","isDone","flush","stopStreaming","reqId","isStreaming","Provider","useSettingsController","settings","updateSetting","resetSettings","shouldRestrictTemperature","cacheEnabled","toggleCache","useCacheToggle","currentUser","processMessageContent","images","text","Array","isArray","texts","reduce","acc","part","push","url","image_url","alt","join","formatTime","ms","toFixed","setCacheEnabled","clearModelCache","removeItem","enabled","newValue","refreshModels","originalFunc","isCacheValid","allModels","processedModels","experimentalModels","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","app","auth","getFirebaseAuth","newAuth","initializeFirebase","initializeApp","getAuth","convertTeXToMathDollars","combinedRegex","RegExp","replace","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","trim","useChatLogic","chatHistory","isWaitingForResponse","currentMessageMetrics","useChatState","sendMessage","submitMessage","clearChat","resetChat","downloadChatHistory","useChatControl","handleSendMessage","editedMessage","editMsgId","uniqueId","findIndex","includes","finalMessage","input","init","backoff","res","ThemeContext","useTheme","ThemeProvider","theme","setTheme","toggleTheme","prevTheme","newTheme","remove","isDark","ToastContext","useToast","ADD_TOAST","REMOVE_TOAST","toastReducer","action","toast","toasts","dispatch","useReducer","showToast","duration","substr","dismissToast","ToastContainer"],"sourceRoot":""}
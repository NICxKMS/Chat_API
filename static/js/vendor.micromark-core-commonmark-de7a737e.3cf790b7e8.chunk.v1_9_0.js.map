{"version":3,"file":"static/js/vendor.micromark-core-commonmark-de7a737e.3cf790b7e8.chunk.v1_9_0.js","mappings":"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","sources":["../node_modules/micromark-core-commonmark/lib/html-text.js","../node_modules/micromark-core-commonmark/lib/html-flow.js","../node_modules/micromark-core-commonmark/lib/line-ending.js","../node_modules/micromark-core-commonmark/lib/label-end.js","../node_modules/micromark-core-commonmark/lib/label-start-image.js","../node_modules/micromark-core-commonmark/lib/label-start-link.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code> | undefined} */\n  let marker\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n  return start\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      index = 0\n      return cdataOpenInside\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n    return nok(code)\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return nok(code)\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return comment\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return comment(code)\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === 62\n      ? end(code)\n      : code === 45\n      ? commentClose(code)\n      : comment(code)\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === value.length ? cdata : cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return cdata\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return declaration\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return instruction\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return tagCloseBetween(code)\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n    return tagOpenBetween(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      marker = undefined\n      return tagOpenAttributeValueQuotedAfter\n    }\n    if (code === null) {\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n    return nok(code)\n  }\n\n  /**\n   * At eol.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineEndingAfter\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          lineEndingAfterPrefix,\n          'linePrefix',\n          self.parser.constructs.disable.null.includes('codeIndented')\n            ? undefined\n            : 4\n        )(code)\n      : lineEndingAfterPrefix(code)\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {\n  tokenize: tokenizeBlankLineBefore,\n  partial: true\n}\nconst nonLazyContinuationStart = {\n  tokenize: tokenizeNonLazyContinuationStart,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      marker = 3\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      marker = 2\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      marker = 5\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = 4\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n      return cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === 47\n      const name = buffer.toLowerCase()\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = 1\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = 6\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      marker = 7\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n        ? completeClosingTagAfter(code)\n        : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 47 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n    if (code === 60 && marker === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n    if (code === 62 && marker === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n    if (code === 63 && marker === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    if (code === 93 && marker === 5) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n    if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {\n      effects.exit('htmlFlowData')\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationStart(code)\n    }\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === 62) {\n      const name = buffer.toLowerCase()\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n      return continuation(code)\n    }\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationAfter(code)\n    }\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit('htmlFlow')\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means we’d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We can’t have that, so it’s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, it’s nothing.\n   *\n   * There was an okay opening, but we didn’t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if there’s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (image) start.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  /**\n   * After `!`, at `[`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `![`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *         ^\n   * ```\n   *\n   * This is needed in because, when GFM footnotes are enabled, images never\n   * form when started with a `^`.\n   * Instead, links form:\n   *\n   * ```markdown\n   * ![^a](b)\n   *\n   * ![^a][b]\n   *\n   * [b]: c\n   * ```\n   *\n   * ```html\n   * <p>!<a href=\\\"b\\\">^a</a></p>\n   * <p>!<a href=\\\"c\\\">^a</a></p>\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // To do: use a new field to do this, this is still needed for\n    // `micromark-extension-gfm-footnote`, but the `label-start-link`\n    // behavior isn’t.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (link) start.\n   *\n   * ```markdown\n   * > | a [b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  /** @type {State} */\n  function after(code) {\n    // To do: this isn’t needed in `micromark-extension-gfm-footnote`,\n    // remove.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n"],"names":["htmlText","name","tokenize","effects","ok","nok","self","this","marker","index","returnState","code","enter","consume","open","declarationOpen","tagCloseStart","instruction","asciiAlpha","tagOpen","commentOpenInside","cdataOpenInside","declaration","commentEnd","comment","commentClose","markdownLineEnding","lineEndingBefore","end","value","charCodeAt","cdata","cdataClose","cdataEnd","instructionClose","tagClose","asciiAlphanumeric","tagCloseBetween","markdownSpace","markdownLineEndingOrSpace","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","undefined","tagOpenAttributeValueQuotedAfter","exit","lineEndingAfter","factorySpace","lineEndingAfterPrefix","parser","constructs","disable","null","includes","htmlFlow","closingTag","buffer","markerB","before","interrupt","continuationDeclarationInside","String","fromCharCode","tagName","continuation","slash","toLowerCase","htmlRawNames","htmlBlockNames","basicSelfClosing","lazy","now","line","completeClosingTagAfter","completeAttributeNameBefore","completeEnd","completeAttributeName","completeAttributeNameAfter","completeAttributeValueBefore","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","continuationCdataInside","continuationStart","check","blankLineBefore","continuationAfter","nonLazyContinuationStart","continuationStartNonLazy","continuationBefore","continuationRawEndTag","length","resolveTo","events","type","start","splice","concrete","attempt","blankLine","partial","after","lineEnding","labelEnd","labelStart","defined","_balanced","_inactive","labelEndNok","normalizeIdentifier","sliceSerialize","resourceConstruct","labelEndOk","referenceFullConstruct","referenceNotFull","referenceCollapsedConstruct","context","token","close","media","offset","group","Object","assign","label","text","push","slice","resolveAll","insideSpan","resourceBefore","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","factoryLabel","call","referenceFullAfter","referenceFullMissing","referenceCollapsedOpen","labelStartImage","labelStartLink"],"sourceRoot":""}
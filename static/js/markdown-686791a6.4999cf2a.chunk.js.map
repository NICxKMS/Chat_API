{"version":3,"file":"static/js/markdown-686791a6.4999cf2a.chunk.js","mappings":"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","sources":["../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/thematic-break.js","../node_modules/react-markdown/node_modules/micromark-factory-title/index.js","../node_modules/react-markdown/node_modules/micromark-factory-destination/index.js","../node_modules/react-markdown/node_modules/micromark-factory-label/index.js","../node_modules/react-markdown/node_modules/micromark-factory-whitespace/index.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of thematic break.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('thematicBreak')\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at marker.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    marker = code\n    return atBreak(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n    if (size >= 3 && (code === null || markdownLineEnding(code))) {\n      effects.exit('thematicBreak')\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n    effects.exit('thematicBreakSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, atBreak, 'whitespace')(code)\n      : atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * Parse titles.\n *\n * ###### Examples\n *\n * ```markdown\n * \"a\"\n * 'b'\n * (c)\n * \"a\n * b\"\n * 'a\n *     b'\n * (a\\)b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole title (`\"a\"`, `'b'`, `(c)`).\n * @param {TokenType} markerType\n *   Type for the markers (`\"`, `'`, `(`, and `)`).\n * @param {TokenType} stringType\n *   Type for the value (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of title.\n   *\n   * ```markdown\n   * > | \"a\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      effects.enter(type)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      marker = code === 40 ? 41 : code\n      return begin\n    }\n    return nok(code)\n  }\n\n  /**\n   * After opening marker.\n   *\n   * This is also used at the closing marker.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function begin(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    return atBreak(code)\n  }\n\n  /**\n   * At something, before something else.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return begin(marker)\n    }\n    if (code === null) {\n      return nok(code)\n    }\n\n    // Note: blank lines can’t exist in content.\n    if (markdownLineEnding(code)) {\n      // To do: use `space_or_tab_eol_with_options`, connect.\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atBreak, 'linePrefix')\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return inside(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? escape : inside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | \"a\\*b\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function escape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return inside\n    }\n    return inside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n/**\n * Parse destinations.\n *\n * ###### Examples\n *\n * ```markdown\n * <a>\n * <a\\>b>\n * <a b>\n * <a)>\n * a\n * a\\)b\n * a(b)c\n * a(b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type for whole (`<a>` or `b`).\n * @param {TokenType} literalType\n *   Type when enclosed (`<a>`).\n * @param {TokenType} literalMarkerType\n *   Type for enclosing (`<` and `>`).\n * @param {TokenType} rawType\n *   Type when not enclosed (`b`).\n * @param {TokenType} stringType\n *   Type for the value (`a` or `b`).\n * @param {number | undefined} [max=Infinity]\n *   Depth of nested parens (inclusive).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n\n  /**\n   * Start of destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *     ^\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return enclosedBefore\n    }\n\n    // ASCII control, space, closing paren.\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return raw(code)\n  }\n\n  /**\n   * After `<`, at an enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return enclosed(code)\n  }\n\n  /**\n   * In enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return enclosedBefore(code)\n    }\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? enclosedEscape : enclosed\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | <a\\*a>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return enclosed\n    }\n    return enclosed(code)\n  }\n\n  /**\n   * In raw destination.\n   *\n   * ```markdown\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function raw(code) {\n    if (\n      !balance &&\n      (code === null || code === 41 || markdownLineEndingOrSpace(code))\n    ) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n    if (balance < limit && code === 40) {\n      effects.consume(code)\n      balance++\n      return raw\n    }\n    if (code === 41) {\n      effects.consume(code)\n      balance--\n      return raw\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesn’t.\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? rawEscape : raw\n  }\n\n  /**\n   * After `\\`, at special character.\n   *\n   * ```markdown\n   * > | a\\*a\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function rawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return raw\n    }\n    return raw(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse labels.\n *\n * > 👉 **Note**: labels in markdown are capped at 999 characters in the string.\n *\n * ###### Examples\n *\n * ```markdown\n * [a]\n * [a\n * b]\n * [a\\]b]\n * ```\n *\n * @this {TokenizeContext}\n *   Tokenize context.\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole label (`[a]`).\n * @param {TokenType} markerType\n *   Type for the markers (`[` and `]`).\n * @param {TokenType} stringType\n *   Type for the identifier (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /**\n   * Start of label.\n   *\n   * ```markdown\n   * > | [a]\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  /**\n   * In label, at something, before something else.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (\n      size > 999 ||\n      code === null ||\n      code === 91 ||\n      (code === 93 && !seen) ||\n      // To do: remove in the future once we’ve switched from\n      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n      // which doesn’t need this.\n      // Hidden footnotes hook.\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    // To do: indent? Link chunks and EOLs together?\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return labelInside(code)\n  }\n\n  /**\n   * In label, in text.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    if (!seen) seen = !markdownSpace(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | [a\\*a]\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   line endings or spaces in markdown are often optional, in which case this\n *     factory can be used and `ok` will be switched to whether spaces were found\n *     or not\n * *   one line ending or space can be detected with\n *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @returns\n *   Start state.\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = 'setextHeadingText'\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== 'lineEnding' &&\n        self.events[index][1].type !== 'linePrefix' &&\n        self.events[index][1].type !== 'content'\n      ) {\n        paragraph = self.events[index][1].type === 'paragraph'\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      marker = code\n      return before(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('setextHeadingLineSequence')\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    effects.exit('setextHeadingLineSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'lineSuffix')(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n"],"names":["thematicBreak","name","tokenize","effects","ok","nok","marker","size","code","enter","atBreak","before","sequence","markdownLineEnding","exit","consume","markdownSpace","factorySpace","factoryTitle","type","markerType","stringType","begin","contentType","inside","escape","factoryDestination","literalType","literalMarkerType","rawType","max","limit","Number","POSITIVE_INFINITY","balance","enclosedBefore","asciiControl","raw","enclosed","enclosedEscape","markdownLineEndingOrSpace","rawEscape","factoryLabel","self","this","seen","parser","constructs","labelInside","labelEscape","factoryWhitespace","start","setextUnderline","paragraph","index","events","length","lazy","now","line","interrupt","after","resolveTo","context","content","text","definition","splice","heading","Object","assign","end","push"],"sourceRoot":""}
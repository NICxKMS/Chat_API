{"version":3,"file":"static/js/markdown-bbfa9bc6.a94ea96d.chunk.js","mappings":"2KAgBO,MAAMA,EAAY,CACvBC,KAAM,YACNC,SA4KF,SAA2BC,EAASC,GAClC,MAAMC,EAAmBC,KAAKC,OAAOC,WAAWH,iBAAiBI,KAC3DC,EAAWJ,KAAKI,SAChBC,GAASC,EAAAA,EAAAA,GAAkBF,GAGjC,IAAIG,EACJ,OAYA,SAAeC,GAGb,OAFAD,EAASC,EACTX,EAAQY,MAAM,qBACPC,EAAOF,EAChB,EAYA,SAASE,EAAOF,GACd,GAAIA,IAASD,EAEX,OADAV,EAAQc,QAAQH,GACTE,EAET,MAAME,EAAQf,EAAQgB,KAAK,qBAGrBC,GAAQR,EAAAA,EAAAA,GAAkBE,GAI1BO,GACHD,GAAoB,IAAVA,GAAeT,GAAWN,EAAiBiB,SAASR,GAC3DS,GACHZ,GAAsB,IAAXA,GAAgBS,GAAUf,EAAiBiB,SAASZ,GAGlE,OAFAQ,EAAMM,MAAQC,QAAmB,KAAXZ,EAAgBQ,EAAOA,IAASV,IAAWY,IACjEL,EAAMQ,OAASD,QAAmB,KAAXZ,EAAgBU,EAAQA,IAAUH,IAAUC,IAC5DjB,EAAGU,EACZ,CACF,EAlOEa,WAQF,SAA6BC,EAAQC,GACnC,IAEIR,EAEAS,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAhBAC,GAAS,EAsBb,OAASA,EAAQT,EAAOU,QAEtB,GACuB,UAArBV,EAAOS,GAAO,IACY,sBAA1BT,EAAOS,GAAO,GAAGE,MACjBX,EAAOS,GAAO,GAAGX,OAKjB,IAHAL,EAAOgB,EAGAhB,KAEL,GACsB,SAApBO,EAAOP,GAAM,IACY,sBAAzBO,EAAOP,GAAM,GAAGkB,MAChBX,EAAOP,GAAM,GAAGG,OAEhBK,EAAQW,eAAeZ,EAAOP,GAAM,IAAIoB,WAAW,KACjDZ,EAAQW,eAAeZ,EAAOS,GAAO,IAAII,WAAW,GACtD,CAKA,IACGb,EAAOP,GAAM,GAAGK,QAAUE,EAAOS,GAAO,GAAGb,SAC3CI,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,QAAU,MAE7DR,EAAOP,GAAM,GAAGqB,IAAIN,OACnBR,EAAOP,GAAM,GAAGsB,MAAMP,OACtBR,EAAOS,GAAO,GAAGK,IAAIN,OACrBR,EAAOS,GAAO,GAAGM,MAAMP,QACzB,GAGF,SAIFF,EACEN,EAAOP,GAAM,GAAGqB,IAAIN,OAASR,EAAOP,GAAM,GAAGsB,MAAMP,OAAS,GAC5DR,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,OAAS,EAC1D,EACA,EACN,MAAMO,EAAQC,OAAOC,OAAO,CAAC,EAAGjB,EAAOP,GAAM,GAAGqB,KAC1CA,EAAME,OAAOC,OAAO,CAAC,EAAGjB,EAAOS,GAAO,GAAGM,OAC/CG,EAAUH,GAAQT,GAClBY,EAAUJ,EAAKR,GACfF,EAAkB,CAChBO,KAAML,EAAM,EAAI,iBAAmB,mBACnCS,QACAD,IAAKE,OAAOC,OAAO,CAAC,EAAGjB,EAAOP,GAAM,GAAGqB,MAEzCT,EAAkB,CAChBM,KAAML,EAAM,EAAI,iBAAmB,mBACnCS,MAAOC,OAAOC,OAAO,CAAC,EAAGjB,EAAOS,GAAO,GAAGM,OAC1CD,OAEFX,EAAO,CACLQ,KAAML,EAAM,EAAI,aAAe,eAC/BS,MAAOC,OAAOC,OAAO,CAAC,EAAGjB,EAAOP,GAAM,GAAGqB,KACzCA,IAAKE,OAAOC,OAAO,CAAC,EAAGjB,EAAOS,GAAO,GAAGM,QAE1Cb,EAAQ,CACNS,KAAML,EAAM,EAAI,SAAW,WAC3BS,MAAOC,OAAOC,OAAO,CAAC,EAAGb,EAAgBW,OACzCD,IAAKE,OAAOC,OAAO,CAAC,EAAGZ,EAAgBS,MAEzCd,EAAOP,GAAM,GAAGqB,IAAME,OAAOC,OAAO,CAAC,EAAGb,EAAgBW,OACxDf,EAAOS,GAAO,GAAGM,MAAQC,OAAOC,OAAO,CAAC,EAAGZ,EAAgBS,KAC3DP,EAAa,GAGTP,EAAOP,GAAM,GAAGqB,IAAIN,OAASR,EAAOP,GAAM,GAAGsB,MAAMP,SACrDD,GAAaY,EAAAA,EAAAA,GAAKZ,EAAY,CAC5B,CAAC,QAASP,EAAOP,GAAM,GAAIQ,GAC3B,CAAC,OAAQD,EAAOP,GAAM,GAAIQ,MAK9BM,GAAaY,EAAAA,EAAAA,GAAKZ,EAAY,CAC5B,CAAC,QAASL,EAAOD,GACjB,CAAC,QAASG,EAAiBH,GAC3B,CAAC,OAAQG,EAAiBH,GAC1B,CAAC,QAASE,EAAMF,KAMlBM,GAAaY,EAAAA,EAAAA,GACXZ,GACAR,EAAAA,EAAAA,GACEE,EAAQtB,OAAOC,WAAWwC,WAAWvC,KACrCmB,EAAOqB,MAAM5B,EAAO,EAAGgB,GACvBR,IAKJM,GAAaY,EAAAA,EAAAA,GAAKZ,EAAY,CAC5B,CAAC,OAAQJ,EAAMF,GACf,CAAC,QAASI,EAAiBJ,GAC3B,CAAC,OAAQI,EAAiBJ,GAC1B,CAAC,OAAQC,EAAOD,KAIdD,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,QACvDA,EAAS,EACTD,GAAaY,EAAAA,EAAAA,GAAKZ,EAAY,CAC5B,CAAC,QAASP,EAAOS,GAAO,GAAIR,GAC5B,CAAC,OAAQD,EAAOS,GAAO,GAAIR,MAG7BO,EAAS,GAEXc,EAAAA,EAAAA,GAAOtB,EAAQP,EAAO,EAAGgB,EAAQhB,EAAO,EAAGc,GAC3CE,EAAQhB,EAAOc,EAAWG,OAASF,EAAS,EAC5C,KACF,CAMNC,GAAS,EACT,OAASA,EAAQT,EAAOU,QACQ,sBAA1BV,EAAOS,GAAO,GAAGE,OACnBX,EAAOS,GAAO,GAAGE,KAAO,QAG5B,OAAOX,CACT,GAyEA,SAASkB,EAAUK,EAAOf,GACxBe,EAAMC,QAAUhB,EAChBe,EAAMf,QAAUA,EAChBe,EAAME,cAAgBjB,CACxB,C,6DC3PO,MAAMkB,EAAY,CACvBpD,SAQF,SAA2BC,EAASC,EAAImD,GACtC,OAgBA,SAAezC,GACb,OAAO0C,EAAAA,EAAAA,IAAc1C,IACjB2C,EAAAA,EAAAA,GAAatD,EAASiB,EAAO,aAA7BqC,CAA2C3C,GAC3CM,EAAMN,EACZ,EAgBA,SAASM,EAAMN,GACb,OAAgB,OAATA,IAAiB4C,EAAAA,EAAAA,IAAmB5C,GAAQV,EAAGU,GAAQyC,EAAIzC,EACpE,CACF,EA/CE6C,SAAS,E,kDCEJ,MAAMC,EAAW,CACtB3D,KAAM,WACNC,SAOF,SAA0BC,EAASC,EAAImD,GACrC,IAAIM,EAAO,EACX,OAcA,SAAe/C,GAMb,OALAX,EAAQY,MAAM,YACdZ,EAAQY,MAAM,kBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,kBACbhB,EAAQY,MAAM,oBACPM,CACT,EAcA,SAASA,EAAKP,GACZ,OAAIgD,EAAAA,EAAAA,IAAWhD,IACbX,EAAQc,QAAQH,GACTiD,GAEFC,EAAWlD,EACpB,CAcA,SAASiD,EAAmBjD,GAE1B,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,IAAemD,EAAAA,EAAAA,IAAkBnD,IAEjE+C,EAAO,EACAK,EAAyBpD,IAE3BkD,EAAWlD,EACpB,CAcA,SAASoD,EAAyBpD,GAChC,OAAa,KAATA,GACFX,EAAQc,QAAQH,GAChB+C,EAAO,EACAM,IAKG,KAATrD,GAAwB,KAATA,GAAwB,KAATA,IAAemD,EAAAA,EAAAA,IAAkBnD,KAChE+C,IAAS,IAET1D,EAAQc,QAAQH,GACToD,IAETL,EAAO,EACAG,EAAWlD,GACpB,CAYA,SAASqD,EAAUrD,GACjB,OAAa,KAATA,GACFX,EAAQgB,KAAK,oBACbhB,EAAQY,MAAM,kBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,kBACbhB,EAAQgB,KAAK,YACNf,GAII,OAATU,GAA0B,KAATA,GAAwB,KAATA,IAAesD,EAAAA,EAAAA,IAAatD,GACvDyC,EAAIzC,IAEbX,EAAQc,QAAQH,GACTqD,EACT,CAYA,SAASH,EAAWlD,GAClB,OAAa,KAATA,GACFX,EAAQc,QAAQH,GACTuD,IAELC,EAAAA,EAAAA,IAAWxD,IACbX,EAAQc,QAAQH,GACTkD,GAEFT,EAAIzC,EACb,CAYA,SAASuD,EAAiBvD,GACxB,OAAOmD,EAAAA,EAAAA,IAAkBnD,GAAQyD,EAAWzD,GAAQyC,EAAIzC,EAC1D,CAYA,SAASyD,EAAWzD,GAClB,OAAa,KAATA,GACFX,EAAQc,QAAQH,GAChB+C,EAAO,EACAQ,GAEI,KAATvD,GAEFX,EAAQgB,KAAK,oBAAoBoB,KAAO,gBACxCpC,EAAQY,MAAM,kBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,kBACbhB,EAAQgB,KAAK,YACNf,GAEFoE,EAAW1D,EACpB,CAcA,SAAS0D,EAAW1D,GAElB,IAAc,KAATA,IAAemD,EAAAA,EAAAA,IAAkBnD,KAAU+C,IAAS,GAAI,CAC3D,MAAMY,EAAgB,KAAT3D,EAAc0D,EAAaD,EAExC,OADApE,EAAQc,QAAQH,GACT2D,CACT,CACA,OAAOlB,EAAIzC,EACb,CACF,E,kDCjOO,MAAM4D,EAAkB,CAC7BzE,KAAM,kBACNC,SAOF,SAAiCC,EAASC,EAAImD,GAC5C,OAYA,SAAezC,GAKb,OAJAX,EAAQY,MAAM,mBACdZ,EAAQY,MAAM,gBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,gBACNH,CACT,EAYA,SAASA,EAAOF,GAEd,OAAI6D,EAAAA,EAAAA,IAAiB7D,IACnBX,EAAQY,MAAM,wBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,wBACbhB,EAAQgB,KAAK,mBACNf,GAEFmD,EAAIzC,EACb,CACF,E,6DC7CO,MAAM8D,EAAqB,CAChC3E,KAAM,qBACNC,SAOF,SAAoCC,EAASC,EAAImD,GAC/C,MAAMsB,EAAOvE,KACb,IAEIwE,EAEAC,EAJAlB,EAAO,EAKX,OAgBA,SAAe/C,GAKb,OAJAX,EAAQY,MAAM,sBACdZ,EAAQY,MAAM,4BACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,4BACNE,CACT,EAiBA,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFX,EAAQY,MAAM,mCACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,mCACN6D,IAET7E,EAAQY,MAAM,2BACd+D,EAAM,GACNC,EAAOd,EAAAA,GACAgB,EAAMnE,GACf,CAcA,SAASkE,EAAQlE,GACf,OAAa,KAATA,GAAwB,MAATA,GACjBX,EAAQY,MAAM,uCACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,uCACbhB,EAAQY,MAAM,2BACd+D,EAAM,EACNC,EAAOG,EAAAA,GACAD,IAET9E,EAAQY,MAAM,2BACd+D,EAAM,EACNC,EAAOI,EAAAA,GACAF,EAAMnE,GACf,CAmBA,SAASmE,EAAMnE,GACb,GAAa,KAATA,GAAe+C,EAAM,CACvB,MAAM3C,EAAQf,EAAQgB,KAAK,2BAC3B,OACE4D,IAASd,EAAAA,KACRmB,EAAAA,EAAAA,GAA8BP,EAAKrC,eAAetB,KAOrDf,EAAQY,MAAM,4BACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,4BACbhB,EAAQgB,KAAK,sBACNf,GATEmD,EAAIzC,EAUf,CACA,OAAIiE,EAAKjE,IAAS+C,IAASiB,GACzB3E,EAAQc,QAAQH,GACTmE,GAEF1B,EAAIzC,EACb,CACF,E,6DC7IO,MAAMuE,EAAa,CACxBpF,KAAM,aACNC,SAWF,SAAiCC,EAASC,EAAImD,GAC5C,MAAMsB,EAAOvE,KACb,OAYA,SAAeQ,GACb,GAAa,KAATA,EAAa,CACf,MAAMwE,EAAQT,EAAKU,eAWnB,OAVKD,EAAMjE,OACTlB,EAAQY,MAAM,aAAc,CAC1ByE,YAAY,IAEdF,EAAMjE,MAAO,GAEflB,EAAQY,MAAM,oBACdZ,EAAQY,MAAM,oBACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,oBACNC,CACT,CACA,OAAOmC,EAAIzC,EACb,EAYA,SAASM,EAAMN,GACb,OAAI0C,EAAAA,EAAAA,IAAc1C,IAChBX,EAAQY,MAAM,8BACdZ,EAAQc,QAAQH,GAChBX,EAAQgB,KAAK,8BACbhB,EAAQgB,KAAK,oBACNf,IAETD,EAAQgB,KAAK,oBACNf,EAAGU,GACZ,CACF,EA/DE2E,aAAc,CACZvF,SA4EJ,SAAwCC,EAASC,EAAImD,GACnD,MAAMsB,EAAOvE,KACb,OAeA,SAAmBQ,GACjB,IAAI0C,EAAAA,EAAAA,IAAc1C,GAGhB,OAAO2C,EAAAA,EAAAA,GACLtD,EACAuF,EACA,aACAb,EAAKtE,OAAOC,WAAWmF,QAAQlF,KAAKa,SAAS,qBACzCsE,EACA,EANCnC,CAOL3C,GAEJ,OAAO4E,EAAW5E,EACpB,EAeA,SAAS4E,EAAW5E,GAClB,OAAOX,EAAQ0F,QAAQR,EAAYjF,EAAImD,EAAhCpD,CAAqCW,EAC9C,CACF,GA3HEK,KA8HF,SAAchB,GACZA,EAAQgB,KAAK,aACf,E","sources":["../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/attention.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/blank-line.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/autolink.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/character-escape.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/character-reference.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/block-quote.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n  let open\n  /** @type {Token} */\n  let group\n  /** @type {Token} */\n  let text\n  /** @type {Token} */\n  let openingSequence\n  /** @type {Token} */\n  let closingSequence\n  /** @type {number} */\n  let use\n  /** @type {Array<Event>} */\n  let nextEvents\n  /** @type {number} */\n  let offset\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open &&\n          // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          }\n\n          // Number of markers to use from the sequence.\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = []\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ])\n\n          // Always populated by defaults.\n\n          // Between.\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          )\n\n          // Closing.\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ])\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Before a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    marker = code\n    effects.enter('attentionSequence')\n    return inside(code)\n  }\n\n  /**\n   * In a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    const token = effects.exit('attentionSequence')\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code)\n\n    // Always populated by defaults.\n\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of blank line.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *     ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'linePrefix')(code)\n      : after(code)\n  }\n\n  /**\n   * At eof/eol, after optional whitespace.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *       ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 0\n  return start\n\n  /**\n   * Start of an autolink.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *      ^\n   * > | a<user@example.com>b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n\n  /**\n   * After `<`, at protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *       ^\n   * > | a<user@example.com>b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n    return emailAtext(code)\n  }\n\n  /**\n   * At second byte of protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeOrEmailAtext(code) {\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) {\n      // Count the previous alphabetical from `open` too.\n      size = 1\n      return schemeInsideOrEmailAtext(code)\n    }\n    return emailAtext(code)\n  }\n\n  /**\n   * In ambiguous protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      size = 0\n      return urlInside\n    }\n\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n    size = 0\n    return emailAtext(code)\n  }\n\n  /**\n   * After protocol, in URL.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      effects.enter('autolinkMarker')\n      effects.consume(code)\n      effects.exit('autolinkMarker')\n      effects.exit('autolink')\n      return ok\n    }\n\n    // ASCII control, space, or `<`.\n    if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return urlInside\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      return emailAtSignOrDot\n    }\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label, after at-sign or dot.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                 ^       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are allowed.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n    if (code === 62) {\n      // Exit, then change the token type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      effects.enter('autolinkMarker')\n      effects.consume(code)\n      effects.exit('autolinkMarker')\n      effects.exit('autolink')\n      return ok\n    }\n    return emailValue(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are *not* allowed.\n   *\n   * Though, this is also used in `emailLabel` to parse other values.\n   *\n   * ```markdown\n   * > | a<user.name@ex-ample.com>b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailValue(code) {\n    // ASCII alphanumeric or `-`.\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      const next = code === 45 ? emailValue : emailLabel\n      effects.consume(code)\n      return next\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {asciiPunctuation} from 'micromark-util-character'\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of character escape.\n   *\n   * ```markdown\n   * > | a\\*b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return inside\n  }\n\n  /**\n   * After `\\`, at punctuation.\n   *\n   * ```markdown\n   * > | a\\*b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // ASCII punctuation.\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n  let max\n  /** @type {(code: Code) => boolean} */\n  let test\n  return start\n\n  /**\n   * Start of character reference.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *      ^\n   * > | a&#123;b\n   *      ^\n   * > | a&#x9;b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n\n  /**\n   * After `&`, at `#` for numeric references or alphanumeric for named\n   * references.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^\n   * > | a&#123;b\n   *       ^\n   * > | a&#x9;b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  /**\n   * After `#`, at `x` for hexadecimals or digit for decimals.\n   *\n   * ```markdown\n   * > | a&#123;b\n   *        ^\n   * > | a&#x9;b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n\n  /**\n   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.\n   *\n   * The character reference kind defines what and how many characters are\n   * allowed.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^^^\n   * > | a&#123;b\n   *        ^^^\n   * > | a&#x9;b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function value(code) {\n    if (code === 59 && size) {\n      const token = effects.exit('characterReferenceValue')\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      // To do: `markdown-rs` uses a different name:\n      // `CharacterReferenceMarkerSemi`.\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this\n  return contStart\n\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n\n      return factorySpace(\n        effects,\n        contBefore,\n        'linePrefix',\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : 4\n      )(code)\n    }\n    return contBefore(code)\n  }\n\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code)\n  }\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n"],"names":["attention","name","tokenize","effects","ok","attentionMarkers","this","parser","constructs","null","previous","before","classifyCharacter","marker","code","enter","inside","consume","token","exit","after","open","includes","close","_open","Boolean","_close","resolveAll","events","context","group","text","openingSequence","closingSequence","use","nextEvents","offset","index","length","type","sliceSerialize","charCodeAt","end","start","Object","assign","movePoint","push","insideSpan","slice","splice","point","column","_bufferIndex","blankLine","nok","markdownSpace","factorySpace","markdownLineEnding","partial","autolink","size","asciiAlpha","schemeOrEmailAtext","emailAtext","asciiAlphanumeric","schemeInsideOrEmailAtext","urlInside","asciiControl","emailAtSignOrDot","asciiAtext","emailLabel","emailValue","next","characterEscape","asciiPunctuation","characterReference","self","max","test","numeric","value","asciiHexDigit","asciiDigit","decodeNamedCharacterReference","blockQuote","state","containerState","_container","continuation","contBefore","disable","undefined","attempt"],"sourceRoot":""}
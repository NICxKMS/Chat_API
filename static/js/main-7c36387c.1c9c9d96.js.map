{"version":3,"file":"static/js/main-7c36387c.1c9c9d96.js","mappings":"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","sources":["utils/performance.js","reportWebVitals.js","serviceWorkerRegistration.js","index.js","hooks/useCacheToggle.js","hooks/useMediaQuery.js","utils/network.js","hooks/useLocalStorage.js","../webpack/runtime/startup prefetch"],"sourcesContent":["/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","import './utils/polyfills';\nimport React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './styles/common/colors.css';\nimport './styles/common/tokens.css';\nimport './styles/theme.css';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { ToastProvider } from './contexts/ToastContext';\nimport { LoadingProvider } from './contexts/LoadingContext';\nimport GlobalLoadingIndicator from './components/common/GlobalLoadingIndicator';\n\n// Set initial theme class on <body> so theme mappings (light-mode/dark-mode) take effect\nconst prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n// Apply body class for index.css mappings\ndocument.body.classList.add(prefersDark ? 'dark-mode' : 'light-mode');\n// Apply data-theme attribute for colors.css and theme.css dark mode overrides\ndocument.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <ToastProvider>\n      <LoadingProvider>\n        <Suspense fallback={\n          <div style={{ \n            display: 'flex', \n            justifyContent: 'center', \n            alignItems: 'center', \n            height: '100vh' \n          }}>\n            Loading...\n          </div>\n        }>\n          <App />\n        </Suspense>\n        <GlobalLoadingIndicator />\n      </LoadingProvider>\n    </ToastProvider>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","import { useState, useEffect, useMemo } from 'react';\n\n// Define breakpoint constants in a single source of truth\nexport const BREAKPOINTS = {\n  mobile: '640px',\n  tablet: '1023px',\n  desktop: '1024px',\n  settings: '550px'\n};\n\n// Cached media query listeners\nconst mediaQueryListeners = new Map();\n\n/**\n * Custom hook that returns true if the current viewport matches the provided media query\n * @param {string} query - Media query string e.g., \"(max-width: 1024px)\"\n * @returns {boolean} - True if the media query matches\n */\nexport const useMediaQuery = (query) => {\n  // Initialize with the current match state\n  const [matches, setMatches] = useState(() => {\n    // Check for window to avoid SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    // Avoid running in SSR context\n    if (typeof window === 'undefined') {\n      return undefined;\n    }\n\n    // Check if we already have a listener for this query\n    if (!mediaQueryListeners.has(query)) {\n      // Create media query list\n      const mediaQueryList = window.matchMedia(query);\n      \n      // Create listener registry for this query\n      mediaQueryListeners.set(query, {\n        mediaQueryList,\n        listeners: new Set()\n      });\n    }\n    \n    const queryData = mediaQueryListeners.get(query);\n    const { mediaQueryList, listeners } = queryData;\n\n    // Initial check\n    setMatches(mediaQueryList.matches);\n\n    // Define listener function\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener to registry\n    listeners.add(listener);\n\n    // Modern browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener);\n      return () => {\n        mediaQueryList.removeEventListener('change', listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    } \n    // Legacy support for older browsers (e.g., IE, older Safari)\n    else if (mediaQueryList.addListener) {\n      mediaQueryList.addListener(listener);\n      return () => {\n        mediaQueryList.removeListener(listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    }\n\n    return undefined;\n  }, [query]);\n\n  return matches;\n};\n\n/**\n * Pre-configured hooks for common breakpoints\n */\nexport const useIsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.mobile})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsTablet = () => {\n  const query = useMemo(() => \n    `(min-width: calc(${BREAKPOINTS.mobile} + 1px)) and (max-width: ${BREAKPOINTS.tablet})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsDesktop = () => {\n  const query = useMemo(() => `(min-width: ${BREAKPOINTS.desktop})`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Special hook for settings components\n */\nexport const useIsSettingsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.settings})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsSettingsDesktop = () => {\n  const query = useMemo(() => `(min-width: calc(${BREAKPOINTS.settings} + 1px))`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Get a consistent breakpoint value across the app\n * @returns {{mobile: string, tablet: string, desktop: string, settings: string}}\n */\nexport const useBreakpoints = () => {\n  return BREAKPOINTS;\n}; ","export async function fetchWithRetry(input, init = {}, retries = 3, backoff = 500) {\n  let attempt = 0;\n  while (true) {\n    try {\n      const response = await fetch(input, init);\n      if (!response.ok) {\n        throw new Error(`Network error: ${response.status}`);\n      }\n      return response;\n    } catch (error) {\n      if (attempt >= retries) {\n        throw error;\n      }\n      // Exponential backoff with jitter\n      const delay = backoff * Math.pow(2, attempt) + Math.random() * 100;\n      await new Promise(res => setTimeout(res, delay));\n      attempt++;\n    }\n  }\n} ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; ","__webpack_require__.O(0, [3895], () => {\n\t[4314,208,5764,2042,4370,1042,4912,4910,268,496,6716,8990,8360,4377,3542,8467,5419,5174,7007,1524,5433,4431,9173,4537,1802,4191,5028,535,5100,393,5039,5444,2412,6017,399,4917,7777,438,662,7272,7390,4734,6755,4182,4582,8162,6760,1217,822,4335,6814,2489,9734,5522,5080,1927,9283,8476,5816,4120,7295,237,9104,2993,9889,392,7514,8482,5418,1506,5796,4266,7210,3484,9579].map(__webpack_require__.E);\n}, 5);"],"names":["PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","Set","measures","window","trackPaintMetrics","PerformanceObserver","entries","getEntries","forEach","entry","markName","name","performance","mark","add","measureName","measure","error","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clear","clearMarks","clearMeasures","logMetrics","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","prefersDark","matchMedia","matches","document","body","classList","documentElement","setAttribute","ReactDOM","getElementById","render","_jsx","React","children","ToastProvider","_jsxs","LoadingProvider","Suspense","fallback","style","display","justifyContent","alignItems","height","App","GlobalLoadingIndicator","reportWebVitals","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","waitingServiceWorker","waiting","event","target","postMessage","type","useCacheToggle","cacheEnabled","setCacheEnabled","useLocalStorage","clearModelCache","useCallback","localStorage","removeItem","toggleCache","enabled","newValue","refreshModels","useEffect","originalFunc","isCacheValid","cache","getItem","timestamp","Date","now","allModels","processedModels","experimentalModels","BREAKPOINTS","mobile","tablet","desktop","settings","mediaQueryListeners","Map","useMediaQuery","query","setMatches","useState","has","mediaQueryList","set","listeners","queryData","listener","removeEventListener","delete","size","addListener","removeListener","useIsDesktop","useMemo","useIsSettingsMobile","async","fetchWithRetry","input","init","arguments","length","undefined","retries","backoff","attempt","ok","Error","delay","Math","pow","random","Promise","res","setTimeout","key","initialValue","initialValueRef","useRef","storedValue","setStoredValue","item","JSON","parse","current","setValue","value","valueToStore","setItem","stringify","__webpack_require__","O","map","E"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor-refractor-f72f697c.05c2365443.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/refractor/lang/qore.js","../node_modules/refractor/lang/q.js","../node_modules/refractor/lang/qsharp.js","../node_modules/refractor/lang/qml.js"],"sourcesContent":["'use strict'\n\nmodule.exports = qore\nqore.displayName = 'qore'\nqore.aliases = []\nfunction qore(Prism) {\n  Prism.languages.qore = Prism.languages.extend('clike', {\n    comment: {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:\\/\\/|#).*)/,\n      lookbehind: true\n    },\n    // Overridden to allow unescaped multi-line strings\n    string: {\n      pattern: /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n      greedy: true\n    },\n    keyword:\n      /\\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\\b/,\n    boolean: /\\b(?:false|true)\\b/i,\n    function: /\\$?\\b(?!\\d)\\w+(?=\\()/,\n    number:\n      /\\b(?:0b[01]+|0x(?:[\\da-f]*\\.)?[\\da-fp\\-]+|(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:e\\d+)?[df]|(?:\\d+(?:\\.\\d+)?|\\.\\d+))\\b/i,\n    operator: {\n      pattern:\n        /(^|[^.])(?:\\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\\|[|=]?|[*\\/%^]=?|[~?])/,\n      lookbehind: true\n    },\n    variable: /\\$(?!\\d)\\w+\\b/\n  })\n}\n","'use strict'\n\nmodule.exports = q\nq.displayName = 'q'\nq.aliases = []\nfunction q(Prism) {\n  Prism.languages.q = {\n    string: /\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n    comment: [\n      // From http://code.kx.com/wiki/Reference/Slash:\n      // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.\n      {\n        pattern: /([\\t )\\]}])\\/.*/,\n        lookbehind: true,\n        greedy: true\n      }, // From http://code.kx.com/wiki/Reference/Slash:\n      // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.\n      // A / on a line by itself begins a multiline comment which is terminated by the next \\ on a line by itself.\n      // If a / is not matched by a \\, the multiline comment is unterminated and continues to end of file.\n      // The / and \\ must be the first char on the line, but may be followed by any amount of whitespace.\n      {\n        pattern:\n          /(^|\\r?\\n|\\r)\\/[\\t ]*(?:(?:\\r?\\n|\\r)(?:.*(?:\\r?\\n|\\r(?!\\n)))*?(?:\\\\(?=[\\t ]*(?:\\r?\\n|\\r))|$)|\\S.*)/,\n        lookbehind: true,\n        greedy: true\n      }, // From http://code.kx.com/wiki/Reference/Slash:\n      // A \\ on a line by itself with no preceding matching / will comment to end of file.\n      {\n        pattern: /^\\\\[\\t ]*(?:\\r?\\n|\\r)[\\s\\S]+/m,\n        greedy: true\n      },\n      {\n        pattern: /^#!.+/m,\n        greedy: true\n      }\n    ],\n    symbol: /`(?::\\S+|[\\w.]*)/,\n    datetime: {\n      pattern:\n        /0N[mdzuvt]|0W[dtz]|\\d{4}\\.\\d\\d(?:m|\\.\\d\\d(?:T(?:\\d\\d(?::\\d\\d(?::\\d\\d(?:[.:]\\d\\d\\d)?)?)?)?)?[dz]?)|\\d\\d:\\d\\d(?::\\d\\d(?:[.:]\\d\\d\\d)?)?[uvt]?/,\n      alias: 'number'\n    },\n    // The negative look-ahead prevents bad highlighting\n    // of verbs 0: and 1:\n    number:\n      /\\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\\da-fA-F]+|\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?[hjfeb]?)/,\n    keyword:\n      /\\\\\\w+\\b|\\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\\b/,\n    adverb: {\n      pattern: /['\\/\\\\]:?|\\beach\\b/,\n      alias: 'function'\n    },\n    verb: {\n      pattern: /(?:\\B\\.\\B|\\b[01]:|<[=>]?|>=?|[:+\\-*%,!?~=|$&#@^]):?|\\b_\\b:?/,\n      alias: 'operator'\n    },\n    punctuation: /[(){}\\[\\];.]/\n  }\n}\n","'use strict'\n\nmodule.exports = qsharp\nqsharp.displayName = 'qsharp'\nqsharp.aliases = ['qs']\nfunction qsharp(Prism) {\n  ;(function (Prism) {\n    /**\n     * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n     *\n     * Note: This is a simple text based replacement. Be careful when using backreferences!\n     *\n     * @param {string} pattern the given pattern.\n     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n     */\n    function replace(pattern, replacements) {\n      return pattern.replace(/<<(\\d+)>>/g, function (m, index) {\n        return '(?:' + replacements[+index] + ')'\n      })\n    }\n    /**\n     * @param {string} pattern\n     * @param {string[]} replacements\n     * @param {string} [flags]\n     * @returns {RegExp}\n     */\n    function re(pattern, replacements, flags) {\n      return RegExp(replace(pattern, replacements), flags || '')\n    }\n    /**\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n     *\n     * @param {string} pattern\n     * @param {number} depthLog2\n     * @returns {string}\n     */\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<<self>>/g, function () {\n          return '(?:' + pattern + ')'\n        })\n      }\n      return pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]')\n    } // https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/\n    // https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar\n    var keywordKinds = {\n      // keywords which represent a return or variable type\n      type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',\n      // all other keywords\n      other:\n        'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'\n    } // keywords\n    function keywordsToPattern(words) {\n      return '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b'\n    }\n    var keywords = RegExp(\n      keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other)\n    ) // types\n    var identifier = /\\b[A-Za-z_]\\w*\\b/.source\n    var qualifiedName = replace(/<<0>>(?:\\s*\\.\\s*<<0>>)*/.source, [identifier])\n    var typeInside = {\n      keyword: keywords,\n      punctuation: /[<>()?,.:[\\]]/\n    } // strings\n    var regularString = /\"(?:\\\\.|[^\\\\\"])*\"/.source\n    Prism.languages.qsharp = Prism.languages.extend('clike', {\n      comment: /\\/\\/.*/,\n      string: [\n        {\n          pattern: re(/(^|[^$\\\\])<<0>>/.source, [regularString]),\n          lookbehind: true,\n          greedy: true\n        }\n      ],\n      'class-name': [\n        {\n          // open Microsoft.Quantum.Canon;\n          // open Microsoft.Quantum.Canon as CN;\n          pattern: re(/(\\b(?:as|open)\\s+)<<0>>(?=\\s*(?:;|as\\b))/.source, [\n            qualifiedName\n          ]),\n          lookbehind: true,\n          inside: typeInside\n        },\n        {\n          // namespace Quantum.App1;\n          pattern: re(/(\\bnamespace\\s+)<<0>>(?=\\s*\\{)/.source, [qualifiedName]),\n          lookbehind: true,\n          inside: typeInside\n        }\n      ],\n      keyword: keywords,\n      number:\n        /(?:\\b0(?:x[\\da-f]+|b[01]+|o[0-7]+)|(?:\\B\\.\\d+|\\b\\d+(?:\\.\\d*)?)(?:e[-+]?\\d+)?)l?\\b/i,\n      operator:\n        /\\band=|\\bor=|\\band\\b|\\bnot\\b|\\bor\\b|<[-=]|[-=]>|>>>=?|<<<=?|\\^\\^\\^=?|\\|\\|\\|=?|&&&=?|w\\/=?|~~~|[*\\/+\\-^=!%]=?/,\n      punctuation: /::|[{}[\\];(),.:]/\n    })\n    Prism.languages.insertBefore('qsharp', 'number', {\n      range: {\n        pattern: /\\.\\./,\n        alias: 'operator'\n      }\n    }) // single line\n    var interpolationExpr = nested(\n      replace(/\\{(?:[^\"{}]|<<0>>|<<self>>)*\\}/.source, [regularString]),\n      2\n    )\n    Prism.languages.insertBefore('qsharp', 'string', {\n      'interpolation-string': {\n        pattern: re(/\\$\"(?:\\\\.|<<0>>|[^\\\\\"{])*\"/.source, [interpolationExpr]),\n        greedy: true,\n        inside: {\n          interpolation: {\n            pattern: re(/((?:^|[^\\\\])(?:\\\\\\\\)*)<<0>>/.source, [\n              interpolationExpr\n            ]),\n            lookbehind: true,\n            inside: {\n              punctuation: /^\\{|\\}$/,\n              expression: {\n                pattern: /[\\s\\S]+/,\n                alias: 'language-qsharp',\n                inside: Prism.languages.qsharp\n              }\n            }\n          },\n          string: /[\\s\\S]+/\n        }\n      }\n    })\n  })(Prism)\n  Prism.languages.qs = Prism.languages.qsharp\n}\n","'use strict'\n\nmodule.exports = qml\nqml.displayName = 'qml'\nqml.aliases = []\nfunction qml(Prism) {\n  ;(function (Prism) {\n    var jsString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"|'(?:\\\\.|[^\\\\'\\r\\n])*'/.source\n    var jsComment = /\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\//.source\n    var jsExpr =\n      /(?:[^\\\\()[\\]{}\"'/]|<string>|\\/(?![*/])|<comment>|\\(<expr>*\\)|\\[<expr>*\\]|\\{<expr>*\\}|\\\\[\\s\\S])/.source\n        .replace(/<string>/g, function () {\n          return jsString\n        })\n        .replace(/<comment>/g, function () {\n          return jsComment\n        }) // the pattern will blow up, so only a few iterations\n    for (var i = 0; i < 2; i++) {\n      jsExpr = jsExpr.replace(/<expr>/g, function () {\n        return jsExpr\n      })\n    }\n    jsExpr = jsExpr.replace(/<expr>/g, '[^\\\\s\\\\S]')\n    Prism.languages.qml = {\n      comment: {\n        pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\//,\n        greedy: true\n      },\n      'javascript-function': {\n        pattern: RegExp(\n          /((?:^|;)[ \\t]*)function\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*\\(<js>*\\)\\s*\\{<js>*\\}/.source.replace(\n            /<js>/g,\n            function () {\n              return jsExpr\n            }\n          ),\n          'm'\n        ),\n        lookbehind: true,\n        greedy: true,\n        alias: 'language-javascript',\n        inside: Prism.languages.javascript\n      },\n      'class-name': {\n        pattern: /((?:^|[:;])[ \\t]*)(?!\\d)\\w+(?=[ \\t]*\\{|[ \\t]+on\\b)/m,\n        lookbehind: true\n      },\n      property: [\n        {\n          pattern: /((?:^|[;{])[ \\t]*)(?!\\d)\\w+(?:\\.\\w+)*(?=[ \\t]*:)/m,\n          lookbehind: true\n        },\n        {\n          pattern:\n            /((?:^|[;{])[ \\t]*)property[ \\t]+(?!\\d)\\w+(?:\\.\\w+)*[ \\t]+(?!\\d)\\w+(?:\\.\\w+)*(?=[ \\t]*:)/m,\n          lookbehind: true,\n          inside: {\n            keyword: /^property/,\n            property: /\\w+(?:\\.\\w+)*/\n          }\n        }\n      ],\n      'javascript-expression': {\n        pattern: RegExp(\n          /(:[ \\t]*)(?![\\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(\n            /<js>/g,\n            function () {\n              return jsExpr\n            }\n          ),\n          'm'\n        ),\n        lookbehind: true,\n        greedy: true,\n        alias: 'language-javascript',\n        inside: Prism.languages.javascript\n      },\n      string: {\n        pattern: /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n        greedy: true\n      },\n      keyword: /\\b(?:as|import|on)\\b/,\n      punctuation: /[{}[\\]:;,]/\n    }\n  })(Prism)\n}\n"],"names":["qore","Prism","languages","extend","comment","pattern","lookbehind","string","greedy","keyword","boolean","function","number","operator","variable","module","exports","displayName","aliases","q","symbol","datetime","alias","adverb","verb","punctuation","qsharp","replace","replacements","m","index","re","flags","RegExp","keywords","keywordKinds","trim","qualifiedName","source","typeInside","regularString","inside","insertBefore","range","interpolationExpr","i","nested","interpolation","expression","qs","qml","jsString","jsComment","jsExpr","javascript","property"],"sourceRoot":""}
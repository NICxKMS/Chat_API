{"version":3,"file":"static/js/chat-messagelist.d38db82d.chunk.js","mappings":"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","sources":["utils/formatters.js","utils/messageHelpers.js","components/common/LazyMarkdownRenderer/index.js","components/chat/ChatMessage/index.js","components/common/ImageOverlay/index.js","components/chat/MessageList/index.js"],"sourcesContent":["/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  // eslint-disable-next-line no-useless-escape\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","import React, { lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\n\n// Lazy-load the heavy Markdown renderer only when first used\nconst MarkdownRenderer = lazy(() => import(/* webpackChunkName: \"markdown-renderer\", webpackPrefetch: true */ './MarkdownRenderer'));\n\nexport default function LazyMarkdownRenderer({ children }) {\n  return (\n    <Suspense fallback={<div>{children}</div>}>\n      <MarkdownRenderer>{children}</MarkdownRenderer>\n    </Suspense>\n  );\n}\n\nLazyMarkdownRenderer.propTypes = {\n  markdownText: PropTypes.string.isRequired\n}; ","// eslint-disable import/first\nimport React, { memo, useMemo, useState, useEffect, useCallback, lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport { PersonIcon, CopilotIcon, GearIcon, AlertIcon, CheckIcon, CopyIcon, ClockIcon, PulseIcon, PencilIcon } from '@primer/octicons-react';\nimport styles from './ChatMessage.module.css';\nimport { formatTime } from '../../../utils/messageHelpers';\nimport { convertTeXToMathDollars } from '../../../utils/formatters';\n// Lazy-load Markdown renderer for user/system/error messages\nimport LazyMarkdownRenderer from '../../common/LazyMarkdownRenderer';\n// Dynamically load StreamingMessage to defer heavy modules\nconst StreamingMessage = lazy(() => import(/* webpackChunkName: \"streaming-message\", webpackPrefetch: true */ './StreamingMessage'));\n\n// Add a module-level singleton for the TeX worker so we only load the worker script once\nlet texWorker;\nconst getTexWorker = () => {\n  if (typeof Worker !== 'undefined' && !texWorker) {\n    texWorker = new Worker(new URL('../../../workers/texProcessor.js', import.meta.url), { type: 'module' });\n  }\n  return texWorker;\n};\n\n/**\n * ChatMessage component with optimized rendering for streaming content\n * @param {Object} props - Component props\n * @param {string} props.role - Message role (user, assistant, system, error)\n * @param {string} props.content - Message content\n * @param {number} props.index - Message index in the chat history\n * @param {boolean} props.isStreaming - Whether this message is currently streaming\n * @returns {JSX.Element} - Rendered component\n */\nconst ChatMessage = ({ message, isStreaming = false, onEditMessage = null, overrideContent = null }) => {\n  // Use overrideContent if provided, else fall back to message.content\n  const content = overrideContent != null ? overrideContent : message.content;\n\n  const [messageCopied, setMessageCopied] = useState(false);\n  const defaultProcessedMessage = useMemo(() => (\n    message.role === 'assistant'\n      ? content\n      : convertTeXToMathDollars(content)\n  ), [content, message.role]);\n  const [processedMessage, setProcessedMessage] = useState(defaultProcessedMessage);\n\n  useEffect(() => {\n    if (message.role !== 'assistant' || typeof content !== 'string' || typeof Worker === 'undefined') {\n      return;\n    }\n    const id = message.timestamp;\n    const worker = getTexWorker();\n    const handleMessage = (e) => {\n      if (e.data.id !== id) return;\n      if (e.data.success) setProcessedMessage(e.data.data);\n      else setProcessedMessage(content);\n    };\n    worker.addEventListener('message', handleMessage);\n    worker.postMessage({ id, content });\n    return () => {\n      worker.removeEventListener('message', handleMessage);\n    };\n  }, [content, message.role, message.timestamp]);\n  \n  // Choose appropriate icon based on message role\n  const icon = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return <PersonIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'assistant':\n        return <CopilotIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'system':\n        return <GearIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'error':\n        return <AlertIcon size={16} className={styles.ChatMessage__icon} />;\n      default:\n        return null;\n    }\n  }, [message.role]);\n  \n  // Select CSS classes based on message role\n  const messageClass = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return styles['ChatMessage--user'];\n      case 'assistant':\n        return styles['ChatMessage--assistant'];\n      case 'system':\n        return styles['ChatMessage--system'];\n      case 'error':\n        return styles['ChatMessage--error'];\n      default:\n        return '';\n    }\n  }, [message.role]);\n  \n  // Determine if we should show metrics (only for assistant messages)\n  const shouldShowMetrics = useMemo(() => {\n    // Show metrics if this is an assistant message with any metrics\n    if (message.role !== 'assistant' || !message.metrics) return false;\n    return true;\n  }, [message.role, message.metrics]);\n  \n  // Copy message content to clipboard\n  const handleCopyMessage = useCallback(() => {\n    const content = typeof message.content === 'string' \n      ? message.content \n      : Array.isArray(message.content) \n        ? message.content\n            .filter(part => part.type === 'text')\n            .map(part => part.text)\n            .join('\\n')\n        : '';\n    navigator.clipboard.writeText(content).then(() => {\n      setMessageCopied(true);\n      setTimeout(() => setMessageCopied(false), 2000);\n    });\n  }, [message.content]);\n  \n  // === BUTTON JSX (Moved here for reuse) ===\n  const copyButtonJsx = useMemo(() => (\n    <button\n      className={`${styles.ChatMessage__copyMessageButton} ${\n        (message.role === 'assistant' && shouldShowMetrics) ? styles.ChatMessage__copyMessageButtonInMetrics : styles.ChatMessage__copyMessageButtonBottomRight\n      }`}\n      onClick={handleCopyMessage}\n      aria-label=\"Copy message\"\n      title=\"Copy message\"\n    >\n      {messageCopied ? <CheckIcon size={16} /> : <CopyIcon size={16} />}\n    </button>\n  ), [handleCopyMessage, message.role, shouldShowMetrics, messageCopied]);\n\n  // Edit button only for user messages\n  const handleEditClick = useCallback(() => {\n    if (onEditMessage) onEditMessage(message);\n  }, [onEditMessage, message]);\n  const editButtonJsx = useMemo(() => message.role === 'user' ? (\n    <button\n      className={styles.ChatMessage__editMessageButton}\n      onClick={handleEditClick}\n      aria-label=\"Edit message\"\n      title=\"Edit message\"\n    >\n      <PencilIcon size={16} />\n    </button>\n  ) : null, [message.role, handleEditClick]);\n  // ==========================================\n  \n  // Render performance metrics (only for assistant messages)\n  const renderMetrics = () => {\n    if (!shouldShowMetrics || !message.metrics) return null;\n    \n    // Use the specific isStreaming prop passed down to determine if THIS message is generating\n    const isGenerating = isStreaming;\n    const { \n      elapsedTime, \n      tokenCount, \n      tokensPerSecond, \n      timeToFirstToken, \n      promptTokens, \n      completionTokens, \n      totalTokens,\n      finishReason \n    } = message.metrics;\n    \n    // Check if we have any valid metrics to show\n    const hasValidMetrics = \n      elapsedTime != null || \n      tokenCount != null || \n      tokensPerSecond != null || \n      timeToFirstToken != null ||\n      promptTokens != null ||\n      completionTokens != null ||\n      totalTokens != null ||\n      finishReason != null;\n      \n    // Don't render anything if no valid metrics are found\n    if (!hasValidMetrics) return null;\n    \n    return (\n      <div className={styles.ChatMessage__metricsContainer}>\n        {/* Time metrics */}\n        {timeToFirstToken != null && timeToFirstToken !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            First Token: {formatTime(timeToFirstToken)}\n          </span>\n        )}\n        {elapsedTime != null && elapsedTime !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total Time: {formatTime(elapsedTime)}\n          </span>\n        )}\n        \n        {/* Token metrics */}\n        {tokenCount != null && tokenCount !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Tokens: {tokenCount}\n          </span>\n        )}\n        {promptTokens != null && promptTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Prompt: {promptTokens}\n          </span>\n        )}\n        {completionTokens != null && completionTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Completion: {completionTokens}\n          </span>\n        )}\n        {totalTokens != null && totalTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total: {totalTokens}\n          </span>\n        )}\n        \n        {/* Speed metrics */}\n        {tokensPerSecond != null && tokensPerSecond !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <PulseIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Speed: {tokensPerSecond} t/s\n          </span>\n        )}\n        \n        {/* Status */}\n        {finishReason != null && finishReason !== '' && (\n          <span className={styles.ChatMessage__metric}>\n            <AlertIcon size={14} className={styles.ChatMessage__metricIcon} />\n            {finishReason}\n          </span>\n        )}\n        {isGenerating && (\n          <span className={`${styles.ChatMessage__metric} ${styles.ChatMessage__generatingIndicator}`}>\n            <span className={styles.ChatMessage__generatingDot}></span>\n            Generating...\n          </span>\n        )}\n        \n        {/* Copy button */}\n        {copyButtonJsx}\n      </div>\n    );\n  };\n  \n  // Main return\n  return (\n    <div className={styles.ChatMessage + ' ' + messageClass}>\n      {/* Avatar */}\n      <div className={styles.ChatMessage__avatar}>{icon}</div>\n\n      {/* Message content section */}\n      <div className={styles.ChatMessage__contentWrapper}>\n        <Suspense fallback={null}>\n          <div className={styles.ChatMessage__content}>\n            {message.role === 'assistant' ? (\n              <StreamingMessage\n                content={processedMessage}\n                isStreaming={isStreaming}\n              />\n            ) : (\n              // Render markdown lazily for user/system/error messages\n              <LazyMarkdownRenderer>\n                {processedMessage}\n              </LazyMarkdownRenderer>\n            )}\n          </div>\n        </Suspense>\n\n        {/* Render performance metrics for assistant messages */}\n        {message.role === 'assistant' && renderMetrics()}\n\n        {/* Copy button for non-user messages, hide when assistant metrics exist */}\n        {message.role !== 'user' && (message.role !== 'assistant' || !shouldShowMetrics) && copyButtonJsx}\n      </div>\n\n      {/* User-specific buttons */}\n      {message.role === 'user' && (\n        <div className={styles.ChatMessage__userButtonContainer}>\n          {editButtonJsx}\n          {copyButtonJsx}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Display name\nChatMessage.displayName = 'ChatMessage';\n\n// PropTypes\nChatMessage.propTypes = {\n  message: PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    role: PropTypes.oneOf(['user', 'assistant', 'system', 'error']).isRequired,\n    content: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.shape({ // Support complex content\n        type: PropTypes.string.isRequired,\n        text: PropTypes.string,\n        image_url: PropTypes.shape({\n          url: PropTypes.string.isRequired\n        })\n      }))\n    ]).isRequired,\n    timestamp: PropTypes.number.isRequired,\n    metrics: PropTypes.shape({\n      elapsedTime: PropTypes.number,\n      tokenCount: PropTypes.number,\n      tokensPerSecond: PropTypes.number,\n      timeToFirstToken: PropTypes.number,\n      promptTokens: PropTypes.number,\n      completionTokens: PropTypes.number,\n      totalTokens: PropTypes.number,\n      finishReason: PropTypes.string\n    })\n  }).isRequired,\n  isStreaming: PropTypes.bool,\n  onEditMessage: PropTypes.func,\n  overrideContent: PropTypes.string // Optional override for rendering previews\n};\n\nexport default memo(ChatMessage); ","import ReactDOM from 'react-dom'; // Import ReactDOM\nimport PropTypes from 'prop-types';\nimport { XIcon } from '@primer/octicons-react';\nimport styles from './ImageOverlay.module.css';\n\n/**\n * Full-screen overlay for displaying an image using React Portal.\n * Clicking anywhere on the overlay closes it.\n */\nconst ImageOverlay = ({ src, alt, isOpen, onClose }) => {\n  if (!src || !isOpen) return null;\n\n  // Prevent clicks on the image itself from closing if needed (optional)\n  const handleImageClick = (e) => {\n    e.stopPropagation(); // Prevents the overlay click handler from firing\n    // Could potentially add other actions here, like zoom controls\n  };\n\n  // The overlay content\n  const overlayContent = (\n    <div className={styles.ImageOverlay} onClick={onClose} role=\"dialog\" aria-modal=\"true\" title=\"Click to close image\">\n      <img \n        src={src} \n        alt={alt} \n        className={styles.ImageOverlay__image}\n        onClick={handleImageClick} // Handle clicks on the image specifically\n      />\n    </div>\n  );\n\n  // Use ReactDOM.createPortal to render the overlay into document.body\n  return ReactDOM.createPortal(\n    overlayContent,\n    document.body \n  );\n};\n\nImageOverlay.propTypes = {\n  /** The URL of the image to display */\n  src: PropTypes.string.isRequired,\n  /** The alt text for the image */\n  alt: PropTypes.string.isRequired,\n  /** Whether the overlay is open or not */\n  isOpen: PropTypes.bool.isRequired,\n  /** Function to call when the overlay should be closed */\n  onClose: PropTypes.func.isRequired,\n};\n\nexport default ImageOverlay; ","import { forwardRef, useState, useMemo, memo } from 'react';\nimport styles from './MessageList.module.css';\nimport { useChatState } from '../../../contexts/ChatStateContext';\nimport ChatMessage from '../ChatMessage';\nimport ImageOverlay from '../../common/ImageOverlay';\nimport PropTypes from 'prop-types';\nimport { processMessageContent } from '../../../utils/messageHelpers';\n\n/**\n * Simple message list without virtualization\n * @param {Object} props - Component props\n * @param {Array} props.messages - Array of message objects\n * @param {string} props.error - Error message to display\n * @param {Function} props.onEditMessage - Function to handle message edit requests\n * @returns {JSX.Element} - Rendered component\n */\nconst MessageList = forwardRef(({ messages, error, onEditMessage }, ref) => {\n  const { isWaitingForResponse } = useChatState();\n  const [overlayImageSrc, setOverlayImageSrc] = useState(null);\n\n  // Combine regular messages with error content (if any)\n  const finalMessages = useMemo(() => {\n    const result = [...messages];\n    \n    // Add error message if any\n    if (error) {\n      result.push({\n        role: 'error',\n        content: error,\n        timestamp: Date.now()\n      });\n    }\n    \n    return result;\n  }, [messages, error]);\n\n  // Handlers for overlay\n  const handleImageClick = (src) => {\n    setOverlayImageSrc(src);\n  };\n\n  const handleCloseOverlay = () => {\n    setOverlayImageSrc(null);\n  };\n\n  return (\n    <>\n      <div \n        className={styles.MessageList} \n        ref={ref}\n        aria-live=\"polite\"\n        aria-relevant=\"additions text\"\n      >\n        {finalMessages.map((message, index) => {\n          // Determine if this message is currently streaming\n          const isLastMessage = index === finalMessages.length - 1;\n          const isStreaming = message.role === 'assistant' && \n                              isLastMessage && \n                              isWaitingForResponse &&\n                              !message.metrics?.isComplete;\n          \n          // Process message content for images and text\n          const { images, text } = processMessageContent(message.content);\n          \n          // Generate a unique key using timestamp if available, fallback to role-index\n          const messageKey = message.timestamp \n            ? `${message.role}-${message.timestamp}-${index}`\n            : `${message.role}-${index}`;\n          \n          return (\n            <div key={messageKey} className={styles.MessageList__messageRow}>\n              {/* Render images first if it's a user message with images */}\n              {message.role === 'user' && images.length > 0 && (\n                <div className={styles.MessageList__imageContainer}>\n                  {images.map((image, imgIndex) => (\n                    <img \n                      key={`${messageKey}-img-${imgIndex}`}\n                      src={image.url}\n                      alt={image.alt || `Uploaded image ${imgIndex + 1}`}\n                      className={`${styles.MessageList__messageImage} ${styles.MessageList__clickableImage}`}\n                      onClick={() => handleImageClick(image.url)}\n                    />\n                  ))}\n                </div>\n              )}\n              {/* Render ChatMessage if there's text content or it's not a user message */}\n              {(text || message.role !== 'user') && (\n                <ChatMessage\n                  message={message}\n                  overrideContent={text || undefined}\n                  isStreaming={isStreaming}\n                  onEditMessage={message.role === 'user' ? onEditMessage : undefined}\n                />\n              )}\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Render the overlay component */}\n      <ImageOverlay src={overlayImageSrc} onClose={handleCloseOverlay} />\n    </>\n  );\n});\n\nMessageList.displayName = 'MessageList';\n\nMessageList.propTypes = {\n  messages: PropTypes.array.isRequired,\n  error: PropTypes.string,\n  onEditMessage: PropTypes.func\n};\n\nexport default memo(MessageList); "],"names":["convertTeXToMathDollars","text","combinedRegex","RegExp","result","replace","match","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","undefined","trim","formatTime","ms","toFixed","MarkdownRenderer","lazy","LazyMarkdownRenderer","_ref","children","_jsx","Suspense","fallback","StreamingMessage","texWorker","ChatMessage","message","isStreaming","onEditMessage","overrideContent","content","messageCopied","setMessageCopied","useState","defaultProcessedMessage","useMemo","role","processedMessage","setProcessedMessage","useEffect","Worker","id","timestamp","worker","URL","type","handleMessage","e","data","success","addEventListener","postMessage","removeEventListener","icon","PersonIcon","size","className","styles","ChatMessage__icon","CopilotIcon","GearIcon","AlertIcon","messageClass","shouldShowMetrics","metrics","handleCopyMessage","useCallback","Array","isArray","filter","part","map","join","navigator","clipboard","writeText","then","setTimeout","copyButtonJsx","ChatMessage__copyMessageButton","ChatMessage__copyMessageButtonInMetrics","ChatMessage__copyMessageButtonBottomRight","onClick","title","CheckIcon","CopyIcon","handleEditClick","editButtonJsx","ChatMessage__editMessageButton","PencilIcon","_jsxs","ChatMessage__avatar","ChatMessage__contentWrapper","ChatMessage__content","renderMetrics","isGenerating","elapsedTime","tokenCount","tokensPerSecond","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","ChatMessage__metricsContainer","ChatMessage__metric","ClockIcon","ChatMessage__metricIcon","PulseIcon","ChatMessage__generatingIndicator","ChatMessage__generatingDot","ChatMessage__userButtonContainer","displayName","memo","src","alt","isOpen","onClose","overlayContent","ImageOverlay","ImageOverlay__image","stopPropagation","ReactDOM","document","body","MessageList","forwardRef","ref","messages","error","isWaitingForResponse","useChatState","overlayImageSrc","setOverlayImageSrc","finalMessages","push","Date","now","_Fragment","index","_message$metrics","isLastMessage","length","isComplete","images","texts","reduce","acc","url","image_url","processMessageContent","messageKey","MessageList__messageRow","MessageList__imageContainer","image","imgIndex","MessageList__messageImage","MessageList__clickableImage","handleImageClick","handleCloseOverlay"],"sourceRoot":""}
{"version":3,"file":"static/js/node_modules_mdast-util-math_lib_index_js-node_modules_micromark-factory-space_index_js.52e6b71b91.chunk.v1_9_0.js","mappings":"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","sources":["../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/micromark-factory-space/node_modules/micromark-util-character/index.js","../node_modules/micromark-factory-space/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-factory-space/index.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n"],"names":["patternInScope","stack","pattern","listInScope","inConstruct","notInConstruct","list","none","length","index","includes","safe","state","input","config","value","before","after","positions","result","infos","unsafe","expression","patternCompile","match","exec","Boolean","atBreak","position","push","sort","numerical","start","end","escapeBackslashes","slice","test","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole","_compiled","RegExp","character","regexCheck","markdownSpace","code","regex","String","fromCharCode","factorySpace","effects","ok","type","max","limit","Number","POSITIVE_INFINITY","size","enter","prefix","consume","exit","track","options","now","lineShift","line","column","move","chunks","split","tail","current","shift","mathFromMarkdown","mathFlow","token","this","meta","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","mathText","resume","replace","node","setData","mathFlowFence","getData","mathFlowValue","exitMathData","mathTextData","call","mathToMarkdown","single","singleDollarTextMath","inlineMath","peek","undefined","handlers","math","_","context","safeOptions","raw","tracker","sequence","repeat","Math","substring","source","indexOf","expected","count","TypeError","longestStreak","subexit","codePointAt"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor.remark-rehype-bb555bc8.ae353bbde7.chunk.v1_7_5.js","mappings":"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","sources":["../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/revert.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/list-item.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/index.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/break.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/code.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/delete.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/footnote.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/heading.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/html.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/image.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/link.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/list.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/root.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/strong.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table-row.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/text.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/index.js","../node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/footer.js","../node_modules/remark-rehype/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('hast').Element} Element\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  if (index === -1) {\n    state.footnoteOrder.push(id)\n    state.footnoteCounts[id] = 1\n    counter = state.footnoteOrder.length\n  } else {\n    state.footnoteCounts[id]++\n    counter = index + 1\n  }\n\n  const reuseCounter = state.footnoteCounts[id]\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + state.clobberPrefix + 'fn-' + safeId,\n      id:\n        state.clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return {type: 'text', value: '![' + node.alt + suffix}\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === undefined || spread === null\n    ? node.children.length > 1\n    : spread\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {footnote} from './footnote.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  footnote,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  // To do: next major, use `node.lang` w/o regex, the splitting’s been going\n  // on for years in remark now.\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null\n  /** @type {Properties} */\n  const properties = {}\n\n  if (lang) {\n    properties.className = ['language-' + lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Footnote} Footnote\n * @typedef {import('../state.js').State} State\n */\n\nimport {footnoteReference} from './footnote-reference.js'\n\n// To do: when both:\n// * <https://github.com/micromark/micromark-extension-footnote>\n// * <https://github.com/syntax-tree/mdast-util-footnote>\n// …are archived, remove this (also from mdast).\n// These inline notes are not used in GFM.\n\n/**\n * Turn an mdast `footnote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Footnote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnote(state, node) {\n  const footnoteById = state.footnoteById\n  let no = 1\n\n  while (no in footnoteById) no++\n\n  const identifier = String(no)\n\n  footnoteById[identifier] = {\n    type: 'footnoteDefinition',\n    identifier,\n    children: [{type: 'paragraph', children: node.children}],\n    position: node.position\n  }\n\n  return footnoteReference(state, {\n    type: 'footnoteReference',\n    identifier,\n    position: node.position\n  })\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').HTML} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Raw | Element | null}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.dangerous) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  // To do: next major: return `undefined`.\n  return null\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(def.url || ''), alt: node.alt}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {ElementContent | Array<ElementContent>}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const def = state.definition(node.identifier)\n\n  if (!def) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(def.url || '')}\n\n  if (def.title !== null && def.title !== undefined) {\n    properties.title = def.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastRoot | HastElement}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointStart, pointEnd} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start.line && end.line) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastText | HastElement}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Root} MdastRoot\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n */\n\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {HastNodes | null | undefined}\n *   hast tree.\n */\n// To do: next major: always return a single `root`.\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, null)\n  const foot = footer(state)\n\n  if (foot) {\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  // To do: next major: always return root?\n  return Array.isArray(node) ? {type: 'root', children: node} : node\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\nexport function footer(state) {\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let index = -1\n\n  while (++index < state.footnoteOrder.length) {\n    const def = state.footnoteById[state.footnoteOrder[index]]\n\n    if (!def) {\n      continue\n    }\n\n    const content = state.all(def)\n    const id = String(def.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let referenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n\n    while (++referenceIndex <= state.footnoteCounts[id]) {\n      /** @type {Element} */\n      const backReference = {\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            state.clobberPrefix +\n            'fnref-' +\n            safeId +\n            (referenceIndex > 1 ? '-' + referenceIndex : ''),\n          dataFootnoteBackref: true,\n          className: ['data-footnote-backref'],\n          ariaLabel: state.footnoteBackLabel\n        },\n        children: [{type: 'text', value: '↩'}]\n      }\n\n      if (referenceIndex > 1) {\n        backReference.children.push({\n          type: 'element',\n          tagName: 'sup',\n          children: [{type: 'text', value: String(referenceIndex)}]\n        })\n      }\n\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      backReferences.push(backReference)\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: state.clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(def, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: state.footnoteLabelTagName,\n        properties: {\n          // To do: use structured clone.\n          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: state.footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('mdast-util-to-hast').Options} Options\n * @typedef {import('unified').Processor<any, any, any, any>} Processor\n *\n * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(\n\n/**\n * Plugin that turns markdown into HTML to support rehype.\n *\n * *   If a destination processor is given, that processor runs with a new HTML\n *     (hast) tree (bridge-mode).\n *     As the given processor runs with a hast tree, and rehype plugins support\n *     hast, that means rehype plugins can be used with the given processor.\n *     The hast tree is discarded in the end.\n *     It’s highly unlikely that you want to do this.\n * *   The common case is to not pass a destination processor, in which case the\n *     current processor continues running with a new HTML (hast) tree\n *     (mutate-mode).\n *     As the current processor continues with a hast tree, and rehype plugins\n *     support hast, that means rehype plugins can be used after\n *     `remark-rehype`.\n *     It’s likely that this is what you want to do.\n *\n * @param destination\n *   Optional unified processor.\n * @param options\n *   Options passed to `mdast-util-to-hast`.\n */\nconst remarkRehype =\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  (\n    function (destination, options) {\n      return destination && 'run' in destination\n        ? bridge(destination, options)\n        : mutate(destination || options)\n    }\n  )\n\nexport default remarkRehype\n\n/**\n * Bridge-mode.\n * Runs the destination with the new hast tree.\n *\n * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}\n */\nfunction bridge(destination, options) {\n  return (node, file, next) => {\n    destination.run(toHast(node, options), file, (error) => {\n      next(error)\n    })\n  }\n}\n\n/**\n * Mutate-mode.\n * Further plugins run on the hast tree.\n *\n * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}\n */\nfunction mutate(options) {\n  // @ts-expect-error: assume a corresponding node is returned by `toHast`.\n  return (node) => toHast(node, options)\n}\n"],"names":["footnoteReference","state","node","id","String","identifier","toUpperCase","safeId","normalizeUri","toLowerCase","index","footnoteOrder","indexOf","counter","push","footnoteCounts","length","reuseCounter","link","type","tagName","properties","href","clobberPrefix","dataFootnoteRef","ariaDescribedBy","children","value","patch","sup","applyData","revert","subtype","referenceType","suffix","label","alt","contents","all","head","unshift","tail","listItemLoose","spread","handlers","blockquote","result","wrap","break","code","lang","match","className","meta","data","delete","emphasis","footnote","footnoteById","no","position","heading","depth","html","dangerous","imageReference","def","definition","src","url","title","undefined","image","inlineCode","text","replace","linkReference","listItem","parent","results","loose","listLoose","checked","paragraph","disabled","child","list","start","Array","isArray","includes","ordered","root","strong","table","rows","firstRow","shift","tableContent","body","pointStart","end","pointEnd","line","tableCell","tableRow","siblings","align","cellIndex","cells","cell","alignValue","trimLines","thematicBreak","toml","ignore","yaml","footnoteDefinition","toHast","tree","options","createState","one","foot","listItems","content","referenceIndex","backReferences","backReference","dataFootnoteBackref","ariaLabel","footnoteBackLabel","tailTail","dataFootnotes","footnoteLabelTagName","JSON","parse","stringify","footnoteLabelProperties","footnoteLabel","footer","destination","file","next","run","error","bridge","mutate"],"sourceRoot":""}
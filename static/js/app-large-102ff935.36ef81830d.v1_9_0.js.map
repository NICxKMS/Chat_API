{"version":3,"file":"static/js/app-large-102ff935.36ef81830d.v1_9_0.js","mappings":"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","sources":["hooks/useProfilePicture.js","hooks/useMediaQuery.js","hooks/useLocalStorage.js","hooks/useSettingsController.js","index.js","hooks/useCacheToggle.js","firebaseConfig.js","hooks/useChatLogic.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n// Time-to-live for cache entries (1 day in milliseconds)\nconst TTL = 24 * 60 * 60 * 1000;\n\n/**\n * Custom hook to fetch and cache user profile picture with a 1-day TTL.\n * @param {string} imageUrl - The URL to fetch the profile picture from.\n * @returns {{ profilePicture: string | null, loading: boolean, error: any }}\n */\nexport const useProfilePicture = (imageUrl) => {\n  const cacheKey = `profilePicture_${imageUrl}`;\n  // cachedEntry is either null, a string (legacy), or { data, timestamp }\n  const [cachedEntry, setCachedEntry] = useLocalStorage(cacheKey, null);\n  const [profilePicture, setProfilePicture] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (!imageUrl) {\n      // No URL: clear state\n      setProfilePicture(null);\n      setLoading(false);\n      return;\n    }\n\n    // Validate cache entry\n    let entry = cachedEntry;\n    if (entry) {\n      // Legacy format: string\n      if (typeof entry === 'string') {\n        const wrapped = { data: entry, timestamp: Date.now() };\n        setCachedEntry(wrapped);\n        entry = wrapped;\n      }\n      // TTL check\n      if (\n        entry.timestamp &&\n        Date.now() - entry.timestamp < TTL &&\n        entry.data\n      ) {\n        setProfilePicture(entry.data);\n        setLoading(false);\n        return;\n      }\n      // Expired cache\n      setCachedEntry(null);\n    }\n\n    // Fetch and cache new image\n    setLoading(true);\n    fetch(imageUrl)\n      .then((response) => {\n        if (!response.ok) throw new Error(`Failed to fetch image: ${response.status}`);\n        return response.blob();\n      })\n      .then(\n        (blob) =>\n          new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n          })\n      )\n      .then((dataUrl) => {\n        if (!isMounted) return;\n        const entryToCache = { data: dataUrl, timestamp: Date.now() };\n        setCachedEntry(entryToCache);\n        setProfilePicture(dataUrl);\n      })\n      .catch((err) => {\n        if (!isMounted) return;\n        console.error('Error fetching and caching profile image:', err);\n        setError(err);\n      })\n      .finally(() => {\n        if (!isMounted) return;\n        setLoading(false);\n      });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [imageUrl, cachedEntry, setCachedEntry]);\n\n  return { profilePicture, loading, error };\n}; ","import { useState, useEffect, useMemo } from 'react';\n\n// Define breakpoint constants in a single source of truth\nexport const BREAKPOINTS = {\n  mobile: '640px',\n  tablet: '1023px',\n  desktop: '1024px',\n  settings: '550px'\n};\n\n// Cached media query listeners\nconst mediaQueryListeners = new Map();\n\n/**\n * Custom hook that returns true if the current viewport matches the provided media query\n * @param {string} query - Media query string e.g., \"(max-width: 1024px)\"\n * @returns {boolean} - True if the media query matches\n */\nexport const useMediaQuery = (query) => {\n  // Initialize with the current match state\n  const [matches, setMatches] = useState(() => {\n    // Check for window to avoid SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    // Avoid running in SSR context\n    if (typeof window === 'undefined') {\n      return undefined;\n    }\n\n    // Check if we already have a listener for this query\n    if (!mediaQueryListeners.has(query)) {\n      // Create media query list\n      const mediaQueryList = window.matchMedia(query);\n      \n      // Create listener registry for this query\n      mediaQueryListeners.set(query, {\n        mediaQueryList,\n        listeners: new Set()\n      });\n    }\n    \n    const queryData = mediaQueryListeners.get(query);\n    const { mediaQueryList, listeners } = queryData;\n\n    // Initial check\n    setMatches(mediaQueryList.matches);\n\n    // Define listener function\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener to registry\n    listeners.add(listener);\n\n    // Modern browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener);\n      return () => {\n        mediaQueryList.removeEventListener('change', listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    } \n    // Legacy support for older browsers (e.g., IE, older Safari)\n    else if (mediaQueryList.addListener) {\n      mediaQueryList.addListener(listener);\n      return () => {\n        mediaQueryList.removeListener(listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    }\n\n    return undefined;\n  }, [query]);\n\n  return matches;\n};\n\n/**\n * Pre-configured hooks for common breakpoints\n */\nexport const useIsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.mobile})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsTablet = () => {\n  const query = useMemo(() => \n    `(min-width: calc(${BREAKPOINTS.mobile} + 1px)) and (max-width: ${BREAKPOINTS.tablet})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsDesktop = () => {\n  const query = useMemo(() => `(min-width: ${BREAKPOINTS.desktop})`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Special hook for settings components\n */\nexport const useIsSettingsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.settings})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsSettingsDesktop = () => {\n  const query = useMemo(() => `(min-width: calc(${BREAKPOINTS.settings} + 1px))`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Get a consistent breakpoint value across the app\n * @returns {{mobile: string, tablet: string, desktop: string, settings: string}}\n */\nexport const useBreakpoints = () => {\n  return BREAKPOINTS;\n}; ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; ","import { useSettings } from '../contexts/SettingsContext';\nimport { useCacheToggle } from './useCacheToggle';\nimport { useAuth } from '../contexts/AuthContext';\n\n/**\n * Hook to provide consolidated settings control logic\n * @returns {Object} settings controller with settings, updateSetting, resetSettings, cacheEnabled, toggleCache, and currentUser\n */\nexport const useSettingsController = () => {\n  const {\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings\n  } = useSettings();\n  const { cacheEnabled, toggleCache } = useCacheToggle();\n  const { currentUser } = useAuth();\n\n  return {\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings,\n    cacheEnabled,\n    toggleCache,\n    currentUser\n  };\n}; ","import './utils/polyfills';\nimport React, { Suspense, lazy } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './styles/common/colors.css';\nimport './styles/common/tokens.css';\nimport './styles/theme.css';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { ToastProvider } from './contexts/ToastContext';\nimport { LoadingProvider } from './contexts/LoadingContext';\nimport GlobalLoadingIndicator from './components/common/GlobalLoadingIndicator';\n\n// Lazy-load the App component to reduce initial bundle size\nconst App = lazy(() => import(/* webpackChunkName: \"app-shell\" */ './App'));\n\n// Set initial theme class on <body> so theme mappings (light-mode/dark-mode) take effect\nconst prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n// Apply body class for index.css mappings\ndocument.body.classList.add(prefersDark ? 'dark-mode' : 'light-mode');\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <ToastProvider>\n      <LoadingProvider>\n        <Suspense fallback={\n          <div style={{ \n            display: 'flex', \n            justifyContent: 'center', \n            alignItems: 'center', \n            height: '100vh' \n          }}>\n            Loading...\n          </div>\n        }>\n          <App />\n        </Suspense>\n        <GlobalLoadingIndicator />\n      </LoadingProvider>\n    </ToastProvider>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\n// Fetch Firebase configuration from environment variables\nconst firebaseConfig = {\n  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.REACT_APP_FIREBASE_APP_ID,\n  // measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID // Optional\n};\n\nlet app = null;\nlet auth = null;\n\nexport const initializeFirebase = () => {\n  if (app) return { app, auth };\n\n  if (\n    firebaseConfig.apiKey &&\n    firebaseConfig.authDomain &&\n    firebaseConfig.projectId &&\n    firebaseConfig.appId\n  ) {\n    try {\n      app = initializeApp(firebaseConfig);\n      auth = getAuth(app);\n      console.log(\"Firebase initialized successfully.\");\n    } catch (error) {\n      console.error(\"Firebase initialization failed:\", error);\n      app = null;\n      auth = null;\n    }\n  } else {\n    console.warn(\n      \"Firebase configuration environment variables are missing. \" +\n      \"Please set REACT_APP_FIREBASE_API_KEY, REACT_APP_FIREBASE_AUTH_DOMAIN, \" +\n      \"REACT_APP_FIREBASE_PROJECT_ID, and REACT_APP_FIREBASE_APP_ID in your .env file.\"\n    );\n  }\n  \n  return { app, auth };\n};\n\nexport const getFirebaseAuth = () => {\n  if (!auth) {\n    const { auth: newAuth } = initializeFirebase();\n    return newAuth;\n  }\n  return auth;\n};\n\nexport const getFirebaseApp = () => {\n  if (!app) {\n    const { app: newApp } = initializeFirebase();\n    return newApp;\n  }\n  return app;\n}; ","import { useCallback } from 'react';\nimport { useChatState } from '../contexts/ChatStateContext';\nimport { useChatControl } from '../contexts/ChatControlContext';\nimport { useModel } from '../contexts/ModelContext';\nimport { useSettings } from '../contexts/SettingsContext';\n\n// Helper to generate unique IDs\nconst generateUniqueId = () => {\n  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n};\n\n/**\n * Custom Hook for Chat Container Logic\n * Encapsulates state management, API calls, and event handlers \n * related to the chat interface.\n */\nexport const useChatLogic = () => {\n  const {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    currentMessageMetrics: metrics\n  } = useChatState();\n  const { sendMessage: submitMessage, clearChat: resetChat, downloadChatHistory } = useChatControl();\n  \n  const { selectedModel } = useModel();\n  const { settings } = useSettings();\n  \n  // Enhanced function to handle sending messages, including edits\n  const handleSendMessage = useCallback(async (message, editedMessage = null) => {\n    const isEditing = !!editedMessage;\n    \n    // Handle both string and array payloads for content validation\n    const messageContent = Array.isArray(message) \n      ? message.map(part => part.type === 'text' ? part.text : '').join(' ').trim()\n      : message;\n\n    if (!messageContent && !Array.isArray(message)) return;\n    if (!selectedModel) return;\n    \n    try {\n      if (isEditing) {\n        // Get or create unique identifier for the message\n        const editMsgId = editedMessage.uniqueId || editedMessage.id || editedMessage.timestamp;\n        // Find the index of the message being edited with a single pass\n        const editIndex = chatHistory.findIndex(msg =>\n          [msg.uniqueId, msg.id, msg.timestamp].includes(editMsgId) ||\n          (typeof msg.content === 'string' && msg.content === editedMessage.content && msg.role === 'user')\n        );\n        if (editIndex === -1) {\n          return;\n        }\n        // Ensure the message to be submitted has the correct uniqueId\n        const finalMessage = Array.isArray(message) ? message : { type: 'text', text: message };\n        \n        // Add uniqueId to message\n        if (Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = editMsgId;\n        } else {\n          finalMessage.uniqueId = editMsgId;\n        }\n        \n        // Call the submitMessage function with the truncated history index\n        await submitMessage(finalMessage, editIndex);\n      } else {\n        // For new messages, generate a unique ID\n        const uniqueId = generateUniqueId();\n        \n        // Add uniqueId to new message\n        const finalMessage = Array.isArray(message) \n          ? message.map(part => ({...part, uniqueId}))\n          : message;\n          \n        if (!Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = uniqueId;\n        }\n        \n        // Normal message submission with uniqueId\n        await submitMessage(finalMessage);\n      }\n    } catch (err) {\n      console.error(`Error ${isEditing ? 'editing' : 'submitting'} message:`, err);\n    }\n  }, [selectedModel, submitMessage, chatHistory]);\n\n  // Return values needed by the ChatContainer component\n  return {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics,\n    selectedModel,\n    settings,\n    handleSendMessage,\n    resetChat, \n    downloadChatHistory,\n  };\n}; "],"names":["useProfilePicture","imageUrl","cacheKey","cachedEntry","setCachedEntry","useLocalStorage","profilePicture","setProfilePicture","useState","loading","setLoading","error","setError","useEffect","isMounted","entry","wrapped","data","timestamp","Date","now","fetch","then","response","ok","Error","status","blob","Promise","resolve","reject","reader","FileReader","onloadend","result","onerror","readAsDataURL","dataUrl","entryToCache","catch","err","finally","BREAKPOINTS","mediaQueryListeners","Map","useMediaQuery","query","matches","setMatches","window","matchMedia","has","mediaQueryList","set","listeners","Set","queryData","get","listener","event","add","addEventListener","removeEventListener","delete","size","addListener","removeListener","useIsDesktop","useMemo","useIsSettingsMobile","key","initialValue","initialValueRef","useRef","storedValue","setStoredValue","item","localStorage","getItem","JSON","parse","current","setValue","useCallback","value","valueToStore","Function","setItem","stringify","useSettingsController","settings","updateSetting","resetSettings","shouldRestrictTemperature","getModelAdjustedSettings","useSettings","cacheEnabled","toggleCache","useCacheToggle","currentUser","useAuth","App","lazy","prefersDark","document","body","classList","ReactDOM","getElementById","render","_jsx","React","children","ToastProvider","_jsxs","LoadingProvider","Suspense","fallback","style","display","justifyContent","alignItems","height","GlobalLoadingIndicator","reportWebVitals","serviceWorkerRegistration","onUpdate","registration","waitingServiceWorker","waiting","target","state","location","reload","postMessage","type","setCacheEnabled","clearModelCache","removeItem","enabled","newValue","refreshModels","originalFunc","isCacheValid","cache","allModels","processedModels","experimentalModels","firebaseConfig","apiKey","process","authDomain","projectId","storageBucket","messagingSenderId","appId","app","auth","initializeFirebase","initializeApp","getAuth","getFirebaseAuth","newAuth","getFirebaseApp","newApp","useChatLogic","chatHistory","isWaitingForResponse","currentMessageMetrics","metrics","useChatState","sendMessage","submitMessage","clearChat","resetChat","downloadChatHistory","useChatControl","selectedModel","useModel","handleSendMessage","async","message","editedMessage","arguments","length","undefined","isEditing","Array","isArray","map","part","text","join","trim","editMsgId","uniqueId","id","editIndex","findIndex","msg","includes","content","role","finalMessage","Math","random","toString","substring"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor.refractor-928495cb.689d0cb4d5.chunk.v1_7_5.js","mappings":"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","sources":["../node_modules/refractor/lang/jsonp.js","../node_modules/refractor/lang/json.js","../node_modules/refractor/lang/js-templates.js","../node_modules/refractor/lang/jsstacktrace.js","../node_modules/refractor/lang/jsdoc.js","../node_modules/refractor/lang/js-extras.js","../node_modules/refractor/lang/json5.js","../node_modules/refractor/lang/jsx.js"],"sourcesContent":["'use strict'\nvar refractorJson = require('./json.js')\nmodule.exports = jsonp\njsonp.displayName = 'jsonp'\njsonp.aliases = []\nfunction jsonp(Prism) {\n  Prism.register(refractorJson)\n  Prism.languages.jsonp = Prism.languages.extend('json', {\n    punctuation: /[{}[\\]();,.]/\n  })\n  Prism.languages.insertBefore('jsonp', 'punctuation', {\n    function: /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*\\()/\n  })\n}\n","'use strict'\n\nmodule.exports = json\njson.displayName = 'json'\njson.aliases = ['webmanifest']\nfunction json(Prism) {\n  // https://www.json.org/json-en.html\n  Prism.languages.json = {\n    property: {\n      pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n      lookbehind: true,\n      greedy: true\n    },\n    string: {\n      pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n      lookbehind: true,\n      greedy: true\n    },\n    comment: {\n      pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      greedy: true\n    },\n    number: /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    punctuation: /[{}[\\],]/,\n    operator: /:/,\n    boolean: /\\b(?:false|true)\\b/,\n    null: {\n      pattern: /\\bnull\\b/,\n      alias: 'keyword'\n    }\n  }\n  Prism.languages.webmanifest = Prism.languages.json\n}\n","'use strict'\n\nmodule.exports = jsTemplates\njsTemplates.displayName = 'jsTemplates'\njsTemplates.aliases = []\nfunction jsTemplates(Prism) {\n  ;(function (Prism) {\n    var templateString = Prism.languages.javascript['template-string'] // see the pattern in prism-javascript.js\n    var templateLiteralPattern = templateString.pattern.source\n    var interpolationObject = templateString.inside['interpolation']\n    var interpolationPunctuationObject =\n      interpolationObject.inside['interpolation-punctuation']\n    var interpolationPattern = interpolationObject.pattern.source\n    /**\n     * Creates a new pattern to match a template string with a special tag.\n     *\n     * This will return `undefined` if there is no grammar with the given language id.\n     *\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\n     * @param {string} tag The regex pattern to match the tag.\n     * @returns {object | undefined}\n     * @example\n     * createTemplate('css', /\\bcss/.source);\n     */\n    function createTemplate(language, tag) {\n      if (!Prism.languages[language]) {\n        return undefined\n      }\n      return {\n        pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          'template-punctuation': {\n            pattern: /^`|`$/,\n            alias: 'string'\n          },\n          'embedded-code': {\n            pattern: /[\\s\\S]+/,\n            alias: language\n          }\n        }\n      }\n    }\n    Prism.languages.javascript['template-string'] = [\n      // styled-jsx:\n      //   css`a { color: #25F; }`\n      // styled-components:\n      //   styled.h1`color: red;`\n      createTemplate(\n        'css',\n        /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/\n          .source\n      ), // html`<p></p>`\n      // div.innerHTML = `<p></p>`\n      createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n      createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n      createTemplate('markdown', /\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n      createTemplate(\n        'graphql',\n        /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source\n      ), // sql`...`\n      createTemplate('sql', /\\bsql/.source), // vanilla template string\n      templateString\n    ].filter(Boolean)\n    /**\n     * Returns a specific placeholder literal for the given language.\n     *\n     * @param {number} counter\n     * @param {string} language\n     * @returns {string}\n     */\n    function getPlaceholder(counter, language) {\n      return '___' + language.toUpperCase() + '_' + counter + '___'\n    }\n    /**\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n     *\n     * @param {string} code\n     * @param {any} grammar\n     * @param {string} language\n     * @returns {(string|Token)[]}\n     */\n    function tokenizeWithHooks(code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language\n      }\n      Prism.hooks.run('before-tokenize', env)\n      env.tokens = Prism.tokenize(env.code, env.grammar)\n      Prism.hooks.run('after-tokenize', env)\n      return env.tokens\n    }\n    /**\n     * Returns the token of the given JavaScript interpolation expression.\n     *\n     * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n     * @returns {Token}\n     */\n    function tokenizeInterpolationExpression(expression) {\n      var tempGrammar = {}\n      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject\n      /** @type {Array} */\n      var tokens = Prism.tokenize(expression, tempGrammar)\n      if (tokens.length === 3) {\n        /**\n         * The token array will look like this\n         * [\n         *     [\"interpolation-punctuation\", \"${\"]\n         *     \"...\" // JavaScript expression of the interpolation\n         *     [\"interpolation-punctuation\", \"}\"]\n         * ]\n         */\n        var args = [1, 1]\n        args.push.apply(\n          args,\n          tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript')\n        )\n        tokens.splice.apply(tokens, args)\n      }\n      return new Prism.Token(\n        'interpolation',\n        tokens,\n        interpolationObject.alias,\n        expression\n      )\n    }\n    /**\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n     *\n     * This function has 3 phases:\n     *\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\n     *    The placeholder will have the syntax of a identify of the target language.\n     * 2. Tokenize the code with placeholders.\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n     *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n     *    tokenized as two tokens by the grammar of the embedded language.\n     *\n     * @param {string} code\n     * @param {object} grammar\n     * @param {string} language\n     * @returns {Token}\n     */\n    function tokenizeEmbedded(code, grammar, language) {\n      // 1. First filter out all interpolations\n      // because they might be escaped, we need a lookbehind, so we use Prism\n      /** @type {(Token|string)[]} */\n      var _tokens = Prism.tokenize(code, {\n        interpolation: {\n          pattern: RegExp(interpolationPattern),\n          lookbehind: true\n        }\n      }) // replace all interpolations with a placeholder which is not in the code already\n      var placeholderCounter = 0\n      /** @type {Object<string, string>} */\n      var placeholderMap = {}\n      var embeddedCode = _tokens\n        .map(function (token) {\n          if (typeof token === 'string') {\n            return token\n          } else {\n            var interpolationExpression = token.content\n            var placeholder\n            while (\n              code.indexOf(\n                (placeholder = getPlaceholder(placeholderCounter++, language))\n              ) !== -1\n            ) {\n              /* noop */\n            }\n            placeholderMap[placeholder] = interpolationExpression\n            return placeholder\n          }\n        })\n        .join('') // 2. Tokenize the embedded code\n      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language) // 3. Re-insert the interpolation\n      var placeholders = Object.keys(placeholderMap)\n      placeholderCounter = 0\n      /**\n       *\n       * @param {(Token|string)[]} tokens\n       * @returns {void}\n       */\n      function walkTokens(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (placeholderCounter >= placeholders.length) {\n            return\n          }\n          var token = tokens[i]\n          if (typeof token === 'string' || typeof token.content === 'string') {\n            var placeholder = placeholders[placeholderCounter]\n            var s =\n              typeof token === 'string'\n                ? token\n                : /** @type {string} */\n                  token.content\n            var index = s.indexOf(placeholder)\n            if (index !== -1) {\n              ++placeholderCounter\n              var before = s.substring(0, index)\n              var middle = tokenizeInterpolationExpression(\n                placeholderMap[placeholder]\n              )\n              var after = s.substring(index + placeholder.length)\n              var replacement = []\n              if (before) {\n                replacement.push(before)\n              }\n              replacement.push(middle)\n              if (after) {\n                var afterTokens = [after]\n                walkTokens(afterTokens)\n                replacement.push.apply(replacement, afterTokens)\n              }\n              if (typeof token === 'string') {\n                tokens.splice.apply(tokens, [i, 1].concat(replacement))\n                i += replacement.length - 1\n              } else {\n                token.content = replacement\n              }\n            }\n          } else {\n            var content = token.content\n            if (Array.isArray(content)) {\n              walkTokens(content)\n            } else {\n              walkTokens([content])\n            }\n          }\n        }\n      }\n      walkTokens(embeddedTokens)\n      return new Prism.Token(\n        language,\n        embeddedTokens,\n        'language-' + language,\n        code\n      )\n    }\n    /**\n     * The languages for which JS templating will handle tagged template literals.\n     *\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n     */\n    var supportedLanguages = {\n      javascript: true,\n      js: true,\n      typescript: true,\n      ts: true,\n      jsx: true,\n      tsx: true\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (!(env.language in supportedLanguages)) {\n        return\n      }\n      /**\n       * Finds and tokenizes all template strings with an embedded languages.\n       *\n       * @param {(Token | string)[]} tokens\n       * @returns {void}\n       */\n      function findTemplateStrings(tokens) {\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i]\n          if (typeof token === 'string') {\n            continue\n          }\n          var content = token.content\n          if (!Array.isArray(content)) {\n            if (typeof content !== 'string') {\n              findTemplateStrings([content])\n            }\n            continue\n          }\n          if (token.type === 'template-string') {\n            /**\n             * A JavaScript template-string token will look like this:\n             *\n             * [\"template-string\", [\n             *     [\"template-punctuation\", \"`\"],\n             *     (\n             *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n             *         or\n             *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n             *                                  It also has an alias which is the language of the embedded code.\n             *     ),\n             *     [\"template-punctuation\", \"`\"]\n             * ]]\n             */\n            var embedded = content[1]\n            if (\n              content.length === 3 &&\n              typeof embedded !== 'string' &&\n              embedded.type === 'embedded-code'\n            ) {\n              // get string content\n              var code = stringContent(embedded)\n              var alias = embedded.alias\n              var language = Array.isArray(alias) ? alias[0] : alias\n              var grammar = Prism.languages[language]\n              if (!grammar) {\n                // the embedded language isn't registered.\n                continue\n              }\n              content[1] = tokenizeEmbedded(code, grammar, language)\n            }\n          } else {\n            findTemplateStrings(content)\n          }\n        }\n      }\n      findTemplateStrings(env.tokens)\n    })\n    /**\n     * Returns the string content of a token or token stream.\n     *\n     * @param {string | Token | (string | Token)[]} value\n     * @returns {string}\n     */\n    function stringContent(value) {\n      if (typeof value === 'string') {\n        return value\n      } else if (Array.isArray(value)) {\n        return value.map(stringContent).join('')\n      } else {\n        return stringContent(value.content)\n      }\n    }\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = jsstacktrace\njsstacktrace.displayName = 'jsstacktrace'\njsstacktrace.aliases = []\nfunction jsstacktrace(Prism) {\n  Prism.languages.jsstacktrace = {\n    'error-message': {\n      pattern: /^\\S.*/m,\n      alias: 'string'\n    },\n    'stack-frame': {\n      pattern: /(^[ \\t]+)at[ \\t].*/m,\n      lookbehind: true,\n      inside: {\n        'not-my-code': {\n          pattern:\n            /^at[ \\t]+(?!\\s)(?:node\\.js|<unknown>|.*(?:node_modules|\\(<anonymous>\\)|\\(<unknown>|<anonymous>$|\\(internal\\/|\\(node\\.js)).*/m,\n          alias: 'comment'\n        },\n        filename: {\n          pattern: /(\\bat\\s+(?!\\s)|\\()(?:[a-zA-Z]:)?[^():]+(?=:)/,\n          lookbehind: true,\n          alias: 'url'\n        },\n        function: {\n          pattern:\n            /(\\bat\\s+(?:new\\s+)?)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF<][.$\\w\\xA0-\\uFFFF<>]*/,\n          lookbehind: true,\n          inside: {\n            punctuation: /\\./\n          }\n        },\n        punctuation: /[()]/,\n        keyword: /\\b(?:at|new)\\b/,\n        alias: {\n          pattern: /\\[(?:as\\s+)?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*\\]/,\n          alias: 'variable'\n        },\n        'line-number': {\n          pattern: /:\\d+(?::\\d+)?\\b/,\n          alias: 'number',\n          inside: {\n            punctuation: /:/\n          }\n        }\n      }\n    }\n  }\n}\n","'use strict'\nvar refractorJavadoclike = require('./javadoclike.js')\nvar refractorTypescript = require('./typescript.js')\nmodule.exports = jsdoc\njsdoc.displayName = 'jsdoc'\njsdoc.aliases = []\nfunction jsdoc(Prism) {\n  Prism.register(refractorJavadoclike)\n  Prism.register(refractorTypescript)\n  ;(function (Prism) {\n    var javascript = Prism.languages.javascript\n    var type = /\\{(?:[^{}]|\\{(?:[^{}]|\\{[^{}]*\\})*\\})+\\}/.source\n    var parameterPrefix =\n      '(@(?:arg|argument|param|property)\\\\s+(?:' + type + '\\\\s+)?)'\n    Prism.languages.jsdoc = Prism.languages.extend('javadoclike', {\n      parameter: {\n        // @param {string} foo - foo bar\n        pattern: RegExp(\n          parameterPrefix + /(?:(?!\\s)[$\\w\\xA0-\\uFFFF.])+(?=\\s|$)/.source\n        ),\n        lookbehind: true,\n        inside: {\n          punctuation: /\\./\n        }\n      }\n    })\n    Prism.languages.insertBefore('jsdoc', 'keyword', {\n      'optional-parameter': {\n        // @param {string} [baz.foo=\"bar\"] foo bar\n        pattern: RegExp(\n          parameterPrefix +\n            /\\[(?:(?!\\s)[$\\w\\xA0-\\uFFFF.])+(?:=[^[\\]]+)?\\](?=\\s|$)/.source\n        ),\n        lookbehind: true,\n        inside: {\n          parameter: {\n            pattern: /(^\\[)[$\\w\\xA0-\\uFFFF\\.]+/,\n            lookbehind: true,\n            inside: {\n              punctuation: /\\./\n            }\n          },\n          code: {\n            pattern: /(=)[\\s\\S]*(?=\\]$)/,\n            lookbehind: true,\n            inside: javascript,\n            alias: 'language-javascript'\n          },\n          punctuation: /[=[\\]]/\n        }\n      },\n      'class-name': [\n        {\n          pattern: RegExp(\n            /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\\s+(?:<TYPE>\\s+)?)[A-Z]\\w*(?:\\.[A-Z]\\w*)*/.source.replace(\n              /<TYPE>/g,\n              function () {\n                return type\n              }\n            )\n          ),\n          lookbehind: true,\n          inside: {\n            punctuation: /\\./\n          }\n        },\n        {\n          pattern: RegExp('(@[a-z]+\\\\s+)' + type),\n          lookbehind: true,\n          inside: {\n            string: javascript.string,\n            number: javascript.number,\n            boolean: javascript.boolean,\n            keyword: Prism.languages.typescript.keyword,\n            operator: /=>|\\.\\.\\.|[&|?:*]/,\n            punctuation: /[.,;=<>{}()[\\]]/\n          }\n        }\n      ],\n      example: {\n        pattern:\n          /(@example\\s+(?!\\s))(?:[^@\\s]|\\s+(?!\\s))+?(?=\\s*(?:\\*\\s*)?(?:@\\w|\\*\\/))/,\n        lookbehind: true,\n        inside: {\n          code: {\n            pattern: /^([\\t ]*(?:\\*\\s*)?)\\S.*$/m,\n            lookbehind: true,\n            inside: javascript,\n            alias: 'language-javascript'\n          }\n        }\n      }\n    })\n    Prism.languages.javadoclike.addSupport('javascript', Prism.languages.jsdoc)\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = jsExtras\njsExtras.displayName = 'jsExtras'\njsExtras.aliases = []\nfunction jsExtras(Prism) {\n  ;(function (Prism) {\n    Prism.languages.insertBefore('javascript', 'function-variable', {\n      'method-variable': {\n        pattern: RegExp(\n          '(\\\\.\\\\s*)' +\n            Prism.languages.javascript['function-variable'].pattern.source\n        ),\n        lookbehind: true,\n        alias: ['function-variable', 'method', 'function', 'property-access']\n      }\n    })\n    Prism.languages.insertBefore('javascript', 'function', {\n      method: {\n        pattern: RegExp(\n          '(\\\\.\\\\s*)' + Prism.languages.javascript['function'].source\n        ),\n        lookbehind: true,\n        alias: ['function', 'property-access']\n      }\n    })\n    Prism.languages.insertBefore('javascript', 'constant', {\n      'known-class-name': [\n        {\n          // standard built-ins\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n          pattern:\n            /\\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\\b/,\n          alias: 'class-name'\n        },\n        {\n          // errors\n          pattern: /\\b(?:[A-Z]\\w*)Error\\b/,\n          alias: 'class-name'\n        }\n      ]\n    })\n    /**\n     * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.\n     *\n     * @param {string} source\n     * @param {string} [flags]\n     * @returns {RegExp}\n     */\n    function withId(source, flags) {\n      return RegExp(\n        source.replace(/<ID>/g, function () {\n          return /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/.source\n        }),\n        flags\n      )\n    }\n    Prism.languages.insertBefore('javascript', 'keyword', {\n      imports: {\n        // https://tc39.es/ecma262/#sec-imports\n        pattern: withId(\n          /(\\bimport\\b\\s*)(?:<ID>(?:\\s*,\\s*(?:\\*\\s*as\\s+<ID>|\\{[^{}]*\\}))?|\\*\\s*as\\s+<ID>|\\{[^{}]*\\})(?=\\s*\\bfrom\\b)/\n            .source\n        ),\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      },\n      exports: {\n        // https://tc39.es/ecma262/#sec-exports\n        pattern: withId(\n          /(\\bexport\\b\\s*)(?:\\*(?:\\s*as\\s+<ID>)?(?=\\s*\\bfrom\\b)|\\{[^{}]*\\})/\n            .source\n        ),\n        lookbehind: true,\n        inside: Prism.languages.javascript\n      }\n    })\n    Prism.languages.javascript['keyword'].unshift(\n      {\n        pattern: /\\b(?:as|default|export|from|import)\\b/,\n        alias: 'module'\n      },\n      {\n        pattern:\n          /\\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\\b/,\n        alias: 'control-flow'\n      },\n      {\n        pattern: /\\bnull\\b/,\n        alias: ['null', 'nil']\n      },\n      {\n        pattern: /\\bundefined\\b/,\n        alias: 'nil'\n      }\n    )\n    Prism.languages.insertBefore('javascript', 'operator', {\n      spread: {\n        pattern: /\\.{3}/,\n        alias: 'operator'\n      },\n      arrow: {\n        pattern: /=>/,\n        alias: 'operator'\n      }\n    })\n    Prism.languages.insertBefore('javascript', 'punctuation', {\n      'property-access': {\n        pattern: withId(/(\\.\\s*)#?<ID>/.source),\n        lookbehind: true\n      },\n      'maybe-class-name': {\n        pattern: /(^|[^$\\w\\xA0-\\uFFFF])[A-Z][$\\w\\xA0-\\uFFFF]+/,\n        lookbehind: true\n      },\n      dom: {\n        // this contains only a few commonly used DOM variables\n        pattern:\n          /\\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\\b/,\n        alias: 'variable'\n      },\n      console: {\n        pattern: /\\bconsole(?=\\s*\\.)/,\n        alias: 'class-name'\n      }\n    }) // add 'maybe-class-name' to tokens which might be a class name\n    var maybeClassNameTokens = [\n      'function',\n      'function-variable',\n      'method',\n      'method-variable',\n      'property-access'\n    ]\n    for (var i = 0; i < maybeClassNameTokens.length; i++) {\n      var token = maybeClassNameTokens[i]\n      var value = Prism.languages.javascript[token] // convert regex to object\n      if (Prism.util.type(value) === 'RegExp') {\n        value = Prism.languages.javascript[token] = {\n          pattern: value\n        }\n      } // keep in mind that we don't support arrays\n      var inside = value.inside || {}\n      value.inside = inside\n      inside['maybe-class-name'] = /^[A-Z][\\s\\S]*/\n    }\n  })(Prism)\n}\n","'use strict'\nvar refractorJson = require('./json.js')\nmodule.exports = json5\njson5.displayName = 'json5'\njson5.aliases = []\nfunction json5(Prism) {\n  Prism.register(refractorJson)\n  ;(function (Prism) {\n    var string = /(\"|')(?:\\\\(?:\\r\\n?|\\n|.)|(?!\\1)[^\\\\\\r\\n])*\\1/\n    Prism.languages.json5 = Prism.languages.extend('json', {\n      property: [\n        {\n          pattern: RegExp(string.source + '(?=\\\\s*:)'),\n          greedy: true\n        },\n        {\n          pattern:\n            /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/,\n          alias: 'unquoted'\n        }\n      ],\n      string: {\n        pattern: string,\n        greedy: true\n      },\n      number:\n        /[+-]?\\b(?:NaN|Infinity|0x[a-fA-F\\d]+)\\b|[+-]?(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[eE][+-]?\\d+\\b)?/\n    })\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source\n    /**\n     * @param {string} source\n     * @param {string} [flags]\n     */\n    function re(source, flags) {\n      source = source\n        .replace(/<S>/g, function () {\n          return space\n        })\n        .replace(/<BRACES>/g, function () {\n          return braces\n        })\n        .replace(/<SPREAD>/g, function () {\n          return spread\n        })\n      return RegExp(source, flags)\n    }\n    spread = re(spread).source\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = re(\n      /<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/\n        .source\n    )\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/\n    Prism.languages.jsx.tag.inside['attr-value'].pattern =\n      /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] =\n      /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.jsx.tag.inside['comment'] = javascript['comment']\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: re(/<SPREAD>/.source),\n          inside: Prism.languages.jsx\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'special-attr',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: re(/=<BRACES>/.source),\n          alias: 'language-javascript',\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?=\\{)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    ) // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n"],"names":["refractorJson","require","jsonp","Prism","register","languages","extend","punctuation","insertBefore","function","module","exports","displayName","aliases","json","property","pattern","lookbehind","greedy","string","comment","number","operator","boolean","null","alias","webmanifest","jsTemplates","templateString","javascript","templateLiteralPattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","interpolation","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","js","typescript","ts","jsx","tsx","stringContent","value","add","findTemplateStrings","l","type","embedded","jsstacktrace","filename","keyword","refractorJavadoclike","refractorTypescript","jsdoc","parameterPrefix","parameter","replace","example","javadoclike","addSupport","jsExtras","withId","flags","method","imports","unshift","spread","arrow","dom","console","maybeClassNameTokens","util","json5","clone","space","braces","re","script","rest","stringifyToken","openedTags","notTagNorBrace","tagName","pop","openedBraces","plainText"],"sourceRoot":""}
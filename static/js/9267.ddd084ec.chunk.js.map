{"version":3,"file":"static/js/9267.ddd084ec.chunk.js","mappings":"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","sources":["../node_modules/mdast-util-to-markdown/lib/util/association.js","../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../node_modules/mdast-util-to-markdown/lib/util/safe.js","../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../node_modules/mdast-util-to-markdown/lib/util/track.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/node-emoji/src/utils.ts","../node_modules/node-emoji/src/data.ts","../node_modules/node-emoji/src/get.ts","../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-chunked/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-character/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-classify-character/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-resolve-all/index.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","import charRegex from 'char-regex'\n\nexport const charRegexMatcher = charRegex()\n\nexport function asFunction<T extends PropertyKey, Args extends unknown[]>(\n  input: ((...args: Args) => T) | T,\n): (...args: Args) => T {\n  return typeof input === 'function' ? input : () => input\n}\n\n/**\n * Non spacing mark contained by some emoticons (65039 - '️' - 0xFE0F).\n *\n * It's the 'Variant Form', which provides more information so that emoticons\n * can be rendered as more colorful graphics. FE0E is a unicode text version\n * whereas FE0F should be rendered as a graphical version.\n * The code gracefully degrades.\n */\nconst NON_SPACING_MARK = String.fromCharCode(65039)\n\nconst nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g')\n\n/**\n * Removes the non-spacing-mark from the emoji code.\n *\n * Never send a stripped version to clients, as it kills graphical emoticons.\n */\nexport function normalizeCode(code: string) {\n  return code.replace(nonSpacingRegex, '')\n}\n\nexport function normalizeName(name: string) {\n  return /:.+:/.test(name) ? name.slice(1, -1) : name\n}\n\nexport function randomItem<T>(array: T[]) {\n  return array[Math.floor(Math.random() * array.length)]\n}\n","import emojilib from 'emojilib'\n\nimport { normalizeCode } from './utils.js'\n\nexport interface Emoji {\n  emoji: string\n  key: string\n}\n\nexport const emojiData = Object.entries(emojilib.lib).map(\n  ([name, { char: emoji }]) => [name, emoji] as const,\n)\n\nexport const emojiCodesByName = new Map(emojiData)\n\nexport const emojiNamesByCode = new Map(\n  emojiData.map(([name, emoji]) => [normalizeCode(emoji), name]),\n)\n","import { assert } from '@sindresorhus/is'\n\nimport { emojiCodesByName } from './data.js'\nimport { normalizeName } from './utils.js'\n\n/**\n * Get an emoji from an emoji name.\n */\nexport const get = (codeOrName: string) => {\n  assert.string(codeOrName)\n\n  return emojiCodesByName.get(normalizeName(codeOrName))\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {void}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if there’s only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, it’s fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, it’s fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde.\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n"],"names":["association","node","label","identifier","decodeString","inlineCode","_","state","value","sequence","index","RegExp","test","unsafe","length","pattern","expression","patternCompile","match","atBreak","exec","position","charCodeAt","slice","peek","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","safe","input","config","before","after","positions","result","infos","Boolean","push","sort","numerical","start","end","escapeBackslashes","charAt","encode","toString","toUpperCase","join","a","b","results","whole","_compiled","character","track","options","now","lineShift","line","column","move","chunks","split","tail","current","shift","findAndReplace","tree","settings","ignored","convert","ignore","pairs","tupleOrList","Array","isArray","TypeError","tuple","toExpression","toFunction","toPairs","pairIndex","visitParents","visitor","parents","grandparent","parent","siblings","children","undefined","indexOf","find","replace","change","nodes","lastIndex","matchObject","type","global","splice","handler","string","escape","charRegex","NON_SPACING_MARK","String","fromCharCode","nonSpacingRegex","normalizeCode","code","normalizeName","name","emojiData","Object","entries","emojilib","map","_ref","char","emoji","emojiCodesByName","Map","get","_ref2","codeOrName","assert3","listItem","info","listItemIndent","style","Error","checkListItemIndent","bullet","bulletCurrent","marker","checkBullet","ordered","incrementListMarker","size","spread","Math","ceil","tracker","createTracker","repeat","exit","enter","indentLines","containerFlow","blank","remove","items","parameters","chunkStart","from","unshift","regexCheck","unicodePunctuation","unicodeWhitespace","regex","classifyCharacter","markdownLineEndingOrSpace","resolveAll","constructs","events","context","called","resolve","gfmStrikethrough","single","singleTilde","tokenizer","tokenize","effects","ok","nok","previous","this","more","consume","token","_open","_close","open","offset","strikethrough","assign","text","nextEvents","insideSpan","parser","null","attentionMarkers","containerPhrasing","indexStack","child","handle","handlers","pop","bulletLastUsed","between","left","right","eol","one"],"sourceRoot":""}
{"version":3,"file":"static/js/main-52f0199e.03e4000714.v1_8_5.js","mappings":"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","sources":["contexts/AuthContext.js","contexts/ChatStatusContext.js","contexts/LoadingContext.js","contexts/ContextManager.js","contexts/ChatHistoryContext.js","components/common/ToastNotification/index.js","components/common/Spinner/index.js","components/common/GlobalLoadingIndicator/index.js","contexts/ApiContext.js","contexts/ChatControlContext.js","contexts/ChatStateContext.js","contexts/ModelContext.js"],"sourcesContent":["import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\nimport { useToast } from './ToastContext';\nimport { useLoading } from './LoadingContext';\n// Firebase is dynamically imported to avoid blocking\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [idToken, setIdToken] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially - we're proceeding anonymously\n  // Sync with global loading context for auth\n  const [, startAuthLoading, stopAuthLoading] = useLoading('auth');\n  const [error, setError] = useState(null);\n  const [isLoggingIn, setIsLoggingIn] = useState(false); // State to trigger login UI\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\n  const { showToast } = useToast();\n\n  useEffect(() => {\n    if (loading) startAuthLoading(); else stopAuthLoading();\n  }, [loading, startAuthLoading, stopAuthLoading]);\n\n  const login = useCallback(async () => {\n    console.log(\"Login button clicked, setting isLoggingIn to true.\");\n    setIsLoggingIn(true);\n  }, [setIsLoggingIn]);\n\n  const logout = useCallback(async () => {\n    if (!isFirebaseInitialized) {\n      console.log(\"Firebase not initialized yet, cannot logout.\");\n      return;\n    }\n    const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n    const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n    const auth = getFirebaseAuth();\n    if (!auth) {\n      const msg = \"Firebase not initialized.\";\n      setError(msg);\n      showToast({ type: 'error', message: msg });\n      return;\n    }\n    try {\n      await firebaseSignOut(auth);\n      console.log(\"Sign out successful.\");\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      const msg = err.message || 'Failed to logout.';\n      setError(msg);\n      showToast({ type: 'error', message: msg });\n    }\n  }, [isFirebaseInitialized, setError, showToast]);\n\n  // Effect to listen for Firebase auth state changes\n  useEffect(() => {\n    let unsubscribe = null;\n\n    // Listen for the 'firebaseInitialized' event from App.js\n    const handleFirebaseInit = () => {\n      console.log(\"Received Firebase initialized event\");\n      setIsFirebaseInitialized(true);\n      initializeAuthListener();\n    };\n\n    // Function to initialize auth listener\n    const initializeAuthListener = async () => {\n      setLoading(true);\n      // Dynamically import Firebase auth\n      const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n      const { onAuthStateChanged: firebaseOnAuthStateChanged } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n      \n      const auth = getFirebaseAuth();\n      if (!auth) {\n        console.warn(\"Auth service not available for onAuthStateChanged listener.\");\n        setLoading(false);\n        return;\n      }\n      \n      console.log(\"Setting up Firebase onAuthStateChanged listener.\");\n      unsubscribe = firebaseOnAuthStateChanged(auth, async (user) => {\n        setCurrentUser(user);\n        if (user) {\n          try {\n            // Force refresh is false by default, gets cached token if available\n            const token = await user.getIdToken();\n            setIdToken(token);\n            try { localStorage.setItem('idToken', token); } catch (e) { console.warn('Failed to cache idToken', e); }\n            setError(null); // Clear previous errors on successful login\n            setIsLoggingIn(false); // Ensure login UI closes if open\n            console.log(\"User signed in, token obtained.\");\n          } catch (err) {\n            console.error(\"Failed to get ID token:\", err);\n            const msg = \"Failed to get authentication token.\";\n            setError(msg);\n            showToast({ type: 'error', message: msg });\n            setIdToken(null);\n            // Optionally sign out the user if token fetch fails critically\n            const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n            await firebaseSignOut(auth);\n          }\n        } else {\n          // User is signed out\n          setIdToken(null);\n          try { localStorage.removeItem('idToken'); } catch (e) { console.warn('Failed to remove cached idToken', e); }\n          setIsLoggingIn(false); // Ensure login UI closes if open\n          console.log(\"User signed out.\");\n        }\n        setLoading(false); // Auth state determined\n      });\n    };\n\n    // Define a custom event for Firebase initialization\n    window.addEventListener('firebaseInitialized', handleFirebaseInit);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('firebaseInitialized', handleFirebaseInit);\n      if (typeof unsubscribe === 'function') {\n      console.log(\"Cleaning up Firebase onAuthStateChanged listener.\");\n        unsubscribe();\n      }\n    };\n  }, [showToast]);\n\n  const value = useMemo(() => ({\n    currentUser,\n    idToken,\n    loading,\n    error,\n    login,\n    logout,\n    isAuthenticated: !!currentUser && !!idToken,\n    isLoggingIn,\n    setIsLoggingIn,\n    isFirebaseInitialized\n  }), [currentUser, idToken, loading, error, login, logout, isLoggingIn, setIsLoggingIn, isFirebaseInitialized]);\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}; ","import { createContext, useContext, useState, useMemo, useEffect } from 'react';\nimport { useLoading } from './LoadingContext';\n\n// Create chat status context\nconst ChatStatusContext = createContext();\n\n// Hook to use chat status context\nexport const useChatStatus = () => {\n  const context = useContext(ChatStatusContext);\n  if (context === undefined) {\n    throw new Error('useChatStatus must be used within a ChatStatusProvider');\n  }\n  return context;\n};\n\n// Provider component for chat status\nexport const ChatStatusProvider = ({ children }) => {\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\n  const [error, setError] = useState(null);\n  // Sync with global loading context for chat\n  const [, startChatLoading, stopChatLoading] = useLoading('chat');\n  useEffect(() => {\n    if (isWaitingForResponse) startChatLoading();\n    else stopChatLoading();\n  }, [isWaitingForResponse, startChatLoading, stopChatLoading]);\n\n  const value = useMemo(() => ({\n    isWaitingForResponse,\n    setIsWaitingForResponse,\n    error,\n    setError,\n  }), [isWaitingForResponse, error]);\n\n  return (\n    <ChatStatusContext.Provider value={value}>\n      {children}\n    </ChatStatusContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useCallback } from 'react';\n\n// Context to track multiple loading tags\nconst LoadingContext = createContext(null);\n\n/**\n * Provider to wrap application and manage loading states by tags\n */\nexport const LoadingProvider = ({ children }) => {\n  const [loadingMap, setLoadingMap] = useState({});\n\n  const setLoading = useCallback((tag, isLoading) => {\n    setLoadingMap(prev => ({ ...prev, [tag]: isLoading }));\n  }, []);\n\n  const isLoading = useCallback(tag => !!loadingMap[tag], [loadingMap]);\n  const anyLoading = Object.values(loadingMap).some(val => val);\n\n  return (\n    <LoadingContext.Provider value={{ setLoading, isLoading, anyLoading }}>\n      {children}\n    </LoadingContext.Provider>\n  );\n};\n\n/**\n * Hook to control loading for a specific tag\n * @param {string} tag - Unique identifier for loading scope\n * @returns {[boolean, function, function]} [isLoading, startLoading, stopLoading]\n */\nexport const useLoading = (tag) => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useLoading must be used within LoadingProvider');\n  const { setLoading, isLoading } = context;\n  const startLoading = useCallback(() => setLoading(tag, true), [setLoading, tag]);\n  const stopLoading = useCallback(() => setLoading(tag, false), [setLoading, tag]);\n  return [isLoading(tag), startLoading, stopLoading];\n};\n\n/**\n * Hook to check if any loading is active globally\n * @returns {boolean}\n */\nexport const useGlobalLoading = () => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useGlobalLoading must be used within LoadingProvider');\n  return context.anyLoading;\n}; ","import { createContext, useContext, useMemo, useEffect } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatStatusProvider } from './ChatStatusContext';\nimport { ChatHistoryProvider } from './ChatHistoryContext';\nimport { PerformanceMetricsProvider } from './PerformanceMetricsContext';\nimport { StreamingEventsProvider } from './StreamingEventsContext';\nimport { ChatStateProvider } from './ChatStateContext';\nimport { ChatControlProvider } from './ChatControlContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n  // Mark as initialized once on mount\n  useEffect(() => {\n    initializationState.setInitialized(true);\n  }, [initializationState]);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatStatusProvider>\n                <ChatHistoryProvider>\n                  <PerformanceMetricsProvider>\n                    <StreamingEventsProvider>\n                      <ChatStateProvider>\n                        <ChatControlProvider>\n                          {children}\n                        </ChatControlProvider>\n                      </ChatStateProvider>\n                    </StreamingEventsProvider>\n                  </PerformanceMetricsProvider>\n                </ChatHistoryProvider>\n              </ChatStatusProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useRef,  useCallback, useMemo } from 'react';\n\n// Create chat history context\nconst ChatHistoryContext = createContext();\n\n// Hook to use chat history context\nexport const useChatHistory = () => {\n  const context = useContext(ChatHistoryContext);\n  if (context === undefined) {\n    throw new Error('useChatHistory must be used within a ChatHistoryProvider');\n  }\n  return context;\n};\n\n// Provider component for chat history\nexport const ChatHistoryProvider = ({ children }) => {\n  // State and ref for chat history, with custom setter to sync ref immediately\n  const [chatHistory, internalSetChatHistory] = useState([]);\n  const chatHistoryRef = useRef([]);\n\n  // Wrap setter to sync ref and state in one step\n  const setChatHistory = useCallback((update) => {\n    internalSetChatHistory(prev => {\n      const newHistory = typeof update === 'function' ? update(prev) : update;\n      chatHistoryRef.current = newHistory;\n      return newHistory;\n    });\n  }, []);\n\n  // Add message, stable callback\n  const addMessageToHistory = useCallback((role, content, metrics) => {\n    const timestamp = Date.now();\n    const message = { id: timestamp, role, content, timestamp, ...(metrics && { metrics }) };\n    setChatHistory(prev => [...prev, message]);\n    return message;\n  }, [setChatHistory]);\n\n  // Function to update content of the most recent assistant message (avoiding user replacements)\n  const updateChatWithContent = useCallback((content) => {\n    setChatHistory(prev => {\n      const lastIndex = prev.length - 1;\n      if (lastIndex < 0) return prev;\n      const lastMsg = prev[lastIndex];\n      // No-op if not assistant or same content\n      if (lastMsg.role !== 'assistant' || lastMsg.content === content) {\n        return prev;\n      }\n      // Otherwise clone and update\n      const newHistory = [...prev];\n      newHistory[lastIndex] = { ...lastMsg, content };\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Memoize context value to avoid re-renders\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    updateChatWithContent\n  }), [chatHistory, setChatHistory, addMessageToHistory, updateChatWithContent]);\n\n  return (\n    <ChatHistoryContext.Provider value={value}>\n      {children}\n    </ChatHistoryContext.Provider>\n  );\n}; ","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './ToastNotification.module.css';\n\n/**\n * ToastNotification component renders a list of toast messages.\n * @param {Object} props\n * @param {Array} props.toasts - Array of toast objects { id, type, message, duration }\n * @param {Function} props.dismissToast - Function to remove a toast by id\n */\nconst ToastNotification = ({ toasts, dismissToast }) => {\n  return (\n    <div className={styles.toastContainer}>\n      {toasts.map((toast) => (\n        <div key={toast.id} className={`${styles.toast} ${styles[toast.type] || ''}`}> \n          <span className={styles.message}>{toast.message}</span>\n          <button\n            type=\"button\"\n            className={styles.closeButton}\n            onClick={() => dismissToast(toast.id)}\n            aria-label=\"Close notification\"\n          >\n            ×\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nToastNotification.propTypes = {\n  toasts: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      type: PropTypes.oneOf(['error', 'success', 'info', 'warning']),\n      message: PropTypes.string.isRequired,\n      duration: PropTypes.number\n    })\n  ).isRequired,\n  dismissToast: PropTypes.func.isRequired\n};\n\nexport default ToastNotification; ","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './Spinner.module.css';\n\n/**\n * Standardized Spinner for all loading states\n * @param {Object} props\n * @param {string} props.size - One of 'small', 'medium', 'large'\n * @param {string} props.tag - Optional loading tag for context\n */\nconst Spinner = ({ size = 'medium', tag }) => {\n  const sizeClass = styles[`Spinner--${size}`] || styles['Spinner--medium'];\n  return (\n    <div className={`${styles.Spinner} ${sizeClass}`} data-loading-tag={tag} aria-label=\"Loading\" role=\"status\">\n      <div className={styles.Spinner__loader} />\n    </div>\n  );\n};\n\nSpinner.propTypes = {\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n  tag: PropTypes.string\n};\n\nexport default Spinner; ","import { useEffect, useRef } from 'react';\nimport { useLoading } from '../../../contexts/LoadingContext';\nimport { useToast } from '../../../contexts/ToastContext';\n\nconst GlobalLoadingIndicator = () => {\n  // Only show global loading overlay for authentication operations\n  const [authLoading] = useLoading('auth');\n  const isLoading = authLoading;\n  const { showToast, dismissToast } = useToast();\n  const toastIdRef = useRef(null);\n  useEffect(() => {\n    if (isLoading) {\n      // show persistent loading toast for heavy operations\n      toastIdRef.current = showToast({ type: 'info', message: 'Loading in progress...', duration: 0 });\n    } else if (toastIdRef.current) {\n      // dismiss loading toast and show completion\n      dismissToast(toastIdRef.current);\n      showToast({ type: 'success', message: 'Loading complete', duration: 2000 });\n      toastIdRef.current = null;\n    }\n    return () => {\n      if (toastIdRef.current) {\n        dismissToast(toastIdRef.current);\n        toastIdRef.current = null;\n      }\n    };\n  }, [isLoading, showToast, dismissToast]);\n\n  // No overlay spinner; toasts still handled in useEffect\n  return null;\n};\n\nexport default GlobalLoadingIndicator; ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create API context\nconst ApiContext = createContext();\n\n// Custom hook for using API context\nexport const useApi = () => {\n  const context = useContext(ApiContext);\n  if (context === undefined) {\n    throw new Error('useApi must be used within an ApiProvider');\n  }\n  return context;\n};\n\n// API provider component\nexport const ApiProvider = ({ children }) => {\n  const [apiUrl] = useState(process.env.REACT_APP_API_URL || 'http://localhost:3000/api'); // Base API URL\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    apiUrl,\n  }), [apiUrl]);\n\n  return (\n    <ApiContext.Provider value={value}>\n      {children}\n    </ApiContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo, useCallback, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { useStreamingEvents } from './StreamingEventsContext';\nimport { fetchWithRetry } from '../utils/network';\nimport { useToast } from './ToastContext';\n\n// Context for chat actions (controls)\nconst ChatControlContext = createContext();\n\n// Hook to consume chat controls\nexport const useChatControl = () => {\n  const context = useContext(ChatControlContext);\n  if (context === undefined) {\n    throw new Error('useChatControl must be used within a ChatControlProvider');\n  }\n  return context;\n};\n\n// Provider component for chat controls\nexport const ChatControlProvider = ({ children }) => {\n  // Ref to track client-generated request ID for non-streaming\n  const currentRequestIdRef = useRef(null);\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { settings, getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, setTokenMetricsForLastMessage } = usePerformanceMetrics();\n  const { streamMessageWithFetch, stopStreaming } = useStreamingEvents();\n  const { showToast } = useToast();\n\n  // Helpers\n  const formatModelIdentifier = useCallback((model) => {\n    if (!model || !model.provider || !model.id) return null;\n    return `${model.provider}/${model.id}`;\n  }, []);\n\n  // Action: sendMessage\n  const sendMessage = useCallback(async (message, editIndex = null) => {\n    // Generate unique client-side requestId\n    const clientRequestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = clientRequestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (settings.streaming) {\n      return streamMessageWithFetch(message, isEditing ? editIndex : null);\n    }\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = formatModelIdentifier(selectedModel);\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        const original = prev[editIndex];\n        // Preserve original id/timestamp, only update content\n        userMessage = { ...original, content: message };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    const requestStartTime = Date.now();\n    setIsWaitingForResponse(true);\n    setError(null);\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now()-1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = { \n        requestId: clientRequestId,\n        model: modelId, messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      resetPerformanceMetrics();\n      startPerformanceTimer();\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/completions', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        let errMsg = `API error: ${response.status}`;\n        try { const errData = await response.json(); errMsg = errData?.error?.message || errData?.message || errMsg; } catch {};\n        throw new Error(errMsg);\n      }\n      const data = await response.json();\n      console.log('Received non-streaming chat data:', data);\n\n      // Handle server-sent error in response payload\n      if (data.error?.message || data.finishReason === 'error') {\n        const errMsg = data.error?.message || 'Error occurred during generation';\n        console.error('Error in API response:', errMsg);\n        setError(errMsg);\n        const rawUsage = data.usage || {};\n        const promptTokens = rawUsage.promptTokens ?? rawUsage.prompt_tokens ?? 0;\n        const completionTokens = rawUsage.completionTokens ?? rawUsage.completion_tokens ?? 0;\n        const totalTokens = rawUsage.totalTokens ?? rawUsage.total_tokens ?? completionTokens;\n        const requestEndTime = Date.now();\n        const elapsed = requestEndTime - requestStartTime;\n        const tokensPerSecond = elapsed ? Math.round((completionTokens / (elapsed / 1000)) * 10) / 10 : null;\n        const errorMetrics = {\n          startTime: requestStartTime,\n          endTime: requestEndTime,\n          elapsedTime: elapsed,\n          tokenCount: completionTokens,\n          tokensPerSecond,\n          isComplete: true,\n          timeToFirstToken: null,\n          promptTokens,\n          completionTokens,\n          totalTokens,\n          finishReason: data.finishReason || 'error',\n          error: true\n        };\n        addMessageToHistory('assistant', errMsg, errorMetrics);\n        return null;\n      }\n      const content = data.content || 'No Response returned';\n      // Use server-provided usage tokens directly\n      const rawUsage = data.usage || {};\n      const promptTokens = rawUsage.promptTokens ?? rawUsage.prompt_tokens ?? 0;\n      const completionTokens = rawUsage.completionTokens ?? rawUsage.completion_tokens ?? 0;\n      const totalTokens = rawUsage.totalTokens ?? rawUsage.total_tokens ?? completionTokens;\n      // Compute timing and rates\n      const requestEndTime = Date.now();\n      const elapsed = requestEndTime - requestStartTime;\n      const tokensForMetrics = completionTokens > 0 ? completionTokens : 0;\n      const tokensPerSecond = elapsed\n        ? Math.round((tokensForMetrics / (elapsed / 1000)) * 10) / 10\n        : null;\n      const finalMetrics = {\n        startTime: requestStartTime,\n        endTime: requestEndTime,\n        elapsedTime: elapsed,\n        tokenCount: tokensForMetrics,\n        tokensPerSecond,\n        isComplete: true,\n        timeToFirstToken: null,\n        promptTokens,\n        completionTokens,\n        totalTokens,\n        finishReason: data.finishReason\n      };\n      addMessageToHistory('assistant', content, finalMetrics);\n      return content;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err.message);\n      // Show the server error as an assistant reply\n      addMessageToHistory('assistant', err.message || 'An error occurred');\n      return null;\n    } finally {\n      // Clear the clientRequestId after completion\n      currentRequestIdRef.current = null;\n      setIsWaitingForResponse(false);\n    }\n  }, [\n    apiUrl,\n    selectedModel,\n    settings.streaming,\n    getModelAdjustedSettings,\n    idToken,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    streamMessageWithFetch,\n    formatModelIdentifier,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    setError,\n    setIsWaitingForResponse,\n  ]);\n\n  // Action: stopGeneration\n  const stopGenerationAction = useCallback(async () => {\n    stopStreaming();\n    return true;\n  }, [stopStreaming]);\n\n  // Action: clearChat\n  const clearChat = useCallback(() => {\n    setChatHistory([]);\n    resetPerformanceMetrics();\n  }, [setChatHistory, resetPerformanceMetrics]);\n\n  // Action: newChat\n  const newChat = useCallback(() => {\n    if (chatHistoryRef.current.length > 0) {\n      clearChat();\n    }\n  }, [chatHistoryRef, clearChat]);\n\n  // Action: resetChat\n  const resetChat = useCallback(() => {\n    if (chatHistoryRef.current.length === 0) return;\n    \n    if (window.confirm('Are you sure you want to clear the current chat?')) {\n      clearChat();\n      showToast({ type: 'info', message: 'Chat has been cleared' });\n    }\n  }, [chatHistoryRef, clearChat, showToast]);\n\n  // Action: downloadChat\n  const downloadChat = useCallback(() => {\n    const history = chatHistoryRef.current;\n    if (!history.length) return;\n    try {\n      const formatted = history.map(msg => {\n        const role = msg.role === 'user'\n          ? 'You'\n          : msg.role === 'assistant'\n            ? selectedModel?.name || 'Assistant'\n            : msg.role;\n        let contentText = '';\n        if (typeof msg.content === 'string') {\n          contentText = msg.content;\n        } else if (Array.isArray(msg.content)) {\n          contentText = msg.content\n            .map(part => part.type === 'text' ? part.text : '[Image]')\n            .join('\\n');\n        }\n        return `${role}: ${contentText}\\n`;\n      }).join('');\n      const blob = new Blob([formatted], { type: 'text/plain' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `chat_${new Date().toISOString().replace(/:/g, '-')}.txt`;\n      document.body.appendChild(a);\n      a.click();\n      showToast({ type: 'success', message: 'Chat downloaded successfully' });\n      // Clean up anchor and URL\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      console.error(\"Error downloading chat:\", error);\n      showToast({ type: 'error', message: 'Failed to download chat. Please try again.' });\n    }\n  }, [chatHistoryRef, selectedModel, showToast]);\n\n  // Action: getOrCreateConversation (stub)\n  const getOrCreateConversation = useCallback((conversationId) => {\n    // implement or delegate\n  }, []);\n\n  // Value\n  const value = useMemo(() => ({\n    sendMessage,\n    stopGeneration: stopGenerationAction,\n    addMessageToHistory,\n    clearChat,\n    newChat,\n    resetChat,\n    downloadChat,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  }), [\n    sendMessage,\n    stopGenerationAction,\n    addMessageToHistory,\n    clearChat,\n    newChat,\n    resetChat,\n    downloadChat,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  ]);\n\n  return (\n    <ChatControlContext.Provider value={value}>\n      {children}\n    </ChatControlContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\n\n// Context for read-only chat state\nconst ChatStateContext = createContext();\n\n// Hook to consume chat state\nexport const useChatState = () => {\n  const context = useContext(ChatStateContext);\n  if (context === undefined) {\n    throw new Error('useChatState must be used within a ChatStateProvider');\n  }\n  return context;\n};\n\n// Provider component for chat state\nexport const ChatStateProvider = ({ children }) => {\n  const { chatHistory, chatHistoryRef } = useChatHistory();\n  const { isWaitingForResponse, error } = useChatStatus();\n\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    isWaitingForResponse,\n    error\n  }), [chatHistory, chatHistoryRef, isWaitingForResponse, error]);\n\n  return (\n    <ChatStateContext.Provider value={value}>\n      {children}\n    </ChatStateContext.Provider>\n  );\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport { useCacheToggle } from '../hooks/useCacheToggle';\nimport { useToast } from './ToastContext';\nimport { useLoading } from './LoadingContext';\n\n// Cache expiry time in milliseconds (5 days)\nconst CACHE_EXPIRY_TIME = 5 * 24 * 60 * 60 * 1000;\n\n// Create separate contexts for models and filtering\nconst ModelContext = createContext();\nconst ModelFilterContext = createContext();\n\n// Custom hook for using model context\nexport const useModel = () => {\n  const context = useContext(ModelContext);\n  if (context === undefined) {\n    throw new Error('useModel must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Custom hook for using model filter context\nexport const useModelFilter = () => {\n  const context = useContext(ModelFilterContext);\n  if (context === undefined) {\n    throw new Error('useModelFilter must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Model provider component\nexport const ModelProvider = ({ children }) => {\n  const { cacheEnabled } = useCacheToggle();\n  const { apiUrl } = useApi();\n  const { idToken } = useAuth();\n  const { showToast } = useToast();\n  \n  // State for model data\n  const [allModels, setAllModels] = useState([]);\n  const [processedModels, setProcessedModels] = useState({});\n  const [experimentalModels, setExperimentalModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useLocalStorage('selectedModel', null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Filter state - moved to separate context\n  const [showExperimental, setShowExperimental] = useLocalStorage('showExperimental', false);\n  const [modelFilter, setModelFilter] = useState({\n    search: '',\n    categories: {\n      'Chat': true,\n      'Image': true,\n      'Embedding': true\n    }\n  });\n  \n  // Sync with global loading context\n  const [, startModelsLoading, stopModelsLoading] = useLoading('models');\n  useEffect(() => {\n    if (isLoading) startModelsLoading();\n    else stopModelsLoading();\n  }, [isLoading, startModelsLoading, stopModelsLoading]);\n  \n  // Check if cache is valid\n  const isCacheValid = useCallback((cache) => {\n    return (\n      cache &&\n      cache.timestamp &&\n      Date.now() - cache.timestamp < CACHE_EXPIRY_TIME &&\n      cache.allModels &&\n      cache.processedModels &&\n      cache.experimentalModels\n    );\n  }, []);\n  \n  // Expose isCacheValid function for external access\n  useEffect(() => {\n    // Skip during server-side rendering\n    if (typeof window === 'undefined') return;\n    window.isCacheValid = isCacheValid;\n    \n    return () => {\n      delete window.isCacheValid;\n    };\n  }, [isCacheValid]);\n  \n  // Cache models to localStorage\n  const cacheModels = useCallback((data) => {\n    try {\n      const cache = {\n        allModels: data.allModels,\n        processedModels: data.processedModels,\n        experimentalModels: data.experimentalModels,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem('modelDropdownCache', JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error caching models:', error);\n    }\n  }, []);\n  \n  // Update category filter\n  const updateCategoryFilter = useCallback((category, isChecked) => {\n    setModelFilter(prev => ({\n      ...prev,\n      categories: {\n        ...prev.categories,\n        [category]: isChecked\n      }\n    }));\n  }, []);\n  \n  // Update search filter\n  const updateSearchFilter = useCallback((searchText) => {\n    setModelFilter(prev => ({\n      ...prev,\n      search: searchText\n    }));\n  }, []);\n  \n  // Select a model\n  const selectModel = useCallback((model) => {\n    // Check if the model is actually different to prevent unnecessary updates\n    if (selectedModel?.id !== model?.id) { \n      setSelectedModel(model);\n    }\n  }, [selectedModel, setSelectedModel]);\n  \n  // Fetch models from API, optionally using auth token or override token\n  const fetchModels = useCallback(async (authRequired = false, overrideToken = null) => {\n    setIsLoading(true);\n    setError(null);\n    \n    console.log(`Fetching models from API (auth: ${authRequired})...`);\n    try {\n      const headers = { 'Accept': 'application/json' };\n      if (authRequired) {\n        // Prefer overrideToken (cached) over current idToken\n        const tokenToUse = overrideToken || idToken;\n        if (tokenToUse) {\n          headers['Authorization'] = `Bearer ${tokenToUse}`;\n        }\n      }\n      const modelsUrl = new URL('/api/models/classified', apiUrl).toString();\n      const response = await fetch(modelsUrl, { headers });\n      console.log('Models response:', response);\n      \n      if (!response.ok) {\n        let errorMsg = `Error fetching models: ${response.status}`;\n        console.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n      \n      const rawData = await response.json();\n      console.log(\"[ModelContext] Spawning worker for model processing...\");\n      // Offload model processing to Web Worker\n      const worker = new Worker(new URL('../workers/modelProcessor.js', import.meta.url), { type: 'module' });\n      worker.postMessage(rawData);\n      worker.onmessage = ({ data: msg }) => {\n        if (msg.error) {\n          console.error('[ModelContext] Worker error:', msg.error);\n          setError(msg.error);\n          showToast({ type: 'error', message: msg.error });\n        } else {\n          const {\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          } = msg;\n          if (cacheEnabled) {\n            const rawPrev = localStorage.getItem('modelDropdownCache');\n            let prevCache;\n            try { prevCache = JSON.parse(rawPrev); } catch { prevCache = null; }\n            const changed = !prevCache ||\n              JSON.stringify(prevCache.allModels) !== JSON.stringify(fetchedAllModels) ||\n              JSON.stringify(prevCache.processedModels) !== JSON.stringify(fetchedProcessedModels) ||\n              JSON.stringify(prevCache.experimentalModels) !== JSON.stringify(fetchedExperimentalModels);\n            if (changed) {\n              setAllModels(fetchedAllModels);\n              setProcessedModels(fetchedProcessedModels);\n              setExperimentalModels(fetchedExperimentalModels);\n              cacheModels({ allModels: fetchedAllModels, processedModels: fetchedProcessedModels, experimentalModels: fetchedExperimentalModels });\n            }\n          } else {\n            setAllModels(fetchedAllModels);\n            setProcessedModels(fetchedProcessedModels);\n            setExperimentalModels(fetchedExperimentalModels);\n          }\n          // Initial model selection moved to a separate useEffect\n        }\n        setIsLoading(false);\n        worker.terminate();\n      };\n      worker.onerror = (err) => {\n        console.error('[ModelContext] Worker unexpected error:', err);\n        setError(err.message);\n        showToast({ type: 'error', message: err.message });\n        setIsLoading(false);\n        worker.terminate();\n      };\n    } catch (err) {\n      console.error('Failed to fetch or process models:', err);\n      setError(err.message || 'Failed to load model data');\n      showToast({ type: 'error', message: err.message || 'Failed to load model data' });\n      // Attempt to load from potentially expired cache as a last resort?\n    }\n  }, [apiUrl, cacheModels, idToken, cacheEnabled, showToast]);\n  \n  // Initial fetch once on mount\n  const initialFetchDoneRef = useRef(false);\n  // track if we've already fetched models with authentication\n  const didAuthFetchRef = useRef(false);\n\n  useEffect(() => {\n    if (!initialFetchDoneRef.current) {\n      if (cacheEnabled) {\n        const rawCache = localStorage.getItem('modelDropdownCache');\n        let parsedCache;\n        try { parsedCache = JSON.parse(rawCache); } catch { parsedCache = null; }\n        if (parsedCache && window.isCacheValid(parsedCache)) {\n          setAllModels(parsedCache.allModels);\n          setProcessedModels(parsedCache.processedModels);\n          setExperimentalModels(parsedCache.experimentalModels);\n          setIsLoading(false);\n        }\n      }\n      let cachedToken = null;\n      try { cachedToken = localStorage.getItem('idToken'); } catch {}\n      if (cachedToken) {\n        // initial authenticated fetch\n        didAuthFetchRef.current = true;\n        fetchModels(true, cachedToken);\n      } else {\n        // initial unauthenticated fetch\n        fetchModels(false);\n      }\n      initialFetchDoneRef.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // After login, fetch authenticated models\n  useEffect(() => {\n    // only fetch once after obtaining idToken if not already done\n    if (initialFetchDoneRef.current && idToken && !didAuthFetchRef.current) {\n      didAuthFetchRef.current = true;\n      fetchModels(true);\n    }\n  }, [idToken, fetchModels]);\n  \n  // Set initial model after models are loaded\n  useEffect(() => {\n    // Select first model if none selected and models are loaded\n    if (!selectedModel && allModels.length > 0) {\n      setSelectedModel(allModels[0]);\n    }\n  }, [allModels, selectedModel, setSelectedModel]);\n  \n  // Create toggleExperimentalModels callback at the top level\n  const toggleExperimentalModels = useCallback(() => {\n    setShowExperimental(prev => !prev);\n  }, [setShowExperimental]);\n  \n  // Main model context value - no filter state\n  const modelValue = useMemo(() => ({\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    isExperimentalModelsEnabled: showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    refreshModels: fetchModels\n  }), [\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    fetchModels\n  ]);\n  \n  // Filter context value - only filter-related state\n  const filterValue = useMemo(() => ({\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  }), [\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  ]);\n  \n  return (\n    <ModelContext.Provider value={modelValue}>\n      <ModelFilterContext.Provider value={filterValue}>\n        {children}\n      </ModelFilterContext.Provider>\n    </ModelContext.Provider>\n  );\n}; "],"names":["AuthContext","createContext","useAuth","context","useContext","undefined","Error","AuthProvider","_ref","children","currentUser","setCurrentUser","useState","idToken","setIdToken","loading","setLoading","startAuthLoading","stopAuthLoading","useLoading","error","setError","isLoggingIn","setIsLoggingIn","isFirebaseInitialized","setIsFirebaseInitialized","showToast","useToast","useEffect","login","useCallback","async","logout","getFirebaseAuth","signOut","firebaseSignOut","auth","msg","type","message","err","unsubscribe","handleFirebaseInit","initializeAuthListener","onAuthStateChanged","firebaseOnAuthStateChanged","user","token","getIdToken","localStorage","setItem","e","removeItem","window","addEventListener","removeEventListener","value","useMemo","isAuthenticated","_jsx","Provider","ChatStatusContext","useChatStatus","ChatStatusProvider","isWaitingForResponse","setIsWaitingForResponse","startChatLoading","stopChatLoading","LoadingContext","LoadingProvider","loadingMap","setLoadingMap","tag","isLoading","prev","anyLoading","Object","values","some","val","startLoading","stopLoading","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ThemeProvider","ApiProvider","ModelProvider","SettingsProvider","ChatHistoryProvider","PerformanceMetricsProvider","StreamingEventsProvider","ChatStateProvider","ChatControlProvider","ChatHistoryContext","useChatHistory","chatHistory","internalSetChatHistory","chatHistoryRef","useRef","setChatHistory","update","newHistory","current","addMessageToHistory","role","content","metrics","timestamp","Date","now","id","updateChatWithContent","lastIndex","length","lastMsg","toasts","dismissToast","className","styles","toastContainer","map","toast","_jsxs","closeButton","onClick","size","sizeClass","Spinner","Spinner__loader","GlobalLoadingIndicator","authLoading","toastIdRef","duration","ApiContext","useApi","apiUrl","process","ChatControlContext","useChatControl","currentRequestIdRef","selectedModel","useModel","settings","getModelAdjustedSettings","useSettings","resetPerformanceMetrics","startPerformanceTimer","setTokenMetricsForLastMessage","usePerformanceMetrics","streamMessageWithFetch","stopStreaming","useStreamingEvents","formatModelIdentifier","model","provider","sendMessage","editIndex","arguments","clientRequestId","crypto","randomUUID","Math","random","toString","substring","isEditing","Number","isInteger","streaming","modelId","userMessage","truncated","slice","original","requestStartTime","_data$error","_ref6","_rawUsage$promptToken2","_ref7","_rawUsage$completionT2","_ref8","_rawUsage$totalTokens2","adjusted","historyForApi","_ref2","m","systemPrompt","unshift","push","payload","requestId","messages","temperature","max_tokens","top_p","frequency_penalty","presence_penalty","headers","response","fetchWithRetry","URL","method","body","JSON","stringify","ok","errMsg","status","_errData$error","errData","json","data","finishReason","_data$error2","_ref3","_rawUsage$promptToken","_ref4","_rawUsage$completionT","_ref5","_rawUsage$totalTokens","rawUsage","usage","promptTokens","prompt_tokens","completionTokens","completion_tokens","totalTokens","total_tokens","requestEndTime","elapsed","errorMetrics","startTime","endTime","elapsedTime","tokenCount","tokensPerSecond","round","isComplete","timeToFirstToken","tokensForMetrics","finalMetrics","stopGenerationAction","clearChat","newChat","resetChat","confirm","downloadChat","history","formatted","name","contentText","Array","isArray","part","text","join","blob","Blob","url","createObjectURL","a","document","createElement","href","download","toISOString","replace","appendChild","click","removeChild","revokeObjectURL","getOrCreateConversation","conversationId","stopGeneration","ChatStateContext","useChatState","ModelContext","ModelFilterContext","useModelFilter","cacheEnabled","useCacheToggle","allModels","setAllModels","processedModels","setProcessedModels","experimentalModels","setExperimentalModels","setSelectedModel","useLocalStorage","setIsLoading","showExperimental","setShowExperimental","modelFilter","setModelFilter","search","categories","startModelsLoading","stopModelsLoading","isCacheValid","cache","cacheModels","updateCategoryFilter","category","isChecked","updateSearchFilter","searchText","selectModel","fetchModels","authRequired","overrideToken","tokenToUse","modelsUrl","fetch","errorMsg","rawData","worker","Worker","postMessage","onmessage","fetchedAllModels","fetchedProcessedModels","fetchedExperimentalModels","rawPrev","getItem","prevCache","parse","terminate","onerror","initialFetchDoneRef","didAuthFetchRef","rawCache","parsedCache","cachedToken","toggleExperimentalModels","modelValue","isExperimentalModelsEnabled","refreshModels","filterValue"],"sourceRoot":""}
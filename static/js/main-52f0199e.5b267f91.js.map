{"version":3,"file":"static/js/main-52f0199e.5b267f91.js","mappings":"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","sources":["contexts/AuthContext.js","contexts/ChatStatusContext.js","contexts/ContextManager.js","contexts/ChatHistoryContext.js","components/common/Spinner/index.js","contexts/ApiContext.js","contexts/ChatControlContext.js","contexts/ChatStateContext.js"],"sourcesContent":["import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n// Firebase is dynamically imported to avoid blocking\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [idToken, setIdToken] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially - we're proceeding anonymously\n  const [error, setError] = useState(null);\n  const [isLoggingIn, setIsLoggingIn] = useState(false); // State to trigger login UI\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\n\n  const login = useCallback(async () => {\n    console.log(\"Login button clicked, setting isLoggingIn to true.\");\n    setIsLoggingIn(true);\n  }, [setIsLoggingIn]);\n\n  const logout = useCallback(async () => {\n    if (!isFirebaseInitialized) {\n      console.log(\"Firebase not initialized yet, cannot logout.\");\n      return;\n    }\n    const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n    const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n    const auth = getFirebaseAuth();\n    if (!auth) {\n      setError(\"Firebase not initialized.\");\n      return;\n    }\n    try {\n      await firebaseSignOut(auth);\n      console.log(\"Sign out successful.\");\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      setError(err.message || 'Failed to logout.');\n    }\n  }, [isFirebaseInitialized, setError]);\n\n  // Effect to listen for Firebase auth state changes\n  useEffect(() => {\n    let unsubscribe = null;\n\n    // Listen for the 'firebaseInitialized' event from App.js\n    const handleFirebaseInit = () => {\n      console.log(\"Received Firebase initialized event\");\n      setIsFirebaseInitialized(true);\n      initializeAuthListener();\n    };\n\n    // Function to initialize auth listener\n    const initializeAuthListener = async () => {\n      setLoading(true);\n      // Dynamically import Firebase auth\n      const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n      const { onAuthStateChanged: firebaseOnAuthStateChanged } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n      \n      const auth = getFirebaseAuth();\n      if (!auth) {\n        console.warn(\"Auth service not available for onAuthStateChanged listener.\");\n        setLoading(false);\n        return;\n      }\n      \n      console.log(\"Setting up Firebase onAuthStateChanged listener.\");\n      unsubscribe = firebaseOnAuthStateChanged(auth, async (user) => {\n        setCurrentUser(user);\n        if (user) {\n          try {\n            // Force refresh is false by default, gets cached token if available\n            const token = await user.getIdToken();\n            setIdToken(token);\n            try { localStorage.setItem('idToken', token); } catch (e) { console.warn('Failed to cache idToken', e); }\n            setError(null); // Clear previous errors on successful login\n            setIsLoggingIn(false); // Ensure login UI closes if open\n            console.log(\"User signed in, token obtained.\");\n          } catch (err) {\n            console.error(\"Failed to get ID token:\", err);\n            setError(\"Failed to get authentication token.\");\n            setIdToken(null);\n            // Optionally sign out the user if token fetch fails critically\n            const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n            await firebaseSignOut(auth);\n          }\n        } else {\n          // User is signed out\n          setIdToken(null);\n          try { localStorage.removeItem('idToken'); } catch (e) { console.warn('Failed to remove cached idToken', e); }\n          setIsLoggingIn(false); // Ensure login UI closes if open\n          console.log(\"User signed out.\");\n        }\n        setLoading(false); // Auth state determined\n      });\n    };\n\n    // Define a custom event for Firebase initialization\n    window.addEventListener('firebaseInitialized', handleFirebaseInit);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('firebaseInitialized', handleFirebaseInit);\n      if (typeof unsubscribe === 'function') {\n      console.log(\"Cleaning up Firebase onAuthStateChanged listener.\");\n        unsubscribe();\n      }\n    };\n  }, []);\n\n  const value = useMemo(() => ({\n    currentUser,\n    idToken,\n    loading,\n    error,\n    login,\n    logout,\n    isAuthenticated: !!currentUser && !!idToken,\n    isLoggingIn,\n    setIsLoggingIn,\n    isFirebaseInitialized\n  }), [currentUser, idToken, loading, error, login, logout, isLoggingIn, setIsLoggingIn, isFirebaseInitialized]);\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}; ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create chat status context\nconst ChatStatusContext = createContext();\n\n// Hook to use chat status context\nexport const useChatStatus = () => {\n  const context = useContext(ChatStatusContext);\n  if (context === undefined) {\n    throw new Error('useChatStatus must be used within a ChatStatusProvider');\n  }\n  return context;\n};\n\n// Provider component for chat status\nexport const ChatStatusProvider = ({ children }) => {\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\n  const [error, setError] = useState(null);\n\n  const value = useMemo(() => ({\n    isWaitingForResponse,\n    setIsWaitingForResponse,\n    error,\n    setError,\n  }), [isWaitingForResponse, error]);\n\n  return (\n    <ChatStatusContext.Provider value={value}>\n      {children}\n    </ChatStatusContext.Provider>\n  );\n}; ","import { createContext, useContext, useMemo, useEffect } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatStatusProvider } from './ChatStatusContext';\nimport { ChatHistoryProvider } from './ChatHistoryContext';\nimport { PerformanceMetricsProvider } from './PerformanceMetricsContext';\nimport { StreamingEventsProvider } from './StreamingEventsContext';\nimport { ChatStateProvider } from './ChatStateContext';\nimport { ChatControlProvider } from './ChatControlContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n  // Mark as initialized once on mount\n  useEffect(() => {\n    initializationState.setInitialized(true);\n  }, [initializationState]);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatStatusProvider>\n                <ChatHistoryProvider>\n                  <PerformanceMetricsProvider>\n                    <StreamingEventsProvider>\n                      <ChatStateProvider>\n                        <ChatControlProvider>\n                          {children}\n                        </ChatControlProvider>\n                      </ChatStateProvider>\n                    </StreamingEventsProvider>\n                  </PerformanceMetricsProvider>\n                </ChatHistoryProvider>\n              </ChatStatusProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useRef,  useCallback, useMemo } from 'react';\n\n// Create chat history context\nconst ChatHistoryContext = createContext();\n\n// Hook to use chat history context\nexport const useChatHistory = () => {\n  const context = useContext(ChatHistoryContext);\n  if (context === undefined) {\n    throw new Error('useChatHistory must be used within a ChatHistoryProvider');\n  }\n  return context;\n};\n\n// Provider component for chat history\nexport const ChatHistoryProvider = ({ children }) => {\n  // State and ref for chat history, with custom setter to sync ref immediately\n  const [chatHistory, internalSetChatHistory] = useState([]);\n  const chatHistoryRef = useRef([]);\n\n  // Wrap setter to sync ref and state in one step\n  const setChatHistory = useCallback((update) => {\n    internalSetChatHistory(prev => {\n      const newHistory = typeof update === 'function' ? update(prev) : update;\n      chatHistoryRef.current = newHistory;\n      return newHistory;\n    });\n  }, []);\n\n  // Add message, stable callback\n  const addMessageToHistory = useCallback((role, content, metrics) => {\n    const message = { role, content, timestamp: Date.now(), ...(metrics && { metrics }) };\n    setChatHistory(prev => [...prev, message]);\n    return message;\n  }, [setChatHistory]);\n\n  // Function to update content of the most recent assistant message (avoiding user replacements)\n  const updateChatWithContent = useCallback((content) => {\n    setChatHistory(prev => {\n      const lastIndex = prev.length - 1;\n      if (lastIndex < 0) return prev;\n      const lastMsg = prev[lastIndex];\n      // No-op if not assistant or same content\n      if (lastMsg.role !== 'assistant' || lastMsg.content === content) {\n        return prev;\n      }\n      // Otherwise clone and update\n      const newHistory = [...prev];\n      newHistory[lastIndex] = { ...lastMsg, content };\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Memoize context value to avoid re-renders\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    updateChatWithContent\n  }), [chatHistory, setChatHistory, addMessageToHistory, updateChatWithContent]);\n\n  return (\n    <ChatHistoryContext.Provider value={value}>\n      {children}\n    </ChatHistoryContext.Provider>\n  );\n}; ","import React from 'react';\nimport styles from './Spinner.module.css';\n\n/**\n * Loading spinner component with multiple sizes\n * @param {Object} props - Component props\n * @param {string} [props.size='medium'] - Size of spinner (small, medium, large)\n * @param {string} [props.color] - Optional custom color\n * @returns {JSX.Element} - Rendered spinner\n */\nconst Spinner = ({ size = 'medium', color }) => {\n  const sizeClass = styles[size] || styles.medium;\n  \n  const spinnerStyle = color ? { borderTopColor: color } : {};\n  \n  return (\n    <div className={`${styles.spinnerContainer} ${sizeClass}`}>\n      <div \n        className={styles.spinner} \n        style={spinnerStyle}\n        aria-label=\"Loading\"\n        role=\"status\"\n      />\n    </div>\n  );\n};\n\n// Wrap with React.memo to prevent unnecessary re-renders\nexport default React.memo(Spinner); ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create API context\nconst ApiContext = createContext();\n\n// Custom hook for using API context\nexport const useApi = () => {\n  const context = useContext(ApiContext);\n  if (context === undefined) {\n    throw new Error('useApi must be used within an ApiProvider');\n  }\n  return context;\n};\n\n// API provider component\nexport const ApiProvider = ({ children }) => {\n  const [apiUrl] = useState(process.env.REACT_APP_API_URL || 'http://localhost:3000/api'); // Base API URL\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    apiUrl,\n  }), [apiUrl]);\n\n  return (\n    <ApiContext.Provider value={value}>\n      {children}\n    </ApiContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo, useCallback, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { useStreamingEvents } from './StreamingEventsContext';\nimport { fetchWithRetry } from '../utils/network';\n\n// Context for chat actions (controls)\nconst ChatControlContext = createContext();\n\n// Hook to consume chat controls\nexport const useChatControl = () => {\n  const context = useContext(ChatControlContext);\n  if (context === undefined) {\n    throw new Error('useChatControl must be used within a ChatControlProvider');\n  }\n  return context;\n};\n\n// Provider component for chat controls\nexport const ChatControlProvider = ({ children }) => {\n  // Ref to track client-generated request ID for non-streaming\n  const currentRequestIdRef = useRef(null);\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { settings, getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, setTokenMetricsForLastMessage } = usePerformanceMetrics();\n  const { streamMessageWithFetch, stopStreaming } = useStreamingEvents();\n\n  // Helpers\n  const formatModelIdentifier = useCallback((model) => {\n    if (!model || !model.provider || !model.id) return null;\n    return `${model.provider}/${model.id}`;\n  }, []);\n\n  // Action: sendMessage\n  const sendMessage = useCallback(async (message, editIndex = null) => {\n    // Generate unique client-side requestId\n    const clientRequestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = clientRequestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (settings.streaming) {\n      return streamMessageWithFetch(message, isEditing ? editIndex : null);\n    }\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = formatModelIdentifier(selectedModel);\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        userMessage = { role: 'user', content: message, timestamp: Date.now() };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    const requestStartTime = Date.now();\n    setIsWaitingForResponse(true);\n    setError(null);\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now()-1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = { \n        requestId: clientRequestId,\n        model: modelId, messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      resetPerformanceMetrics();\n      startPerformanceTimer();\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/completions', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        let errMsg = `API error: ${response.status}`;\n        try { const errData = await response.json(); errMsg = errData?.error?.message || errData?.message || errMsg; } catch {};\n        throw new Error(errMsg);\n      }\n      const data = await response.json();\n      console.log('Received non-streaming chat data:', data);\n\n      const content = data.content || 'No Response returned';\n      // Use server-provided usage tokens directly\n      const rawUsage = data.usage || {};\n      const promptTokens = rawUsage.promptTokens ?? rawUsage.prompt_tokens ?? 0;\n      const completionTokens = rawUsage.completionTokens ?? rawUsage.completion_tokens ?? 0;\n      const totalTokens = rawUsage.totalTokens ?? rawUsage.total_tokens ?? completionTokens;\n      // Compute timing and rates\n      const requestEndTime = Date.now();\n      const elapsed = requestEndTime - requestStartTime;\n      const tokensForMetrics = completionTokens > 0 ? completionTokens : 0;\n      const tokensPerSecond = elapsed\n        ? Math.round((tokensForMetrics / (elapsed / 1000)) * 10) / 10\n        : null;\n      const finalMetrics = {\n        startTime: requestStartTime,\n        endTime: requestEndTime,\n        elapsedTime: elapsed,\n        tokenCount: tokensForMetrics,\n        tokensPerSecond,\n        isComplete: true,\n        timeToFirstToken: null,\n        promptTokens,\n        completionTokens,\n        totalTokens,\n        finishReason: data.finishReason\n      };\n      addMessageToHistory('assistant', content, finalMetrics);\n      return content;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err.message);\n      addMessageToHistory('error', err.message || 'An error occurred');\n      return null;\n    } finally {\n      // Clear the clientRequestId after completion\n      currentRequestIdRef.current = null;\n      setIsWaitingForResponse(false);\n    }\n  }, [\n    apiUrl,\n    selectedModel,\n    settings.streaming,\n    getModelAdjustedSettings,\n    idToken,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    streamMessageWithFetch,\n    formatModelIdentifier,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    setError,\n    setIsWaitingForResponse,\n  ]);\n\n  // Action: stopGeneration\n  const stopGenerationAction = useCallback(async () => {\n    stopStreaming();\n    return true;\n  }, [stopStreaming]);\n\n  // Action: clearChat\n  const clearChatAction = useCallback(() => {\n    setChatHistory([]);\n    resetPerformanceMetrics();\n  }, [setChatHistory, resetPerformanceMetrics]);\n\n  // Action: downloadChatHistory\n  const downloadChatHistoryAction = useCallback(() => {\n    const history = chatHistoryRef.current;\n    if (!history.length) return;\n    const formatted = history.map(msg => {\n      const role = msg.role === 'user'\n        ? 'You'\n        : msg.role === 'assistant'\n          ? selectedModel?.name || 'Assistant'\n          : msg.role;\n      const content = typeof msg.content === 'string' ? msg.content : '';\n      return `${role}: ${content}\\n`;\n    }).join('');\n    const blob = new Blob([formatted], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `chat_${new Date().toISOString()}.txt`;\n    document.body.appendChild(a);\n    a.click();\n    setTimeout(() => {\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }, 100);\n  }, [selectedModel]);\n\n  // Action: getOrCreateConversation (stub)\n  const getOrCreateConversation = useCallback((conversationId) => {\n    // implement or delegate\n  }, []);\n\n  // Value\n  const value = useMemo(() => ({\n    sendMessage,\n    stopGeneration: stopGenerationAction,\n    addMessageToHistory,\n    clearChat: clearChatAction,\n    downloadChatHistory: downloadChatHistoryAction,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  }), [\n    sendMessage,\n    stopGenerationAction,\n    addMessageToHistory,\n    clearChatAction,\n    downloadChatHistoryAction,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  ]);\n\n  return (\n    <ChatControlContext.Provider value={value}>\n      {children}\n    </ChatControlContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\n\n// Context for read-only chat state\nconst ChatStateContext = createContext();\n\n// Hook to consume chat state\nexport const useChatState = () => {\n  const context = useContext(ChatStateContext);\n  if (context === undefined) {\n    throw new Error('useChatState must be used within a ChatStateProvider');\n  }\n  return context;\n};\n\n// Provider component for chat state\nexport const ChatStateProvider = ({ children }) => {\n  const { chatHistory, chatHistoryRef } = useChatHistory();\n  const { isWaitingForResponse, error } = useChatStatus();\n\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    isWaitingForResponse,\n    error\n  }), [chatHistory, isWaitingForResponse, error]);\n\n  return (\n    <ChatStateContext.Provider value={value}>\n      {children}\n    </ChatStateContext.Provider>\n  );\n}; "],"names":["AuthContext","createContext","useAuth","context","useContext","undefined","Error","AuthProvider","_ref","children","currentUser","setCurrentUser","useState","idToken","setIdToken","loading","setLoading","error","setError","isLoggingIn","setIsLoggingIn","isFirebaseInitialized","setIsFirebaseInitialized","login","useCallback","async","logout","getFirebaseAuth","signOut","firebaseSignOut","auth","err","message","useEffect","unsubscribe","handleFirebaseInit","initializeAuthListener","onAuthStateChanged","firebaseOnAuthStateChanged","user","token","getIdToken","localStorage","setItem","e","removeItem","window","addEventListener","removeEventListener","value","useMemo","isAuthenticated","_jsx","Provider","ChatStatusContext","useChatStatus","ChatStatusProvider","isWaitingForResponse","setIsWaitingForResponse","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ThemeProvider","ApiProvider","ModelProvider","SettingsProvider","ChatHistoryProvider","PerformanceMetricsProvider","StreamingEventsProvider","ChatStateProvider","ChatControlProvider","ChatHistoryContext","useChatHistory","chatHistory","internalSetChatHistory","chatHistoryRef","useRef","setChatHistory","update","prev","newHistory","current","addMessageToHistory","role","content","metrics","timestamp","Date","now","updateChatWithContent","lastIndex","length","lastMsg","Spinner","size","color","sizeClass","styles","medium","spinnerStyle","borderTopColor","className","spinnerContainer","spinner","style","React","ApiContext","useApi","apiUrl","process","ChatControlContext","useChatControl","currentRequestIdRef","selectedModel","useModel","settings","getModelAdjustedSettings","useSettings","resetPerformanceMetrics","startPerformanceTimer","setTokenMetricsForLastMessage","usePerformanceMetrics","streamMessageWithFetch","stopStreaming","useStreamingEvents","formatModelIdentifier","model","provider","id","sendMessage","editIndex","arguments","clientRequestId","crypto","randomUUID","Math","random","toString","substring","isEditing","Number","isInteger","streaming","modelId","userMessage","truncated","slice","requestStartTime","_ref3","_rawUsage$promptToken","_ref4","_rawUsage$completionT","_ref5","_rawUsage$totalTokens","adjusted","historyForApi","map","_ref2","m","systemPrompt","unshift","push","payload","requestId","messages","temperature","max_tokens","top_p","frequency_penalty","presence_penalty","headers","response","fetchWithRetry","URL","method","body","JSON","stringify","ok","errMsg","status","_errData$error","errData","json","data","rawUsage","usage","promptTokens","prompt_tokens","completionTokens","completion_tokens","totalTokens","total_tokens","requestEndTime","elapsed","tokensForMetrics","finalMetrics","startTime","endTime","elapsedTime","tokenCount","tokensPerSecond","round","isComplete","timeToFirstToken","finishReason","stopGenerationAction","clearChatAction","downloadChatHistoryAction","history","formatted","msg","name","join","blob","Blob","type","url","createObjectURL","a","document","createElement","href","download","toISOString","appendChild","click","setTimeout","removeChild","revokeObjectURL","getOrCreateConversation","conversationId","stopGeneration","clearChat","downloadChatHistory","ChatStateContext","useChatState"],"sourceRoot":""}
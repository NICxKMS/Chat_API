{"version":3,"file":"static/js/main-52f0199e.bcf1a239.js","mappings":"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","sources":["contexts/ThemeContext.js","contexts/PerformanceMetricsContext.js","contexts/SettingsContext.js","contexts/AuthContext.js","contexts/ChatStatusContext.js","contexts/LoadingContext.js","contexts/ContextManager.js","contexts/ChatHistoryContext.js","contexts/StreamingEventsContext.js","components/common/Spinner/index.js","components/common/GlobalLoadingIndicator/index.js","contexts/ApiContext.js","contexts/ChatControlContext.js","contexts/ChatStateContext.js","components/common/ToastNotification/index.js","contexts/ToastContext.js","contexts/ModelContext.js"],"sourcesContent":["import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n\n// Create theme context\nconst ThemeContext = createContext();\n\n// Custom hook for using theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n\n// Theme provider component\nexport const ThemeProvider = ({ children }) => {\n  // Initialize theme from localStorage or default to 'dark'\n  const [theme, setTheme] = useState(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return savedTheme || 'dark';\n  });\n\n  // Toggle between light and dark themes\n  const toggleTheme = useCallback(() => {\n    setTheme(prevTheme => {\n      const newTheme = prevTheme === 'dark' ? 'light' : 'dark';\n      localStorage.setItem('theme', newTheme);\n      return newTheme;\n    });\n  }, []);\n\n  // Apply theme class to body element\n  useEffect(() => {\n    document.body.classList.remove('light-mode', 'dark-mode');\n    document.body.classList.add(`${theme}-mode`);\n  }, [theme]);\n\n  // Context value - memoized to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme, toggleTheme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useCallback, useMemo, useEffect } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\n\n// Create performance metrics context\nconst PerformanceMetricsContext = createContext();\n\n// Hook to use performance metrics context\nexport const usePerformanceMetrics = () => {\n  const context = useContext(PerformanceMetricsContext);\n  if (context === undefined) {\n    throw new Error('usePerformanceMetrics must be used within a PerformanceMetricsProvider');\n  }\n  return context;\n};\n\n// Provider component for performance metrics\nexport const PerformanceMetricsProvider = ({ children }) => {\n  const { setChatHistory } = useChatHistory();\n  const [currentMessageMetrics, setCurrentMessageMetrics] = useState({\n    startTime: null,\n    endTime: null,\n    elapsedTime: null,\n    tokenCount: null,\n    tokensPerSecond: null,\n    isComplete: false,\n    timeToFirstToken: null,\n    promptTokens: null,\n    completionTokens: null,\n    totalTokens: null,\n    finishReason: null\n  });\n\n  const resetPerformanceMetrics = useCallback(() => {\n    setCurrentMessageMetrics({\n      startTime: null,\n      endTime: null,\n      elapsedTime: null,\n      tokenCount: null,\n      tokensPerSecond: null,\n      isComplete: false,\n      timeToFirstToken: null,\n      promptTokens: null,\n      completionTokens: null,\n      totalTokens: null,\n      finishReason: null\n    });\n  }, []);\n\n  const startPerformanceTimer = useCallback(() => {\n    setCurrentMessageMetrics(prev => ({\n      ...prev,\n      startTime: Date.now(),\n      isComplete: false\n    }));\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const updatePerformanceMetrics = useCallback((newTokenCount, isComplete = false, tokenInfo = null, finishReason = null) => {\n    setCurrentMessageMetrics(prev => {\n      const endTime = Date.now();\n      const elapsedTime = prev.startTime ? endTime - prev.startTime : 0;\n      const tokensPerSecond = newTokenCount && elapsedTime ?\n        Math.round((newTokenCount / (elapsedTime / 1000)) * 10) / 10 :\n        prev.tokensPerSecond;\n      const timeToFirstToken = prev.timeToFirstToken ||\n        (newTokenCount > 0 ? elapsedTime : null);\n\n      const newMetrics = {\n        startTime: prev.startTime,\n        endTime,\n        elapsedTime,\n        tokenCount: newTokenCount,\n        tokensPerSecond,\n        isComplete,\n        timeToFirstToken,\n        promptTokens: tokenInfo?.promptTokens || prev.promptTokens,\n        completionTokens: tokenInfo?.completionTokens || prev.completionTokens,\n        totalTokens: tokenInfo?.totalTokens || prev.totalTokens,\n        finishReason: finishReason || prev.finishReason\n      };\n\n      return newMetrics;\n    });\n  }, []);\n\n  // Sync performance metrics into chat history after a metrics update\n  useEffect(() => {\n    if (currentMessageMetrics.endTime != null) {\n      setChatHistory(prevHistory => {\n        const newHistory = [...prevHistory];\n        const lastMsg = newHistory[newHistory.length - 1];\n        if (lastMsg && lastMsg.role === 'assistant') {\n          lastMsg.metrics = { ...currentMessageMetrics };\n        }\n        return newHistory;\n      });\n    }\n  }, [currentMessageMetrics, setChatHistory]);\n\n  // Direct function to set token metrics for the last message - for debugging/testing\n  const setTokenMetricsForLastMessage = useCallback((metrics) => {\n    setChatHistory(prevHistory => {\n      const newHistory = [...prevHistory];\n      const lastMsg = newHistory[newHistory.length - 1];\n      if (lastMsg && lastMsg.role === 'assistant') {\n        lastMsg.metrics = {\n          ...(lastMsg.metrics || {}),\n          ...metrics,\n          isComplete: true\n        };\n      }\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  const value = useMemo(() => ({\n    currentMessageMetrics,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    updatePerformanceMetrics,\n    setTokenMetricsForLastMessage\n  }), [currentMessageMetrics, resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics, setTokenMetricsForLastMessage]);\n\n  return (\n    <PerformanceMetricsContext.Provider value={value}>\n      {children}\n    </PerformanceMetricsContext.Provider>\n  );\n}; ","import { createContext, useContext, useCallback, useMemo } from 'react';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\n\n// Default settings values\nconst DEFAULT_SETTINGS = {\n  temperature: 0.7,\n  top_p: 1.0,\n  max_tokens: 8191,\n  frequency_penalty: 0,\n  presence_penalty: 0,\n  streaming: true,\n  systemPrompt: \"You are ChatGPT, a helpful and knowledgeable AI assistant. Your primary role is to assist Nikhil, a university engineering student, by providing clear, concise, and technically accurate information. Adopt a friendly and approachable tone, akin to a knowledgeable peer or mentor. Enhance your responses with relevant emojis to convey tone and emotion, making interactions more engaging. Structure your answers logically, using bullet points or numbered lists where appropriate to enhance clarity. When applicable, incorporate interactive elements such as code snippets or diagrams to facilitate deeper understanding. Encourage curiosity by suggesting related topics or questions that Nikhil might explore further. Always tailor your assistance to support Nikhil's academic and personal growth in the field of engineering\"\n};\n\n// Create settings context\nconst SettingsContext = createContext();\n\n// Custom hook for using settings\nexport const useSettings = () => {\n  const context = useContext(SettingsContext);\n  if (context === undefined) {\n    throw new Error('useSettings must be used within a SettingsProvider');\n  }\n  return context;\n};\n\n// Settings provider component\nexport const SettingsProvider = ({ children }) => {\n  // Initialize settings state with defaults, persisted to localStorage\n  const [settings, setSettings] = useLocalStorage('appSettings', DEFAULT_SETTINGS);\n  \n  // Handle individual setting updates\n  const updateSetting = useCallback((key, value) => {\n    // Ensure the key is a valid setting we manage\n    if (key in DEFAULT_SETTINGS) {\n      // console.log(`[SettingsContext] Updating '${key}' from ${settings[key]} to ${value}`);\n      setSettings(prev => ({\n        ...prev,\n        [key]: value\n      }));\n    }\n  }, [setSettings]);\n  \n  // Reset settings to defaults\n  const resetSettings = useCallback(() => {\n    // console.log(\"[SettingsContext] Resetting settings to default\");\n    setSettings(DEFAULT_SETTINGS);\n  }, [setSettings]);\n  \n  // Check if temperature should be restricted based on model name/series\n  const shouldRestrictTemperature = useCallback((model) => {\n    if (!model) return false;\n    \n    // More explicit flag checking for temperature restriction\n    // Check for specific model properties that indicate temperature restriction\n    return (\n      model.requiresFixedTemperature === true || \n      (model.properties && model.properties.includes('fixed_temperature')) ||\n      (model.id && model.id.toLowerCase().startsWith('o')) ||\n      (model.series && model.series.toLowerCase() === 'o-series')\n    );\n  }, []);\n  \n  // Get current settings with potential model-specific overrides\n  const getModelAdjustedSettings = useCallback((model) => {\n    if (shouldRestrictTemperature(model)) {\n      return {\n        ...settings,\n        temperature: 1.0\n      };\n    }\n    return settings;\n  }, [settings, shouldRestrictTemperature]);\n  \n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings\n  }), [\n    settings,\n    updateSetting, \n    resetSettings, \n    shouldRestrictTemperature, \n    getModelAdjustedSettings\n  ]);\n  \n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\nimport { useToast } from './ToastContext';\nimport { useLoading } from './LoadingContext';\n// Firebase is dynamically imported to avoid blocking\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [idToken, setIdToken] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially - we're proceeding anonymously\n  // Sync with global loading context for auth\n  const [, startAuthLoading, stopAuthLoading] = useLoading('auth');\n  const [error, setError] = useState(null);\n  const [isLoggingIn, setIsLoggingIn] = useState(false); // State to trigger login UI\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\n  const { showToast } = useToast();\n\n  useEffect(() => {\n    if (loading) startAuthLoading(); else stopAuthLoading();\n  }, [loading, startAuthLoading, stopAuthLoading]);\n\n  const login = useCallback(async () => {\n    console.log(\"Login button clicked, setting isLoggingIn to true.\");\n    setIsLoggingIn(true);\n  }, [setIsLoggingIn]);\n\n  const logout = useCallback(async () => {\n    if (!isFirebaseInitialized) {\n      console.log(\"Firebase not initialized yet, cannot logout.\");\n      return;\n    }\n    const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n    const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n    const auth = getFirebaseAuth();\n    if (!auth) {\n      const msg = \"Firebase not initialized.\";\n      setError(msg);\n      showToast({ type: 'error', message: msg });\n      return;\n    }\n    try {\n      await firebaseSignOut(auth);\n      console.log(\"Sign out successful.\");\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      const msg = err.message || 'Failed to logout.';\n      setError(msg);\n      showToast({ type: 'error', message: msg });\n    }\n  }, [isFirebaseInitialized, setError]);\n\n  // Effect to listen for Firebase auth state changes\n  useEffect(() => {\n    let unsubscribe = null;\n\n    // Listen for the 'firebaseInitialized' event from App.js\n    const handleFirebaseInit = () => {\n      console.log(\"Received Firebase initialized event\");\n      setIsFirebaseInitialized(true);\n      initializeAuthListener();\n    };\n\n    // Function to initialize auth listener\n    const initializeAuthListener = async () => {\n      setLoading(true);\n      // Dynamically import Firebase auth\n      const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n      const { onAuthStateChanged: firebaseOnAuthStateChanged } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n      \n      const auth = getFirebaseAuth();\n      if (!auth) {\n        console.warn(\"Auth service not available for onAuthStateChanged listener.\");\n        setLoading(false);\n        return;\n      }\n      \n      console.log(\"Setting up Firebase onAuthStateChanged listener.\");\n      unsubscribe = firebaseOnAuthStateChanged(auth, async (user) => {\n        setCurrentUser(user);\n        if (user) {\n          try {\n            // Force refresh is false by default, gets cached token if available\n            const token = await user.getIdToken();\n            setIdToken(token);\n            try { localStorage.setItem('idToken', token); } catch (e) { console.warn('Failed to cache idToken', e); }\n            setError(null); // Clear previous errors on successful login\n            setIsLoggingIn(false); // Ensure login UI closes if open\n            console.log(\"User signed in, token obtained.\");\n          } catch (err) {\n            console.error(\"Failed to get ID token:\", err);\n            const msg = \"Failed to get authentication token.\";\n            setError(msg);\n            showToast({ type: 'error', message: msg });\n            setIdToken(null);\n            // Optionally sign out the user if token fetch fails critically\n            const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n            await firebaseSignOut(auth);\n          }\n        } else {\n          // User is signed out\n          setIdToken(null);\n          try { localStorage.removeItem('idToken'); } catch (e) { console.warn('Failed to remove cached idToken', e); }\n          setIsLoggingIn(false); // Ensure login UI closes if open\n          console.log(\"User signed out.\");\n        }\n        setLoading(false); // Auth state determined\n      });\n    };\n\n    // Define a custom event for Firebase initialization\n    window.addEventListener('firebaseInitialized', handleFirebaseInit);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('firebaseInitialized', handleFirebaseInit);\n      if (typeof unsubscribe === 'function') {\n      console.log(\"Cleaning up Firebase onAuthStateChanged listener.\");\n        unsubscribe();\n      }\n    };\n  }, []);\n\n  const value = useMemo(() => ({\n    currentUser,\n    idToken,\n    loading,\n    error,\n    login,\n    logout,\n    isAuthenticated: !!currentUser && !!idToken,\n    isLoggingIn,\n    setIsLoggingIn,\n    isFirebaseInitialized\n  }), [currentUser, idToken, loading, error, login, logout, isLoggingIn, setIsLoggingIn, isFirebaseInitialized]);\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}; ","import { createContext, useContext, useState, useMemo, useEffect } from 'react';\nimport { useLoading } from './LoadingContext';\n\n// Create chat status context\nconst ChatStatusContext = createContext();\n\n// Hook to use chat status context\nexport const useChatStatus = () => {\n  const context = useContext(ChatStatusContext);\n  if (context === undefined) {\n    throw new Error('useChatStatus must be used within a ChatStatusProvider');\n  }\n  return context;\n};\n\n// Provider component for chat status\nexport const ChatStatusProvider = ({ children }) => {\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\n  const [error, setError] = useState(null);\n  // Sync with global loading context for chat\n  const [, startChatLoading, stopChatLoading] = useLoading('chat');\n  useEffect(() => {\n    if (isWaitingForResponse) startChatLoading();\n    else stopChatLoading();\n  }, [isWaitingForResponse, startChatLoading, stopChatLoading]);\n\n  const value = useMemo(() => ({\n    isWaitingForResponse,\n    setIsWaitingForResponse,\n    error,\n    setError,\n  }), [isWaitingForResponse, error]);\n\n  return (\n    <ChatStatusContext.Provider value={value}>\n      {children}\n    </ChatStatusContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useCallback } from 'react';\n\n// Context to track multiple loading tags\nconst LoadingContext = createContext(null);\n\n/**\n * Provider to wrap application and manage loading states by tags\n */\nexport const LoadingProvider = ({ children }) => {\n  const [loadingMap, setLoadingMap] = useState({});\n\n  const setLoading = useCallback((tag, isLoading) => {\n    setLoadingMap(prev => ({ ...prev, [tag]: isLoading }));\n  }, []);\n\n  const isLoading = useCallback(tag => !!loadingMap[tag], [loadingMap]);\n  const anyLoading = Object.values(loadingMap).some(val => val);\n\n  return (\n    <LoadingContext.Provider value={{ setLoading, isLoading, anyLoading }}>\n      {children}\n    </LoadingContext.Provider>\n  );\n};\n\n/**\n * Hook to control loading for a specific tag\n * @param {string} tag - Unique identifier for loading scope\n * @returns {[boolean, function, function]} [isLoading, startLoading, stopLoading]\n */\nexport const useLoading = (tag) => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useLoading must be used within LoadingProvider');\n  const { setLoading, isLoading } = context;\n  const startLoading = useCallback(() => setLoading(tag, true), [setLoading, tag]);\n  const stopLoading = useCallback(() => setLoading(tag, false), [setLoading, tag]);\n  return [isLoading(tag), startLoading, stopLoading];\n};\n\n/**\n * Hook to check if any loading is active globally\n * @returns {boolean}\n */\nexport const useGlobalLoading = () => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useGlobalLoading must be used within LoadingProvider');\n  return context.anyLoading;\n}; ","import { createContext, useContext, useMemo, useEffect } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatStatusProvider } from './ChatStatusContext';\nimport { ChatHistoryProvider } from './ChatHistoryContext';\nimport { PerformanceMetricsProvider } from './PerformanceMetricsContext';\nimport { StreamingEventsProvider } from './StreamingEventsContext';\nimport { ChatStateProvider } from './ChatStateContext';\nimport { ChatControlProvider } from './ChatControlContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n  // Mark as initialized once on mount\n  useEffect(() => {\n    initializationState.setInitialized(true);\n  }, [initializationState]);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatStatusProvider>\n                <ChatHistoryProvider>\n                  <PerformanceMetricsProvider>\n                    <StreamingEventsProvider>\n                      <ChatStateProvider>\n                        <ChatControlProvider>\n                          {children}\n                        </ChatControlProvider>\n                      </ChatStateProvider>\n                    </StreamingEventsProvider>\n                  </PerformanceMetricsProvider>\n                </ChatHistoryProvider>\n              </ChatStatusProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useRef,  useCallback, useMemo } from 'react';\n\n// Create chat history context\nconst ChatHistoryContext = createContext();\n\n// Hook to use chat history context\nexport const useChatHistory = () => {\n  const context = useContext(ChatHistoryContext);\n  if (context === undefined) {\n    throw new Error('useChatHistory must be used within a ChatHistoryProvider');\n  }\n  return context;\n};\n\n// Provider component for chat history\nexport const ChatHistoryProvider = ({ children }) => {\n  // State and ref for chat history, with custom setter to sync ref immediately\n  const [chatHistory, internalSetChatHistory] = useState([]);\n  const chatHistoryRef = useRef([]);\n\n  // Wrap setter to sync ref and state in one step\n  const setChatHistory = useCallback((update) => {\n    internalSetChatHistory(prev => {\n      const newHistory = typeof update === 'function' ? update(prev) : update;\n      chatHistoryRef.current = newHistory;\n      return newHistory;\n    });\n  }, []);\n\n  // Add message, stable callback\n  const addMessageToHistory = useCallback((role, content, metrics) => {\n    const message = { role, content, timestamp: Date.now(), ...(metrics && { metrics }) };\n    setChatHistory(prev => [...prev, message]);\n    return message;\n  }, [setChatHistory]);\n\n  // Function to update content of the most recent assistant message (avoiding user replacements)\n  const updateChatWithContent = useCallback((content) => {\n    setChatHistory(prev => {\n      const lastIndex = prev.length - 1;\n      if (lastIndex < 0) return prev;\n      const lastMsg = prev[lastIndex];\n      // No-op if not assistant or same content\n      if (lastMsg.role !== 'assistant' || lastMsg.content === content) {\n        return prev;\n      }\n      // Otherwise clone and update\n      const newHistory = [...prev];\n      newHistory[lastIndex] = { ...lastMsg, content };\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Memoize context value to avoid re-renders\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    updateChatWithContent\n  }), [chatHistory, setChatHistory, addMessageToHistory, updateChatWithContent]);\n\n  return (\n    <ChatHistoryContext.Provider value={value}>\n      {children}\n    </ChatHistoryContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useRef, useCallback,  useMemo } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { fetchWithRetry } from '../utils/network';\nimport debounce from 'lodash.debounce';\n\n// Create a context for streaming events and logic\nconst StreamingEventsContext = createContext();\n\nexport const useStreamingEvents = () => {\n  const context = useContext(StreamingEventsContext);\n  if (context === undefined) {\n    throw new Error('useStreamingEvents must be used within a StreamingEventsProvider');\n  }\n  return context;\n};\n\nexport const StreamingEventsProvider = ({ children }) => {\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics } = usePerformanceMetrics();\n\n  // Refs for streaming\n  const streamingTextRef = useRef('');\n  const currentRequestIdRef = useRef(null);\n  const abortControllerRef = useRef(null);\n  const isStreamingRef = useRef(false);\n  const firstTokenReceivedRef = useRef(false);\n\n  // Debounced content updater\n  const debouncedUpdateChat = useMemo(\n    () => debounce((content) => updateChatWithContent(content), 20),\n    [updateChatWithContent]\n  );\n\n  // SSE parsing worker setup\n  const streamWorkerUrlRef = useRef(null);\n  const streamWorkerRef = useRef(null);\n  const getOrCreateStreamWorker = useCallback(() => {\n    if (!streamWorkerRef.current) {\n      if (!streamWorkerUrlRef.current) {\n        streamWorkerUrlRef.current = new URL('../workers/streamProcessor.js', import.meta.url);\n      }\n      streamWorkerRef.current = new Worker(streamWorkerUrlRef.current, { type: 'module' });\n    }\n    return streamWorkerRef.current;\n  }, []);\n\n  const parseStreamChunk = useCallback((chunk) => new Promise((resolve, reject) => {\n    const worker = getOrCreateStreamWorker();\n    worker.onmessage = (e) => resolve(e.data);\n    worker.onerror = reject;\n    worker.postMessage(chunk);\n  }), [getOrCreateStreamWorker]);\n\n  // Helper to update placeholder on error\n  const _updatePlaceholderOnError = useCallback(() => {\n    setChatHistory(prev => {\n      const newHistory = [...prev];\n      const lastMessage = newHistory[newHistory.length - 1];\n      if (lastMessage && lastMessage.role === 'assistant') {\n        const existingContent = lastMessage.content;\n        const errorSuffix = ' [Error occurred during generation]';\n        if (!existingContent.includes(errorSuffix)) {\n          lastMessage.content = existingContent\n            ? `${existingContent}${errorSuffix}`\n            : 'Error occurred during generation';\n          if (lastMessage.metrics) {\n            lastMessage.metrics.isComplete = true;\n            lastMessage.metrics.error = true;\n          }\n        }\n      }\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Stream a message using fetch SSE\n  const streamMessageWithFetch = useCallback(async (message, editIndex = null) => {\n    // Generate and store a client-side requestId for this stream\n    const requestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = requestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = `${selectedModel.provider}/${selectedModel.id}`;\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        userMessage = { role: 'user', content: message, timestamp: Date.now() };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    resetPerformanceMetrics();\n    startPerformanceTimer();\n    firstTokenReceivedRef.current = false;\n    setIsWaitingForResponse(true);\n    setError(null);\n    streamingTextRef.current = '';\n    isStreamingRef.current = true;\n    addMessageToHistory('assistant', '');\n    let timeoutId = setTimeout(() => {\n      abortControllerRef.current?.abort('timeout');\n      setError('Connection timed out');\n      setIsWaitingForResponse(false);\n    }, 60000);\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now() - 1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = {\n        requestId,\n        model: modelId,\n        messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'text/event-stream', 'Cache-Control': 'no-cache' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/stream', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload), signal: abortController.signal, cache: 'no-store'\n      });\n      if (!response.ok) throw new Error(`API error: ${response.status}`);\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder('utf-8');\n      let accumulatedContent = '';\n      while (true) {\n        const { done, value } = await reader.read();\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n          abortControllerRef.current?.abort();\n          setError('Connection timed out');\n          setIsWaitingForResponse(false);\n        }, 60000);\n        if (done) {\n          // handle leftover buffer\n          break;\n        }\n        const chunk = decoder.decode(value, { stream: true });\n\n        console.log('Received stream chunk:', chunk);\n\n        try {\n          const msgs = await parseStreamChunk(chunk);\n          for (const msg of msgs) {\n            // Append any content from the chunk\n            if (msg.content) {\n              // Record time to first token once\n              if (!firstTokenReceivedRef.current) {\n                updatePerformanceMetrics(1);\n                firstTokenReceivedRef.current = true;\n              }\n              accumulatedContent += msg.content;\n              streamingTextRef.current = accumulatedContent;\n              debouncedUpdateChat(accumulatedContent);\n            }\n            // Always use server-reported completion tokens for metrics\n            const completionTokens = msg.usage?.completionTokens ?? 0;\n            updatePerformanceMetrics(completionTokens, msg.isDone, msg.usage, msg.finishReason);\n          }\n        } catch {}\n      }\n      debouncedUpdateChat.flush();\n      updateChatWithContent(streamingTextRef.current);\n      return streamingTextRef.current;\n    } catch (error) {\n      _updatePlaceholderOnError();\n      return null;\n    } finally {\n      clearTimeout(timeoutId);\n      isStreamingRef.current = false;\n      setIsWaitingForResponse(false);\n      // Do not auto-call stop endpoint here; only explicit stop should trigger it\n      currentRequestIdRef.current = null;\n    }\n  }, [\n    apiUrl, selectedModel, getModelAdjustedSettings, idToken,\n    chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent,\n    debouncedUpdateChat, setError, setIsWaitingForResponse,\n    resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics,\n    parseStreamChunk, _updatePlaceholderOnError\n  ]);\n\n  const stopStreaming = useCallback(async () => {\n    if (abortControllerRef.current) abortControllerRef.current.abort('user_stopped');\n    const reqId = currentRequestIdRef.current;\n    if (reqId) {\n      const headers = { 'Content-Type': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      try {\n        await fetchWithRetry(new URL('/api/chat/stop', apiUrl).toString(), {\n          method: 'POST', headers, body: JSON.stringify({ requestId: reqId })\n        });\n      } catch {} finally {\n        currentRequestIdRef.current = null;\n        abortControllerRef.current = null;\n      }\n    }\n    isStreamingRef.current = false;\n    setIsWaitingForResponse(false);\n    return true;\n  }, [apiUrl, idToken, setIsWaitingForResponse]);\n\n  const value = useMemo(() => ({\n    streamMessageWithFetch,\n    stopStreaming,\n    parseStreamChunk,\n    streamingTextRef,\n    isStreaming: () => isStreamingRef.current\n  }), [streamMessageWithFetch, stopStreaming, parseStreamChunk]);\n\n  return (\n    <StreamingEventsContext.Provider value={value}>\n      {children}\n    </StreamingEventsContext.Provider>\n  );\n}; ","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './Spinner.module.css';\n\n/**\n * Standardized Spinner for all loading states\n * @param {Object} props\n * @param {string} props.size - One of 'small', 'medium', 'large'\n * @param {string} props.tag - Optional loading tag for context\n */\nconst Spinner = ({ size = 'medium', tag }) => {\n  const sizeClass = styles[`Spinner--${size}`] || styles['Spinner--medium'];\n  return (\n    <div className={`${styles.Spinner} ${sizeClass}`} data-loading-tag={tag} aria-label=\"Loading\" role=\"status\">\n      <div className={styles.Spinner__loader} />\n    </div>\n  );\n};\n\nSpinner.propTypes = {\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n  tag: PropTypes.string\n};\n\nexport default Spinner; ","import { useEffect, useRef } from 'react';\nimport { useLoading } from '../../../contexts/LoadingContext';\nimport { useToast } from '../../../contexts/ToastContext';\n\nconst GlobalLoadingIndicator = () => {\n  // Only show global loading overlay for authentication operations\n  const [authLoading] = useLoading('auth');\n  const isLoading = authLoading;\n  const { showToast, dismissToast } = useToast();\n  const toastIdRef = useRef(null);\n  useEffect(() => {\n    if (isLoading) {\n      // show persistent loading toast for heavy operations\n      toastIdRef.current = showToast({ type: 'info', message: 'Loading in progress...', duration: 0 });\n    } else if (toastIdRef.current) {\n      // dismiss loading toast and show completion\n      dismissToast(toastIdRef.current);\n      showToast({ type: 'success', message: 'Loading complete', duration: 2000 });\n      toastIdRef.current = null;\n    }\n    return () => {\n      if (toastIdRef.current) {\n        dismissToast(toastIdRef.current);\n        toastIdRef.current = null;\n      }\n    };\n  }, [authLoading]);\n\n  // No overlay spinner; toasts still handled in useEffect\n  return null;\n};\n\nexport default GlobalLoadingIndicator; ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create API context\nconst ApiContext = createContext();\n\n// Custom hook for using API context\nexport const useApi = () => {\n  const context = useContext(ApiContext);\n  if (context === undefined) {\n    throw new Error('useApi must be used within an ApiProvider');\n  }\n  return context;\n};\n\n// API provider component\nexport const ApiProvider = ({ children }) => {\n  const [apiUrl] = useState(process.env.REACT_APP_API_URL || 'http://localhost:3000/api'); // Base API URL\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    apiUrl,\n  }), [apiUrl]);\n\n  return (\n    <ApiContext.Provider value={value}>\n      {children}\n    </ApiContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo, useCallback, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { useStreamingEvents } from './StreamingEventsContext';\nimport { fetchWithRetry } from '../utils/network';\nimport { useIsDesktop } from '../hooks/useMediaQuery';\nimport { useToast } from './ToastContext';\n\n// Context for chat actions (controls)\nconst ChatControlContext = createContext();\n\n// Hook to consume chat controls\nexport const useChatControl = () => {\n  const context = useContext(ChatControlContext);\n  if (context === undefined) {\n    throw new Error('useChatControl must be used within a ChatControlProvider');\n  }\n  return context;\n};\n\n// Provider component for chat controls\nexport const ChatControlProvider = ({ children }) => {\n  // Ref to track client-generated request ID for non-streaming\n  const currentRequestIdRef = useRef(null);\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { settings, getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, setTokenMetricsForLastMessage } = usePerformanceMetrics();\n  const { streamMessageWithFetch, stopStreaming } = useStreamingEvents();\n  const isDesktop = useIsDesktop();\n  const { showToast } = useToast();\n\n  // Helpers\n  const formatModelIdentifier = useCallback((model) => {\n    if (!model || !model.provider || !model.id) return null;\n    return `${model.provider}/${model.id}`;\n  }, []);\n\n  // Action: sendMessage\n  const sendMessage = useCallback(async (message, editIndex = null) => {\n    // Generate unique client-side requestId\n    const clientRequestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = clientRequestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (settings.streaming) {\n      return streamMessageWithFetch(message, isEditing ? editIndex : null);\n    }\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = formatModelIdentifier(selectedModel);\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        userMessage = { role: 'user', content: message, timestamp: Date.now() };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    const requestStartTime = Date.now();\n    setIsWaitingForResponse(true);\n    setError(null);\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now()-1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = { \n        requestId: clientRequestId,\n        model: modelId, messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      resetPerformanceMetrics();\n      startPerformanceTimer();\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/completions', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        let errMsg = `API error: ${response.status}`;\n        try { const errData = await response.json(); errMsg = errData?.error?.message || errData?.message || errMsg; } catch {};\n        throw new Error(errMsg);\n      }\n      const data = await response.json();\n      console.log('Received non-streaming chat data:', data);\n\n      const content = data.content || 'No Response returned';\n      // Use server-provided usage tokens directly\n      const rawUsage = data.usage || {};\n      const promptTokens = rawUsage.promptTokens ?? rawUsage.prompt_tokens ?? 0;\n      const completionTokens = rawUsage.completionTokens ?? rawUsage.completion_tokens ?? 0;\n      const totalTokens = rawUsage.totalTokens ?? rawUsage.total_tokens ?? completionTokens;\n      // Compute timing and rates\n      const requestEndTime = Date.now();\n      const elapsed = requestEndTime - requestStartTime;\n      const tokensForMetrics = completionTokens > 0 ? completionTokens : 0;\n      const tokensPerSecond = elapsed\n        ? Math.round((tokensForMetrics / (elapsed / 1000)) * 10) / 10\n        : null;\n      const finalMetrics = {\n        startTime: requestStartTime,\n        endTime: requestEndTime,\n        elapsedTime: elapsed,\n        tokenCount: tokensForMetrics,\n        tokensPerSecond,\n        isComplete: true,\n        timeToFirstToken: null,\n        promptTokens,\n        completionTokens,\n        totalTokens,\n        finishReason: data.finishReason\n      };\n      addMessageToHistory('assistant', content, finalMetrics);\n      return content;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err.message);\n      addMessageToHistory('error', err.message || 'An error occurred');\n      return null;\n    } finally {\n      // Clear the clientRequestId after completion\n      currentRequestIdRef.current = null;\n      setIsWaitingForResponse(false);\n    }\n  }, [\n    apiUrl,\n    selectedModel,\n    settings.streaming,\n    getModelAdjustedSettings,\n    idToken,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    streamMessageWithFetch,\n    formatModelIdentifier,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    setError,\n    setIsWaitingForResponse,\n  ]);\n\n  // Action: stopGeneration\n  const stopGenerationAction = useCallback(async () => {\n    stopStreaming();\n    return true;\n  }, [stopStreaming]);\n\n  // Action: clearChat\n  const clearChat = useCallback(() => {\n    setChatHistory([]);\n    resetPerformanceMetrics();\n  }, [setChatHistory, resetPerformanceMetrics]);\n\n  // Action: newChat\n  const newChat = useCallback(() => {\n    if (chatHistoryRef.current.length > 0) {\n      clearChat();\n    }\n  }, [chatHistoryRef, clearChat]);\n\n  // Action: resetChat\n  const resetChat = useCallback(() => {\n    if (chatHistoryRef.current.length === 0) return;\n    \n    if (window.confirm('Are you sure you want to clear the current chat?')) {\n      clearChat();\n      showToast({ type: 'info', message: 'Chat has been cleared' });\n    }\n  }, [chatHistoryRef, clearChat, showToast]);\n\n  // Action: downloadChat\n  const downloadChat = useCallback(() => {\n    const history = chatHistoryRef.current;\n    if (!history.length) return;\n    try {\n      const formatted = history.map(msg => {\n        const role = msg.role === 'user'\n          ? 'You'\n          : msg.role === 'assistant'\n            ? selectedModel?.name || 'Assistant'\n            : msg.role;\n        let contentText = '';\n        if (typeof msg.content === 'string') {\n          contentText = msg.content;\n        } else if (Array.isArray(msg.content)) {\n          contentText = msg.content\n            .map(part => part.type === 'text' ? part.text : '[Image]')\n            .join('\\n');\n        }\n        return `${role}: ${contentText}\\n`;\n      }).join('');\n      const blob = new Blob([formatted], { type: 'text/plain' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `chat_${new Date().toISOString().replace(/:/g, '-')}.txt`;\n      document.body.appendChild(a);\n      a.click();\n      showToast({ type: 'success', message: 'Chat downloaded successfully' });\n      // Clean up anchor and URL\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      console.error(\"Error downloading chat:\", error);\n      showToast({ type: 'error', message: 'Failed to download chat. Please try again.' });\n    }\n  }, [chatHistoryRef, selectedModel, showToast]);\n\n  // Action: getOrCreateConversation (stub)\n  const getOrCreateConversation = useCallback((conversationId) => {\n    // implement or delegate\n  }, []);\n\n  // Value\n  const value = useMemo(() => ({\n    sendMessage,\n    stopGeneration: stopGenerationAction,\n    addMessageToHistory,\n    clearChat,\n    newChat,\n    resetChat,\n    downloadChat,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  }), [\n    sendMessage,\n    stopGenerationAction,\n    addMessageToHistory,\n    clearChat,\n    newChat,\n    resetChat,\n    downloadChat,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  ]);\n\n  return (\n    <ChatControlContext.Provider value={value}>\n      {children}\n    </ChatControlContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\n\n// Context for read-only chat state\nconst ChatStateContext = createContext();\n\n// Hook to consume chat state\nexport const useChatState = () => {\n  const context = useContext(ChatStateContext);\n  if (context === undefined) {\n    throw new Error('useChatState must be used within a ChatStateProvider');\n  }\n  return context;\n};\n\n// Provider component for chat state\nexport const ChatStateProvider = ({ children }) => {\n  const { chatHistory, chatHistoryRef } = useChatHistory();\n  const { isWaitingForResponse, error } = useChatStatus();\n\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    isWaitingForResponse,\n    error\n  }), [chatHistory, isWaitingForResponse, error]);\n\n  return (\n    <ChatStateContext.Provider value={value}>\n      {children}\n    </ChatStateContext.Provider>\n  );\n}; ","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './ToastNotification.module.css';\n\n/**\n * ToastNotification component renders a list of toast messages.\n * @param {Object} props\n * @param {Array} props.toasts - Array of toast objects { id, type, message, duration }\n * @param {Function} props.dismissToast - Function to remove a toast by id\n */\nconst ToastNotification = ({ toasts, dismissToast }) => {\n  return (\n    <div className={styles.toastContainer}>\n      {toasts.map((toast) => (\n        <div key={toast.id} className={`${styles.toast} ${styles[toast.type] || ''}`}> \n          <span className={styles.message}>{toast.message}</span>\n          <button\n            type=\"button\"\n            className={styles.closeButton}\n            onClick={() => dismissToast(toast.id)}\n            aria-label=\"Close notification\"\n          >\n            \n          </button>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nToastNotification.propTypes = {\n  toasts: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      type: PropTypes.oneOf(['error', 'success', 'info', 'warning']),\n      message: PropTypes.string.isRequired,\n      duration: PropTypes.number\n    })\n  ).isRequired,\n  dismissToast: PropTypes.func.isRequired\n};\n\nexport default ToastNotification; ","import React, { createContext, useContext, useReducer, useCallback } from 'react';\nimport ToastContainer from '../components/common/ToastNotification';\n\n// Create context for toast notifications\nconst ToastContext = createContext();\n\n// Hook to use toast context\nexport const useToast = () => {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within a ToastProvider');\n  }\n  return context;\n};\n\n// Action types\nconst ADD_TOAST = 'ADD_TOAST';\nconst REMOVE_TOAST = 'REMOVE_TOAST';\n\n// Reducer to manage toast list\nfunction toastReducer(state, action) {\n  switch (action.type) {\n    case ADD_TOAST:\n      return [...state, action.payload];\n    case REMOVE_TOAST:\n      return state.filter(toast => toast.id !== action.payload);\n    default:\n      return state;\n  }\n}\n\n// Provider component that holds toast state and renders toasts\nexport const ToastProvider = ({ children }) => {\n  const [toasts, dispatch] = useReducer(toastReducer, []);\n\n  // Function to show a toast\n  const showToast = useCallback(({ type, message, duration = 3000 }) => {\n    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);\n    dispatch({ type: ADD_TOAST, payload: { id, type, message, duration } });\n    // Auto-dismiss toast after duration\n    setTimeout(() => dispatch({ type: REMOVE_TOAST, payload: id }), duration);\n    return id;\n  }, []);\n\n  // Function to manually dismiss a toast\n  const dismissToast = useCallback(id => {\n    dispatch({ type: REMOVE_TOAST, payload: id });\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ showToast, dismissToast }}>\n      {children}\n      <ToastContainer toasts={toasts} dismissToast={dismissToast} />\n    </ToastContext.Provider>\n  );\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport { useCacheToggle } from '../hooks/useCacheToggle';\nimport { useToast } from './ToastContext';\nimport { useLoading } from './LoadingContext';\n\n// Cache expiry time in milliseconds (5 days)\nconst CACHE_EXPIRY_TIME = 5 * 24 * 60 * 60 * 1000;\n\n// Create separate contexts for models and filtering\nconst ModelContext = createContext();\nconst ModelFilterContext = createContext();\n\n// Custom hook for using model context\nexport const useModel = () => {\n  const context = useContext(ModelContext);\n  if (context === undefined) {\n    throw new Error('useModel must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Custom hook for using model filter context\nexport const useModelFilter = () => {\n  const context = useContext(ModelFilterContext);\n  if (context === undefined) {\n    throw new Error('useModelFilter must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Model provider component\nexport const ModelProvider = ({ children }) => {\n  const { cacheEnabled } = useCacheToggle();\n  const { apiUrl } = useApi();\n  const { idToken } = useAuth();\n  const { showToast } = useToast();\n  \n  // State for model data\n  const [allModels, setAllModels] = useState([]);\n  const [processedModels, setProcessedModels] = useState({});\n  const [experimentalModels, setExperimentalModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Filter state - moved to separate context\n  const [showExperimental, setShowExperimental] = useLocalStorage('showExperimental', false);\n  const [modelFilter, setModelFilter] = useState({\n    search: '',\n    categories: {\n      'Chat': true,\n      'Image': true,\n      'Embedding': true\n    }\n  });\n  \n  // Sync with global loading context\n  const [, startModelsLoading, stopModelsLoading] = useLoading('models');\n  useEffect(() => {\n    if (isLoading) startModelsLoading();\n    else stopModelsLoading();\n  }, [isLoading, startModelsLoading, stopModelsLoading]);\n  \n  // Check if cache is valid\n  const isCacheValid = useCallback((cache) => {\n    return (\n      cache &&\n      cache.timestamp &&\n      Date.now() - cache.timestamp < CACHE_EXPIRY_TIME &&\n      cache.allModels &&\n      cache.processedModels &&\n      cache.experimentalModels\n    );\n  }, []);\n  \n  // Expose isCacheValid function for external access\n  useEffect(() => {\n    // Skip during server-side rendering\n    if (typeof window === 'undefined') return;\n    window.isCacheValid = isCacheValid;\n    \n    return () => {\n      delete window.isCacheValid;\n    };\n  }, [isCacheValid]);\n  \n  // Cache models to localStorage\n  const cacheModels = useCallback((data) => {\n    try {\n      const cache = {\n        allModels: data.allModels,\n        processedModels: data.processedModels,\n        experimentalModels: data.experimentalModels,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem('modelDropdownCache', JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error caching models:', error);\n    }\n  }, []);\n  \n  // Update category filter\n  const updateCategoryFilter = useCallback((category, isChecked) => {\n    setModelFilter(prev => ({\n      ...prev,\n      categories: {\n        ...prev.categories,\n        [category]: isChecked\n      }\n    }));\n  }, []);\n  \n  // Update search filter\n  const updateSearchFilter = useCallback((searchText) => {\n    setModelFilter(prev => ({\n      ...prev,\n      search: searchText\n    }));\n  }, []);\n  \n  // Select a model\n  const selectModel = useCallback((model) => {\n    // Check if the model is actually different to prevent unnecessary updates\n    if (selectedModel?.id !== model?.id) { \n      setSelectedModel(model);\n    }\n  }, [selectedModel, setSelectedModel]);\n  \n  // Fetch models from API, optionally using auth token or override token\n  const fetchModels = useCallback(async (authRequired = false, overrideToken = null) => {\n    setIsLoading(true);\n    setError(null);\n    \n    console.log(`Fetching models from API (auth: ${authRequired})...`);\n    try {\n      const headers = { 'Accept': 'application/json' };\n      if (authRequired) {\n        // Prefer overrideToken (cached) over current idToken\n        const tokenToUse = overrideToken || idToken;\n        if (tokenToUse) {\n          headers['Authorization'] = `Bearer ${tokenToUse}`;\n        }\n      }\n      const modelsUrl = new URL('/api/models/classified', apiUrl).toString();\n      const response = await fetch(modelsUrl, { headers });\n      console.log('Models response:', response);\n      \n      if (!response.ok) {\n        let errorMsg = `Error fetching models: ${response.status}`;\n        console.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n      \n      const rawData = await response.json();\n      console.log(\"[ModelContext] Spawning worker for model processing...\");\n      // Offload model processing to Web Worker\n      const worker = new Worker(new URL('../workers/modelProcessor.js', import.meta.url), { type: 'module' });\n      worker.postMessage(rawData);\n      worker.onmessage = ({ data: msg }) => {\n        if (msg.error) {\n          console.error('[ModelContext] Worker error:', msg.error);\n          setError(msg.error);\n          showToast({ type: 'error', message: msg.error });\n        } else {\n          const {\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          } = msg;\n          if (cacheEnabled) {\n            const rawPrev = localStorage.getItem('modelDropdownCache');\n            let prevCache;\n            try { prevCache = JSON.parse(rawPrev); } catch { prevCache = null; }\n            const changed = !prevCache ||\n              JSON.stringify(prevCache.allModels) !== JSON.stringify(fetchedAllModels) ||\n              JSON.stringify(prevCache.processedModels) !== JSON.stringify(fetchedProcessedModels) ||\n              JSON.stringify(prevCache.experimentalModels) !== JSON.stringify(fetchedExperimentalModels);\n            if (changed) {\n              setAllModels(fetchedAllModels);\n              setProcessedModels(fetchedProcessedModels);\n              setExperimentalModels(fetchedExperimentalModels);\n              cacheModels({ allModels: fetchedAllModels, processedModels: fetchedProcessedModels, experimentalModels: fetchedExperimentalModels });\n            }\n          } else {\n            setAllModels(fetchedAllModels);\n            setProcessedModels(fetchedProcessedModels);\n            setExperimentalModels(fetchedExperimentalModels);\n          }\n          // Initial model selection moved to a separate useEffect\n        }\n        setIsLoading(false);\n        worker.terminate();\n      };\n      worker.onerror = (err) => {\n        console.error('[ModelContext] Worker unexpected error:', err);\n        setError(err.message);\n        showToast({ type: 'error', message: err.message });\n        setIsLoading(false);\n        worker.terminate();\n      };\n    } catch (err) {\n      console.error('Failed to fetch or process models:', err);\n      setError(err.message || 'Failed to load model data');\n      showToast({ type: 'error', message: err.message || 'Failed to load model data' });\n      // Attempt to load from potentially expired cache as a last resort?\n    }\n  }, [apiUrl, cacheModels, idToken, cacheEnabled, showToast]);\n  \n  // Initial fetch once on mount\n  const initialFetchDoneRef = useRef(false);\n  // track if we've already fetched models with authentication\n  const didAuthFetchRef = useRef(false);\n\n  useEffect(() => {\n    if (!initialFetchDoneRef.current) {\n      if (cacheEnabled) {\n        const rawCache = localStorage.getItem('modelDropdownCache');\n        let parsedCache;\n        try { parsedCache = JSON.parse(rawCache); } catch { parsedCache = null; }\n        if (parsedCache && window.isCacheValid(parsedCache)) {\n          setAllModels(parsedCache.allModels);\n          setProcessedModels(parsedCache.processedModels);\n          setExperimentalModels(parsedCache.experimentalModels);\n          setIsLoading(false);\n        }\n      }\n      let cachedToken = null;\n      try { cachedToken = localStorage.getItem('idToken'); } catch {}\n      if (cachedToken) {\n        // initial authenticated fetch\n        didAuthFetchRef.current = true;\n        fetchModels(true, cachedToken);\n      } else {\n        // initial unauthenticated fetch\n        fetchModels(false);\n      }\n      initialFetchDoneRef.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // After login, fetch authenticated models\n  useEffect(() => {\n    // only fetch once after obtaining idToken if not already done\n    if (initialFetchDoneRef.current && idToken && !didAuthFetchRef.current) {\n      didAuthFetchRef.current = true;\n      fetchModels(true);\n    }\n  }, [idToken, fetchModels]);\n  \n  // Set initial model after models are loaded\n  useEffect(() => {\n    // Select first model if none selected and models are loaded\n    if (!selectedModel && allModels.length > 0) {\n      setSelectedModel(allModels[0]);\n    }\n  }, [allModels, selectedModel]);\n  \n  // Create toggleExperimentalModels callback at the top level\n  const toggleExperimentalModels = useCallback(() => {\n    setShowExperimental(prev => !prev);\n  }, [setShowExperimental]);\n  \n  // Main model context value - no filter state\n  const modelValue = useMemo(() => ({\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    isExperimentalModelsEnabled: showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    refreshModels: fetchModels\n  }), [\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    fetchModels\n  ]);\n  \n  // Filter context value - only filter-related state\n  const filterValue = useMemo(() => ({\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  }), [\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  ]);\n  \n  return (\n    <ModelContext.Provider value={modelValue}>\n      <ModelFilterContext.Provider value={filterValue}>\n        {children}\n      </ModelFilterContext.Provider>\n    </ModelContext.Provider>\n  );\n}; "],"names":["ThemeContext","createContext","useTheme","context","useContext","undefined","Error","ThemeProvider","_ref","children","theme","setTheme","useState","localStorage","getItem","toggleTheme","useCallback","prevTheme","newTheme","setItem","useEffect","document","body","classList","remove","add","value","useMemo","isDark","_jsx","Provider","PerformanceMetricsContext","usePerformanceMetrics","PerformanceMetricsProvider","setChatHistory","useChatHistory","currentMessageMetrics","setCurrentMessageMetrics","startTime","endTime","elapsedTime","tokenCount","tokensPerSecond","isComplete","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","resetPerformanceMetrics","startPerformanceTimer","prev","Date","now","updatePerformanceMetrics","newTokenCount","arguments","length","tokenInfo","Math","round","prevHistory","newHistory","lastMsg","role","metrics","setTokenMetricsForLastMessage","DEFAULT_SETTINGS","temperature","top_p","max_tokens","frequency_penalty","presence_penalty","streaming","systemPrompt","SettingsContext","useSettings","SettingsProvider","settings","setSettings","useLocalStorage","updateSetting","key","resetSettings","shouldRestrictTemperature","model","requiresFixedTemperature","properties","includes","id","toLowerCase","startsWith","series","getModelAdjustedSettings","AuthContext","useAuth","AuthProvider","currentUser","setCurrentUser","idToken","setIdToken","loading","setLoading","startAuthLoading","stopAuthLoading","useLoading","error","setError","isLoggingIn","setIsLoggingIn","isFirebaseInitialized","setIsFirebaseInitialized","showToast","useToast","login","async","logout","getFirebaseAuth","signOut","firebaseSignOut","auth","msg","type","message","err","unsubscribe","handleFirebaseInit","initializeAuthListener","onAuthStateChanged","firebaseOnAuthStateChanged","user","token","getIdToken","e","removeItem","window","addEventListener","removeEventListener","isAuthenticated","ChatStatusContext","useChatStatus","ChatStatusProvider","isWaitingForResponse","setIsWaitingForResponse","startChatLoading","stopChatLoading","LoadingContext","LoadingProvider","loadingMap","setLoadingMap","tag","isLoading","anyLoading","Object","values","some","val","startLoading","stopLoading","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ApiProvider","ModelProvider","ChatHistoryProvider","StreamingEventsProvider","ChatStateProvider","ChatControlProvider","ChatHistoryContext","chatHistory","internalSetChatHistory","chatHistoryRef","useRef","update","current","addMessageToHistory","content","timestamp","updateChatWithContent","lastIndex","StreamingEventsContext","useStreamingEvents","apiUrl","useApi","selectedModel","useModel","streamingTextRef","currentRequestIdRef","abortControllerRef","isStreamingRef","firstTokenReceivedRef","debouncedUpdateChat","debounce","streamWorkerUrlRef","streamWorkerRef","getOrCreateStreamWorker","URL","Worker","parseStreamChunk","chunk","Promise","resolve","reject","worker","onmessage","data","onerror","postMessage","_updatePlaceholderOnError","lastMessage","existingContent","errorSuffix","streamMessageWithFetch","editIndex","requestId","crypto","randomUUID","random","toString","substring","isEditing","Number","isInteger","modelId","provider","userMessage","truncated","slice","timeoutId","setTimeout","_abortControllerRef$c","abort","abortController","AbortController","adjusted","historyForApi","map","_ref2","m","unshift","push","payload","messages","headers","response","fetchWithRetry","method","JSON","stringify","signal","cache","ok","status","reader","getReader","decoder","TextDecoder","accumulatedContent","done","read","clearTimeout","_abortControllerRef$c2","decode","stream","msgs","_msg$usage$completion","_msg$usage","usage","isDone","flush","stopStreaming","reqId","isStreaming","size","sizeClass","styles","className","Spinner","Spinner__loader","GlobalLoadingIndicator","authLoading","dismissToast","toastIdRef","duration","ApiContext","process","ChatControlContext","useChatControl","useIsDesktop","formatModelIdentifier","sendMessage","clientRequestId","requestStartTime","_ref3","_rawUsage$promptToken","_ref4","_rawUsage$completionT","_ref5","_rawUsage$totalTokens","errMsg","_errData$error","errData","json","rawUsage","prompt_tokens","completion_tokens","total_tokens","requestEndTime","elapsed","tokensForMetrics","finalMetrics","stopGenerationAction","clearChat","newChat","resetChat","confirm","downloadChat","history","formatted","name","contentText","Array","isArray","part","text","join","blob","Blob","url","createObjectURL","a","createElement","href","download","toISOString","replace","appendChild","click","removeChild","revokeObjectURL","getOrCreateConversation","conversationId","stopGeneration","ChatStateContext","useChatState","toasts","toastContainer","toast","_jsxs","closeButton","onClick","ToastContext","ADD_TOAST","REMOVE_TOAST","toastReducer","state","action","filter","ToastProvider","dispatch","useReducer","substr","ToastContainer","ModelContext","ModelFilterContext","useModelFilter","cacheEnabled","useCacheToggle","allModels","setAllModels","processedModels","setProcessedModels","experimentalModels","setExperimentalModels","setSelectedModel","setIsLoading","showExperimental","setShowExperimental","modelFilter","setModelFilter","search","categories","startModelsLoading","stopModelsLoading","isCacheValid","cacheModels","updateCategoryFilter","category","isChecked","updateSearchFilter","searchText","selectModel","fetchModels","authRequired","overrideToken","tokenToUse","modelsUrl","fetch","errorMsg","rawData","fetchedAllModels","fetchedProcessedModels","fetchedExperimentalModels","rawPrev","prevCache","parse","terminate","initialFetchDoneRef","didAuthFetchRef","rawCache","parsedCache","cachedToken","toggleExperimentalModels","modelValue","isExperimentalModelsEnabled","refreshModels","filterValue"],"sourceRoot":""}
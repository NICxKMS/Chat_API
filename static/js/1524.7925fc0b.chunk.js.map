{"version":3,"file":"static/js/1524.7925fc0b.chunk.js","mappings":"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","sources":["../node_modules/mdast-util-gfm-footnote/lib/index.js","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/mdast-util-gfm/lib/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/mdast-util-to-string/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n"],"names":["enterFootnoteDefinition","token","this","enter","type","identifier","label","children","enterFootnoteDefinitionLabelString","buffer","exitFootnoteDefinitionLabelString","resume","node","stack","length","normalizeIdentifier","sliceSerialize","toLowerCase","exitFootnoteDefinition","exit","enterFootnoteCall","enterFootnoteCallString","exitFootnoteCallString","exitFootnoteCall","footnoteReference","_","context","safeOptions","tracker","track","value","move","subexit","safe","association","current","before","after","footnoteDefinition","shift","indentLines","containerFlow","map","line","index","blank","peek","handleDelete","gfmStrikethroughFromMarkdown","canContainEols","strikethrough","gfmStrikethroughToMarkdown","unsafe","character","inConstruct","notInConstruct","handlers","delete","containerPhrasing","gfmTableFromMarkdown","table","align","_align","d","setData","tableData","enterCell","tableHeader","tableRow","codeText","getData","replace","$0","$1","gfmTableToMarkdown","options","settings","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","atBreak","serializeData","result","handleTableRowAsData","handleTableAsData","slice","indexOf","tableCell","handleTableCell","inlineCode","parent","includes","matrix","markdownTable","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","checked","head","siblings","firstParaghraph","sibling","position","start","offset","column","Object","assign","gfmTaskListItemToMarkdown","listItem","checkable","checkbox","gfmFromMarkdown","gfmAutolinkLiteralFromMarkdown","gfmFootnoteDefinition","gfmFootnoteDefinitionLabelString","gfmFootnoteCall","gfmFootnoteCallString","gfmToMarkdown","extensions","gfmAutolinkLiteralToMarkdown","mathFromMarkdown","mathFlow","meta","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","mathText","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathToMarkdown","single","singleDollarTextMath","inlineMath","undefined","math","raw","sequence","repeat","Math","max","longestStreak","encode","size","RegExp","test","pattern","expression","patternCompile","match","exec","codePointAt","emptyOptions","toString","one","includeImageAlt","includeHtml","Boolean","alt","all","Array","isArray","values","join"],"sourceRoot":""}
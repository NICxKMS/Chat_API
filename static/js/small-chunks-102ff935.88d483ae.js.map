{"version":3,"file":"static/js/small-chunks-102ff935.88d483ae.js","mappings":"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","sources":["utils/preloadFormatting.js","hooks/useChatLogic.js","utils/performance.js","reportWebVitals.js","serviceWorkerRegistration.js","index.js","hooks/useCacheToggle.js","hooks/useMediaQuery.js","workers/modelProcessor.js","firebaseConfig.js","hooks/useLocalStorage.js"],"sourcesContent":["/**\n * Utility functions for preloading formatting-related components\n */\nimport {  PERFORMANCE_MARKS, PERFORMANCE_MEASURES } from './performance';\n\n// Phase 2: Basic Formatting Components - essential for initial rendering\nexport const basicFormattingImports = [\n  () => import(/* webpackChunkName: \"react-markdown\" */ 'react-markdown'),\n  () => import(/* webpackChunkName: \"remark-gfm\" */ 'remark-gfm'),\n];\n\n// Advanced Formatting Components - includes StreamingMessage and all its dependencies\nexport const advancedFormattingImports = [\n  // StreamingMessage and its dependencies\n  () => import(/* webpackChunkName: \"streaming-message\" */ '../components/chat/ChatMessage/StreamingMessage'),\n  () => import(/* webpackChunkName: \"syntax-highlighter-prism\" */ 'react-syntax-highlighter/dist/esm/prism'),\n  () => import(/* webpackChunkName: \"prism-atom-dark\" */ 'react-syntax-highlighter/dist/esm/styles/prism/atom-dark'),\n  () => import(/* webpackChunkName: \"prism-style\" */ 'react-syntax-highlighter/dist/esm/styles/prism/prism'),\n  () => import(/* webpackChunkName: \"rehype-katex\" */ 'rehype-katex'), \n  () => import(/* webpackChunkName: \"katex-css\" */ 'katex/dist/katex.min.css'), \n  () => import(/* webpackChunkName: \"remark-emoji\" */ 'remark-emoji'),\n  () => import(/* webpackChunkName: \"remark-math\" */ 'remark-math'),\n];\n\n// Phase 2: Model Selector Components\nexport const modelSelectorImports = [\n  () => import(/* webpackChunkName: \"model-dropdown\" */ '../components/models/ModelDropdown'),\n  () => import(/* webpackChunkName: \"model-item\" */ '../components/models/ModelItem'),\n  () => import(/* webpackChunkName: \"model-search\" */ '../components/models/ModelSearch'),\n  () => import(/* webpackChunkName: \"model-selector-button\" */ '../components/models/ModelSelectorButton')\n];\n\n// Removed preloadFormattingComponents and preloadFormattingComponentsIdle functions\n// Loading logic will be handled directly in App.js\n\n// Keep performance monitoring utilities if they are used elsewhere,\n// but the specific measurement logic tied to the removed functions is gone.\n// Export constants if needed elsewhere\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES };\n\n// Example of how you might export all imports if needed elsewhere,\n// but individual phase arrays are likely more useful now.\nconst formattingUtils = {\n  basicFormattingImports,\n  advancedFormattingImports,\n  modelSelectorImports\n};\n\nexport default formattingUtils; ","import { useCallback } from 'react';\nimport { useChat } from '../contexts/ChatContext';\nimport { useModel } from '../contexts/ModelContext';\nimport { useSettings } from '../contexts/SettingsContext';\n\n// Helper to generate unique IDs\nconst generateUniqueId = () => {\n  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n};\n\n/**\n * Custom Hook for Chat Container Logic\n * Encapsulates state management, API calls, and event handlers \n * related to the chat interface.\n */\nexport const useChatLogic = () => {\n  const { \n    chatHistory, \n    isWaitingForResponse, \n    error,\n    metrics,\n    submitMessage,\n    resetChat, \n    downloadChatHistory \n  } = useChat();\n  \n  const { selectedModel } = useModel();\n  const { settings } = useSettings();\n  \n  // Enhanced function to handle sending messages, including edits\n  const handleSendMessage = useCallback(async (message, editedMessage = null) => {\n    const isEditing = !!editedMessage;\n    \n    // Handle both string and array payloads for content validation\n    const messageContent = Array.isArray(message) \n      ? message.map(part => part.type === 'text' ? part.text : '').join(' ').trim()\n      : message;\n\n    if (!messageContent && !Array.isArray(message)) return;\n    if (!selectedModel) return;\n    \n    try {\n      if (isEditing) {\n        // Get or create unique identifier for the message\n        const editMsgId = editedMessage.uniqueId || editedMessage.id || editedMessage.timestamp;\n        \n        // Find the index of the message being edited\n        let editIndex = -1;\n        \n        // First try to find by uniqueId (most reliable)\n        if (editMsgId) {\n          editIndex = chatHistory.findIndex(msg => \n            msg.uniqueId === editMsgId || msg.id === editMsgId\n          );\n        }\n        \n        // If not found yet, try by timestamp as fallback\n        if (editIndex === -1 && editedMessage.timestamp) {\n          editIndex = chatHistory.findIndex(msg => \n            msg.timestamp === editedMessage.timestamp && msg.role === 'user'\n          );\n        }\n        \n        // Last resort: try by content match\n        if (editIndex === -1 && typeof editedMessage.content === 'string') {\n          editIndex = chatHistory.findIndex(msg => \n            typeof msg.content === 'string' && \n            msg.content === editedMessage.content && \n            msg.role === 'user'\n          );\n        }\n        \n        if (editIndex === -1) {\n          console.error(\"Could not find message to edit\");\n          console.log(\"Edited message:\", editedMessage);\n          console.log(\"Chat history:\", chatHistory.map(m => ({ \n            role: m.role, \n            uniqueId: m.uniqueId, \n            timestamp: m.timestamp,\n            contentPreview: typeof m.content === 'string' ? m.content.substring(0, 20) : 'non-string'\n          })));\n          return;\n        }\n        \n        // Ensure the message to be submitted has the correct uniqueId\n        const finalMessage = Array.isArray(message) \n          ? message \n          : { type: 'text', text: message };\n        \n        // Add uniqueId to message\n        if (Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = editMsgId;\n        } else {\n          finalMessage.uniqueId = editMsgId;\n        }\n        \n        // Call the submitMessage function with the truncated history index\n        await submitMessage(finalMessage, editIndex);\n      } else {\n        // For new messages, generate a unique ID\n        const uniqueId = generateUniqueId();\n        \n        // Add uniqueId to new message\n        const finalMessage = Array.isArray(message) \n          ? message.map(part => ({...part, uniqueId}))\n          : message;\n          \n        if (!Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = uniqueId;\n        }\n        \n        // Normal message submission with uniqueId\n        await submitMessage(finalMessage);\n      }\n    } catch (err) {\n      console.error(`Error ${isEditing ? 'editing' : 'submitting'} message:`, err);\n    }\n  }, [selectedModel, submitMessage, chatHistory]);\n\n  // Return values needed by the ChatContainer component\n  return {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics,\n    selectedModel,\n    settings,\n    handleSendMessage,\n    resetChat, \n    downloadChatHistory,\n  };\n}; ","/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","import React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Suspense fallback={\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: '100vh' \n      }}>\n        Loading...\n      </div>\n    }>\n      <App />\n    </Suspense>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","import { useState, useEffect, useMemo } from 'react';\n\n// Define breakpoint constants in a single source of truth\nexport const BREAKPOINTS = {\n  mobile: '640px',\n  tablet: '1023px',\n  desktop: '1024px'\n};\n\n// Cached media query listeners\nconst mediaQueryListeners = new Map();\n\n/**\n * Custom hook that returns true if the current viewport matches the provided media query\n * @param {string} query - Media query string e.g., \"(max-width: 1024px)\"\n * @returns {boolean} - True if the media query matches\n */\nexport const useMediaQuery = (query) => {\n  // Initialize with the current match state\n  const [matches, setMatches] = useState(() => {\n    // Check for window to avoid SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    // Avoid running in SSR context\n    if (typeof window === 'undefined') {\n      return undefined;\n    }\n\n    // Check if we already have a listener for this query\n    if (!mediaQueryListeners.has(query)) {\n      // Create media query list\n      const mediaQueryList = window.matchMedia(query);\n      \n      // Create listener registry for this query\n      mediaQueryListeners.set(query, {\n        mediaQueryList,\n        listeners: new Set()\n      });\n    }\n    \n    const queryData = mediaQueryListeners.get(query);\n    const { mediaQueryList, listeners } = queryData;\n\n    // Initial check\n    setMatches(mediaQueryList.matches);\n\n    // Define listener function\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener to registry\n    listeners.add(listener);\n\n    // Modern browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener);\n      return () => {\n        mediaQueryList.removeEventListener('change', listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    } \n    // Legacy support for older browsers (e.g., IE, older Safari)\n    else if (mediaQueryList.addListener) {\n      mediaQueryList.addListener(listener);\n      return () => {\n        mediaQueryList.removeListener(listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    }\n\n    return undefined;\n  }, [query]);\n\n  return matches;\n};\n\n/**\n * Pre-configured hooks for common breakpoints\n */\nexport const useIsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.mobile})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsTablet = () => {\n  const query = useMemo(() => \n    `(min-width: calc(${BREAKPOINTS.mobile} + 1px)) and (max-width: ${BREAKPOINTS.tablet})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsDesktop = () => {\n  const query = useMemo(() => `(min-width: ${BREAKPOINTS.desktop})`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Get a consistent breakpoint value across the app\n * @returns {{mobile: string, tablet: string, desktop: string}}\n */\nexport const useBreakpoints = () => {\n  return BREAKPOINTS;\n}; ","/* eslint-disable no-restricted-globals */\n// modelProcessor.js\n// Web Worker for processing model list data in the background\n\n/**\n * processModels replicates the logic from ModelContext to transform\n * hierarchical_groups into flat arrays and nested maps.\n */\nfunction processModels(data) {\n  const allModels = [];\n  const experimentalModels = [];\n  const processedModels = {};\n\n  // Helper to normalize a model name\n  const normalizeModelName = (model) => {\n    const name = model.id || '';\n    return name.split('/').pop() || name;\n  };\n\n  data.hierarchical_groups.forEach(providerGroup => {\n    const provider = providerGroup.group_value;\n    if (!providerGroup.children) return;\n\n    providerGroup.children.forEach(typeGroup => {\n      const type = typeGroup.group_value;\n      if (!typeGroup.children) return;\n\n      typeGroup.children.forEach(versionGroup => {\n        const version = versionGroup.group_value;\n        if (!Array.isArray(versionGroup.models)) return;\n\n        versionGroup.models.forEach(model => {\n          let category = 'Chat';\n          const t = (model.type || type || '').toLowerCase();\n          if (t.includes('image')) category = 'Image';\n          else if (t.includes('embedding')) category = 'Embedding';\n\n          const processedModel = {\n            id: model.id,\n            name: model.name || model.display_name || normalizeModelName(model),\n            provider,\n            type: model.type || type,\n            version: model.version || version,\n            category,\n            is_experimental: model.is_experimental,\n            is_multimodal: model.is_multimodal,\n            capabilities: model.capabilities,\n            family: model.family || type,\n            series: model.series || version\n          };\n\n          allModels.push(processedModel);\n          if (model.is_experimental) experimentalModels.push(processedModel);\n\n          // Build nested map: processedModels[category][provider][type]\n          processedModels[category] = processedModels[category] || {};\n          processedModels[category][provider] = processedModels[category][provider] || {};\n          processedModels[category][provider][type] = processedModels[category][provider][type] || [];\n          processedModels[category][provider][type].push(processedModel);\n        });\n      });\n    });\n  });\n\n  return { allModels, processedModels, experimentalModels };\n}\n\n// Listen for messages from main thread\nself.onmessage = ({ data }) => {\n  try {\n    const result = processModels(data);\n    self.postMessage({ ...result });\n  } catch (err) {\n    self.postMessage({ error: err.message });\n  }\n}; ","import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\n// Fetch Firebase configuration from environment variables\nconst firebaseConfig = {\n  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.REACT_APP_FIREBASE_APP_ID,\n  // measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID // Optional\n};\n\nlet app = null;\nlet auth = null;\n\nexport const initializeFirebase = () => {\n  if (app) return { app, auth };\n\n  if (\n    firebaseConfig.apiKey &&\n    firebaseConfig.authDomain &&\n    firebaseConfig.projectId &&\n    firebaseConfig.appId\n  ) {\n    try {\n      app = initializeApp(firebaseConfig);\n      auth = getAuth(app);\n      console.log(\"Firebase initialized successfully.\");\n    } catch (error) {\n      console.error(\"Firebase initialization failed:\", error);\n      app = null;\n      auth = null;\n    }\n  } else {\n    console.warn(\n      \"Firebase configuration environment variables are missing. \" +\n      \"Please set REACT_APP_FIREBASE_API_KEY, REACT_APP_FIREBASE_AUTH_DOMAIN, \" +\n      \"REACT_APP_FIREBASE_PROJECT_ID, and REACT_APP_FIREBASE_APP_ID in your .env file.\"\n    );\n  }\n  \n  return { app, auth };\n};\n\nexport const getFirebaseAuth = () => {\n  if (!auth) {\n    const { auth: newAuth } = initializeFirebase();\n    return newAuth;\n  }\n  return auth;\n};\n\nexport const getFirebaseApp = () => {\n  if (!app) {\n    const { app: newApp } = initializeFirebase();\n    return newApp;\n  }\n  return app;\n}; ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; "],"names":["basicFormattingImports","advancedFormattingImports","modelSelectorImports","useChatLogic","chatHistory","isWaitingForResponse","error","metrics","submitMessage","resetChat","downloadChatHistory","useChat","selectedModel","useModel","settings","useSettings","handleSendMessage","useCallback","async","message","editedMessage","arguments","length","undefined","isEditing","Array","isArray","map","part","type","text","join","trim","editMsgId","uniqueId","id","timestamp","editIndex","findIndex","msg","role","content","finalMessage","Date","now","Math","random","toString","substring","err","PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","Set","measures","window","trackPaintMetrics","PerformanceObserver","entries","getEntries","forEach","entry","markName","name","performance","mark","add","measureName","measure","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clear","clearMarks","clearMeasures","logMetrics","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","ReactDOM","document","getElementById","render","_jsx","React","children","Suspense","fallback","style","display","justifyContent","alignItems","height","App","reportWebVitals","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","waitingServiceWorker","waiting","event","target","postMessage","useCacheToggle","cacheEnabled","setCacheEnabled","useLocalStorage","clearModelCache","localStorage","removeItem","toggleCache","enabled","newValue","refreshModels","useEffect","originalFunc","isCacheValid","cache","getItem","allModels","processedModels","experimentalModels","BREAKPOINTS","mobile","tablet","desktop","mediaQueryListeners","Map","useMediaQuery","query","matches","setMatches","useState","matchMedia","has","mediaQueryList","set","listeners","queryData","listener","removeEventListener","delete","size","addListener","removeListener","useIsDesktop","useMemo","self","onmessage","data","result","normalizeModelName","model","split","pop","hierarchical_groups","providerGroup","provider","group_value","typeGroup","versionGroup","version","models","category","t","toLowerCase","includes","processedModel","display_name","is_experimental","is_multimodal","capabilities","family","series","push","processModels","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","app","auth","initializeFirebase","initializeApp","getAuth","getFirebaseAuth","newAuth","getFirebaseApp","newApp","key","initialValue","initialValueRef","useRef","storedValue","setStoredValue","item","JSON","parse","current","setValue","value","valueToStore","setItem","stringify"],"sourceRoot":""}
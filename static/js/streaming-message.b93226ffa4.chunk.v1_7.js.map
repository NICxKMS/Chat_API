{"version":3,"file":"static/js/streaming-message.b93226ffa4.chunk.v1_7.js","mappings":"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","sources":["utils/formatters.js","components/chat/ChatMessage/StreamingMessage.js"],"sourcesContent":["/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  // eslint-disable-next-line no-useless-escape\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","import { useState, useCallback, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport ReactMarkdown from 'react-markdown';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport styles from './ChatMessage.module.css';\nimport atomDark from 'react-syntax-highlighter/dist/esm/styles/prism/atom-dark';\nimport prism from 'react-syntax-highlighter/dist/esm/styles/prism/prism';\nimport { useTheme } from '../../../contexts/ThemeContext';\nimport remarkGfm from 'remark-gfm';\nimport remarkEmoji from 'remark-emoji';\nimport remarkMath from 'remark-math';\nimport rehypeKatex from 'rehype-katex';\nimport 'katex/dist/katex.min.css';\nimport { convertTeXToMathDollars } from '../../../utils/formatters';\n\n// Copy Icon SVG (simple inline version)\nconst CopyIcon = () => (\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"14\" height=\"14\">\n    <path fillRule=\"evenodd\" d=\"M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z\"></path>\n    <path fillRule=\"evenodd\" d=\"M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z\"></path>\n  </svg>\n);\n\n// Check Icon SVG (simple inline version)\nconst CheckIcon = () => (\n  <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"14\" height=\"14\">\n    <path fillRule=\"evenodd\" d=\"M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z\"></path>\n  </svg>\n);\n\n/**\n * StreamingMessage component using react-markdown for rendering the entire content.\n */\nconst StreamingMessage = ({ content, isStreaming }) => {\n  const { isDark } = useTheme();\n  const [copiedCodeMap, setCopiedCodeMap] = useState({}); // Use a map for multiple blocks\n\n  const syntaxTheme = isDark ? atomDark : prism;\n\n  // Handle copy code to clipboard, using index as key\n  const handleCopyCode = useCallback((code, index) => {\n    navigator.clipboard.writeText(code).then(() => {\n      setCopiedCodeMap(prev => ({ ...prev, [index]: true }));\n      setTimeout(() => {\n        setCopiedCodeMap(prev => ({ ...prev, [index]: false }));\n      }, 2000);\n    });\n  }, []);\n\n  // Custom component for rendering code blocks\n  const CodeBlock = useCallback(({ node, inline, className, children, ...props }) => {\n    // Only treat content wrapped in triple backticks as code blocks (ignore indents)\n    const match = /language-(\\w+)/.exec(className || '');\n    const language = match ? match[1] : 'plaintext'; // Default to plaintext if no language class\n    const codeContent = String(children).replace(/\\n$/, ''); // Get code content\n\n    // Use index from node's position if available, fallback to content hash or similar\n    const codeBlockKey = node?.position?.start?.offset ?? codeContent.substring(0, 20); // Example key\n    const isCopied = copiedCodeMap[codeBlockKey];\n\n    return !inline ? (\n      <div className={styles.codeBlockContainer}>\n        <div className={styles.codeHeader}>\n          <span className={styles.language}>{language}</span>\n          <button\n            className={styles.copyButton}\n            onClick={() => handleCopyCode(codeContent, codeBlockKey)}\n            disabled={isCopied}\n          >\n            {isCopied ? (\n              <> <CheckIcon /> Copied! </>\n            ) : (\n              <> <CopyIcon /> Copy </>\n            )}\n          </button>\n        </div>\n        <SyntaxHighlighter\n          style={syntaxTheme}\n          customStyle={{ background: 'transparent' }}\n          language={language}\n          PreTag=\"div\" // Use div instead of pre, SyntaxHighlighter wraps in its own pre\n          className={styles.pre}\n          wrapLines={true} // Consider wrapping lines based on preference\n          {...props}\n        >\n          {codeContent}\n        </SyntaxHighlighter>\n      </div>\n    ) : (\n      // Render inline code with specific styling\n      <code className={`${styles.inlineCode} ${className || ''}`} {...props}>\n        {children}\n      </code>\n    );\n  }, [syntaxTheme, handleCopyCode, copiedCodeMap]);\n\n  // Define components for ReactMarkdown\n  const markdownComponents = useMemo(() => ({\n    code: CodeBlock,\n  }), [CodeBlock]); // CodeBlock is the dependency\n\n  // Apply streaming class based on the passed-in prop\n  const markdownClassName = `${styles.markdown} ${styles.ChatMessage__streamingContent} ${isStreaming ? styles['ChatMessage__streamingContent--streaming'] : ''}`;\n\n  // Use a zero-width space for this purpose.\n  const actualContent = typeof content === 'string' ? content : String(content || '');\n  const contentToRender = !actualContent ? '\\u200B' : convertTeXToMathDollars(actualContent);\n\n  return (\n    <div className={markdownClassName}>\n      <ReactMarkdown\n        remarkPlugins={[remarkGfm, remarkEmoji, remarkMath]}\n        rehypePlugins={[rehypeKatex]}\n        components={markdownComponents}\n        // skipHtml={false}\n      >\n        {contentToRender}\n      </ReactMarkdown>\n    </div>\n  );\n};\n\nStreamingMessage.propTypes = {\n  content: PropTypes.string,\n  isStreaming: PropTypes.bool // Add prop type for isStreaming\n};\n\nexport default StreamingMessage;\n"],"names":["convertTeXToMathDollars","text","combinedRegex","RegExp","result","replace","match","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","undefined","trim","CopyIcon","_jsxs","xmlns","viewBox","width","height","children","_jsx","fillRule","d","CheckIcon","_ref","content","isStreaming","isDark","useTheme","copiedCodeMap","setCopiedCodeMap","useState","syntaxTheme","atomDark","prism","handleCopyCode","useCallback","code","index","navigator","clipboard","writeText","then","prev","setTimeout","CodeBlock","_ref2","_node$position$start$","_node$position","_node$position$start","node","inline","className","props","exec","language","codeContent","String","codeBlockKey","position","start","offset","substring","isCopied","styles","inlineCode","codeBlockContainer","codeHeader","copyButton","onClick","disabled","_Fragment","SyntaxHighlighter","style","customStyle","background","PreTag","pre","wrapLines","markdownComponents","useMemo","markdownClassName","markdown","ChatMessage__streamingContent","actualContent","contentToRender","ReactMarkdown","remarkPlugins","remarkGfm","remarkEmoji","remarkMath","rehypePlugins","rehypeKatex","components"],"sourceRoot":""}
{"version":3,"file":"static/js/vendors-node_modules_extend_index_js-node_modules_inline-style-parser_index_js-node_modules_b-132821.e2fbac8eb0.chunk.v1_9_0.js","mappings":"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","sources":["../node_modules/extend/index.js","../node_modules/comma-separated-tokens/index.js","../node_modules/mdast-util-definitions/lib/index.js","../node_modules/bail/index.js","../node_modules/inline-style-parser/index.js","../node_modules/is-plain-obj/index.js","../node_modules/hast-util-whitespace/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    let tail = node.children[node.children.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: we’ll add `end` later.\n      tail.position = {\n        start: point(token.start)\n      }\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    setData('inReference', true)\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n"],"names":["hasOwn","Object","prototype","hasOwnProperty","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","call","isPlainObject","obj","key","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","options","name","enumerable","configurable","value","newValue","writable","getProperty","module","exports","extend","src","copy","copyIsArray","clone","arguments","i","length","deep","parse","tokens","input","String","index","indexOf","start","end","token","slice","trim","push","stringify","values","settings","join","padRight","padLeft","own","definitions","tree","cache","create","type","Error","visit","definition","id","clean","identifier","toUpperCase","bail","error","COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","EMPTY_STRING","str","replace","style","TypeError","lineno","column","updatePosition","lines","match","lastIndexOf","position","line","node","Position","whitespace","this","source","content","errorsList","msg","err","reason","filename","silent","re","m","exec","comments","rules","c","comment","pos","charAt","declaration","prop","val","ret","property","decl","decls","declarations","getPrototypeOf","Symbol","toStringTag","iterator","thing","emptyOptions","one","includeImageAlt","includeHtml","Boolean","alt","all","children","result","fromMarkdown","encoding","undefined","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","label","title","url","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","listItem","spread","_spread","checked","listItemValue","getData","stack","Number","parseInt","sliceSerialize","setData","listOrdered","list","listUnordered","paragraph","reference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","depth","onexitdata","characterEscapeValue","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","decodeNumericCharacterReference","decodeNamedCharacterReference","tail","pop","point","resume","codeFencedFence","lang","meta","normalizeIdentifier","toLowerCase","onexithardbreak","referenceType","fragment","labelText","string","ancestor","decodeString","lineEnding","context","includes","resource","setextHeadingLineSequence","charCodeAt","setextHeadingText","configure","mdastExtensions","events","tokenStack","listStack","prepareList","handler","assign","defaultOnError","offset","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","splice","and","errorHandler","onExitError","open","stringifyPosition","ordered","compiler","postprocess","document","write","preprocess","d","combined","extensions","extension","right","left"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor.refractor-a3fa2601.c4d5a56bf9.chunk.v1_8_5.js","mappings":"iHAKA,SAASA,EAAOC,GACdA,EAAMC,UAAUF,OAAS,CACvBG,QAAS,CACPC,QAAS,8BACTC,QAAQ,GAEVC,OAAQ,CACNF,QAAS,iBACTC,QAAQ,GAEVE,QAAS,CAEPH,QACE,uHACFC,QAAQ,EACRG,OAAQ,CACN,kBAAmB,CACjBJ,QAAS,6BACTK,YAAY,EACZJ,QAAQ,EACRG,OAAQ,MAEVE,OAAQ,CACNN,QAAS,kBACTC,QAAQ,GAEVM,YAAa,eACb,cAAe,YACfC,KAAM,eAGVC,MAAO,CACLT,QAAS,4BACTC,QAAQ,GAEVS,IAAK,CACHV,QACE,uHACFC,QAAQ,EACRG,OAAQ,CACNM,IAAK,CACHV,QAAS,iBACTI,OAAQ,CACNG,YAAa,QACbI,UAAW,iBAGf,eAAgB,GAChB,aAAc,CACZX,QAAS,qCACTI,OAAQ,CACNG,YAAa,CACX,CACEP,QAAS,KACTY,MAAO,eAET,SAINL,YAAa,OACb,YAAa,CACXP,QAAS,YACTI,OAAQ,CACNO,UAAW,mBAKnBE,OAAQ,CACN,CACEb,QAAS,kBACTY,MAAO,gBAET,uBAGJf,EAAMC,UAAUF,OAAY,IAAEQ,OAAO,cAAcA,OAAe,OAChEP,EAAMC,UAAUF,OAAe,OACjCC,EAAMC,UAAUF,OAAgB,QAAEQ,OAAO,mBAAmBA,OAC1DP,EAAMC,UAAUF,OAClBC,EAAMiB,MAAMC,IAAI,QAAQ,SAAUC,GACf,WAAbA,EAAIC,OACND,EAAIE,WAAkB,MAAIF,EAAIG,QAAQC,MAAMC,QAAQ,QAAS,KAEjE,IACAC,OAAOC,eAAe1B,EAAMC,UAAUF,OAAOc,IAAK,aAAc,CAY9DU,MAAO,SAAoBI,EAASC,GAClC,IAAIC,EAAsB,CAAC,EAC3BA,EAAoB,YAAcD,GAAQ,CACxCzB,QAAS,oCACTK,YAAY,EACZD,OAAQP,EAAMC,UAAU2B,IAE1BC,EAA2B,MAAI,uBAC/B,IAAItB,EAAS,CACX,iBAAkB,CAChBJ,QAAS,4BACTI,OAAQsB,IAGZtB,EAAO,YAAcqB,GAAQ,CAC3BzB,QAAS,UACTI,OAAQP,EAAMC,UAAU2B,IAE1B,IAAIE,EAAM,CAAC,EACXA,EAAIH,GAAW,CACbxB,QAAS4B,OACP,wFAAwFC,OAAOR,QAC7F,OACA,WACE,OAAOG,CACT,IAEF,KAEFnB,YAAY,EACZJ,QAAQ,EACRG,OAAQA,GAEVP,EAAMC,UAAUgC,aAAa,SAAU,QAASH,EAClD,IAEFL,OAAOC,eAAe1B,EAAMC,UAAUF,OAAOc,IAAK,eAAgB,CAYhEU,MAAO,SAAUW,EAAUN,GACzB5B,EAAMC,UAAUF,OAAOc,IAAIN,OAAO,gBAAgB4B,KAAK,CACrDhC,QAAS4B,OACP,aAAaC,OACX,MACAE,EACA,IACA,iDAAiDF,OACnD,KAEFxB,YAAY,EACZD,OAAQ,CACN,YAAa,WACb,aAAc,CACZJ,QAAS,WACTI,OAAQ,CACNgB,MAAO,CACLpB,QAAS,yCACTK,YAAY,EACZO,MAAO,CAACa,EAAM,YAAcA,GAC5BrB,OAAQP,EAAMC,UAAU2B,IAE1BlB,YAAa,CACX,CACEP,QAAS,KACTY,MAAO,eAET,WAMZ,IAEFf,EAAMC,UAAUmC,KAAOpC,EAAMC,UAAUF,OACvCC,EAAMC,UAAUoC,OAASrC,EAAMC,UAAUF,OACzCC,EAAMC,UAAUqC,IAAMtC,EAAMC,UAAUF,OACtCC,EAAMC,UAAUsC,IAAMvC,EAAMC,UAAUuC,OAAO,SAAU,CAAC,GACxDxC,EAAMC,UAAUwC,KAAOzC,EAAMC,UAAUsC,IACvCvC,EAAMC,UAAUyC,KAAO1C,EAAMC,UAAUsC,IACvCvC,EAAMC,UAAU0C,IAAM3C,EAAMC,UAAUsC,GACxC,CA/LAK,EAAOC,QAAU9C,EACjBA,EAAO+C,YAAc,SACrB/C,EAAOgD,QAAU,CAAC,OAAQ,SAAU,MAAO,MAAO,OAAQ,OAAQ,M,YCClE,SAASC,EAAiBhD,IACvB,SAAWA,GAQV,SAASiD,EAAeC,EAAUC,GAChC,MAAO,MAAQD,EAASE,cAAgBD,EAAQ,KAClD,CACA1B,OAAO4B,iBAAkBrD,EAAMC,UAAU,qBAAuB,CAAC,EAAI,CACnEqD,kBAAmB,CAYjB/B,MAAO,SAAUJ,EAAK+B,EAAUK,EAAoBC,GAClD,GAAIrC,EAAI+B,WAAaA,EAArB,CAGA,IAAIO,EAActC,EAAIsC,WAAa,GACnCtC,EAAIuC,KAAOvC,EAAIuC,KAAKlC,QAAQ+B,GAAoB,SAAUI,GACxD,GAA6B,mBAAlBH,IAAiCA,EAAcG,GACxD,OAAOA,EAIT,IAFA,IACIC,EADAC,EAAIJ,EAAWK,QAIhB,IADD3C,EAAIuC,KAAKK,QAASH,EAAcX,EAAeC,EAAUW,OAGvDA,EAGJ,OADAJ,EAAWI,GAAKF,EACTC,CACT,IACAzC,EAAI6C,QAAUhE,EAAMC,UAAUF,MAjB9B,CAkBF,GAEFkE,qBAAsB,CAOpB1C,MAAO,SAAUJ,EAAK+B,GACpB,GAAI/B,EAAI+B,WAAaA,GAAa/B,EAAIsC,WAAtC,CAGAtC,EAAI6C,QAAUhE,EAAMC,UAAUiD,GAC9B,IAAIgB,EAAI,EACJC,EAAO1C,OAAO0C,KAAKhD,EAAIsC,aAC3B,SAASW,EAAWC,GAClB,IAAK,IAAIR,EAAI,EAAGA,EAAIQ,EAAOP,UAErBI,GAAKC,EAAKL,QAFmBD,IAAK,CAKtC,IAAIS,EAAQD,EAAOR,GACnB,GACmB,iBAAVS,GACNA,EAAMhD,SAAoC,iBAAlBgD,EAAMhD,QAC/B,CACA,IAAIiD,EAAIJ,EAAKD,GACTM,EAAIrD,EAAIsC,WAAWc,GACnBE,EAAqB,iBAAVH,EAAqBA,EAAQA,EAAMhD,QAC9CsC,EAAcX,EAAeC,EAAUqB,GACvCpB,EAAQsB,EAAEV,QAAQH,GACtB,GAAIT,GAAS,EAAG,GACZe,EACF,IAAIQ,EAASD,EAAEE,UAAU,EAAGxB,GACxByB,EAAS,IAAI5E,EAAM6E,MACrB3B,EACAlD,EAAM8E,SAASN,EAAGrD,EAAI6C,SACtB,YAAcd,EACdsB,GAEEO,EAAQN,EAAEE,UAAUxB,EAAQS,EAAYE,QACxCkB,EAAc,GACdN,GACFM,EAAY7C,KAAK8C,MAAMD,EAAaZ,EAAW,CAACM,KAElDM,EAAY7C,KAAKyC,GACbG,GACFC,EAAY7C,KAAK8C,MAAMD,EAAaZ,EAAW,CAACW,KAE7B,iBAAVT,EACTD,EAAOa,OAAOD,MAAMZ,EAAQ,CAACR,EAAG,GAAGsB,OAAOH,IAE1CV,EAAMhD,QAAU0D,CAEpB,CACF,MACEV,EAAMhD,SAGN8C,EAAWE,EAAMhD,QAErB,CACA,OAAO+C,CACT,CACAD,CAAWjD,EAAIkD,OArDf,CAsDF,IAGL,CAlHA,CAkHErE,EACL,CAvHA4C,EAAOC,QAAUG,EACjBA,EAAiBF,YAAc,mBAC/BE,EAAiBD,QAAU,E,YCC3B,SAASqC,EAAUpF,IAChB,SAAWA,GACV,IAAIqF,EACF,2SACFrF,EAAMC,UAAUmF,UAAY,CAC1BlF,QAAS,CACPC,QAAS,8BACTC,QAAQ,GAEVK,OAAQ,CACNN,QAAS,iDACTK,YAAY,EACZJ,QAAQ,GAEVkF,KAAM,CACJnF,QAAS,4BACTC,QAAQ,EACRW,MAAO,UAET,gBAAiB,CACfZ,QAAS4B,OACP,OACG,IAAIC,OACH,IACA,mBAAmBA,OACnB,IACA,6FACGA,OANP,cASEqD,EAASrD,OACT,IACA,cAAcA,OAXhB,kBAcIqD,EAASrD,OACT,IACA,SAASA,OACT,IACA,YAAYA,OACZ,IACA,aAAaA,OACf,KACF,MAEFxB,YAAY,EACZJ,QAAQ,EACRW,MAAO,YAET,sBAAuB,CACrBZ,QAAS,+BACTK,YAAY,EACZO,MAAO,YAETwE,SAAU,CACRpF,QAAS,oBACTY,MAAO,aAETyE,QAASH,EACTI,QAAS,qBACTC,KAAM,CACJvF,QACE,sGACFK,YAAY,EACZO,MAAO,UAET4E,OAAQ,CACN,CACExF,QACE,wFACFK,YAAY,GAEd,gBAEFoF,SAAU,0DACVC,MAAO,CACL1F,QAAS,+DACTY,MAAO,YAET+E,SAAU,6BACVpF,YAAa,8BAEhB,CAjFA,CAiFEV,EACL,CAtFA4C,EAAOC,QAAUuC,EACjBA,EAAUtC,YAAc,YACxBsC,EAAUrC,QAAU,E,YCCpB,SAASgD,EAAS/F,GAChBA,EAAMC,UAAU8F,SAAW,CACzB7F,QAAS,CACPC,QAAS,6CACTK,YAAY,GAEdC,OAAQ,CACNN,QAAS,iDACTC,QAAQ,GAEV,iBAAkB,CAChBD,QAAS,gCACTY,MAAO,WAETiF,OAAQ,CACN7F,QAAS,8CACTY,MAAO,SACPR,OAAQ,CACN0F,SAAU,wCAGdA,SAAU,wDAEVT,QACE,6HACFU,SAAU,CACR/F,QACE,wQACFK,YAAY,GAEdsF,SAAU,uBACVpF,YAAa,WAEjB,CApCAkC,EAAOC,QAAUkD,EACjBA,EAASjD,YAAc,WACvBiD,EAAShD,QAAU,E,YCCnB,SAASoD,EAASnG,IACf,SAAWA,GAEV,IAAIoG,EAAQ,2CAA2CpE,OAWvD,SAASqE,EAAalG,GAIpB,OAHAA,EAAUA,EAAQqB,QAAQ,YAAY,WACpC,OAAO4E,CACT,IACOrE,OAAO,0BAA0BC,OAAS,MAAQ7B,EAAU,IACrE,CACA,IAAImG,EAAY,4DACbtE,OACCuE,EACF,+CAA+CvE,OAAOR,QACpD,OACA,WACE,OAAO8E,CACT,IAEAE,EACF,sEACGxE,OACLhC,EAAMC,UAAUkG,SAAWnG,EAAMC,UAAUuC,OAAO,SAAU,CAAC,GAC7DxC,EAAMC,UAAUgC,aAAa,WAAY,SAAU,CACjD,qBAAsB,CACpB9B,QAAS,kDACTK,YAAY,EACZJ,QAAQ,EACRG,OAAQ,CACNG,YAAa,YACb,eAAgB,CACdP,QAAS,iBACTY,MAAO,CAAC,OAAQ,iBAChBR,OAAQP,EAAMC,UAAUwG,QAI9BC,WAAY,CAEVvG,QAAS,kBACTY,MAAO,eAET4F,MAAO,CACLxG,QAAS4B,OACP,IAAMwE,EAAWC,EAAY,MAAQD,EAAW,KAChD,KAEFhG,OAAQ,CACN,kBAAmB,CACjBJ,QAAS4B,OACP,KAAOwE,EAAWC,EAAY,OAASD,EAAW,OAEpD/F,YAAY,EACZD,OAAQ,CACN,aAAc,CACZJ,QAAS4B,OAAOuE,GAChB/F,OAAQP,EAAMC,UAAUkG,UAE1BzF,YAAa,OAGjB,aAAc,CACZP,QAAS4B,OAAO,KAAOwE,EAAW,IAAMC,EAAY,KACpDhG,YAAY,EACZD,OAAQ,CACNG,YAAa,iBAGjB,mBAAoB,CAClBP,QAAS4B,OAAO,IAAMwE,EAAW,KACjChG,OAAQ,CACN,eAAgB,CACdJ,QAAS4B,OAAOuE,GAChBvF,MAAO,YACPR,OAAQP,EAAMC,UAAUkG,UAE1BzF,YAAa,SAKrBgD,KAAM,CACJ,CAEEvD,QACE,uFACFK,YAAY,EACZO,MAAO,WAET,CAIEZ,QAAS,qBACTC,QAAQ,EACRG,OAAQ,CACN,aAAc,CACZJ,QAAS,qDACTK,YAAY,GAEd,gBAAiB,CACfL,QAAS,WACTK,YAAY,GAEdE,YAAa,SAInBkG,MAAO,CACL,CAKEzG,QAAS,0CACTY,MAAO,YACPR,OAAQ,CACNG,YAAa,cAGjB,CAGEP,QAAS,aACTK,YAAY,EACZO,MAAO,YACPR,OAAQ,CACNG,YAAa,aAInBmG,GAAI,CAKF1G,QAAS,wCACTK,YAAY,EACZO,MAAO,eAET+F,KAAM,CAKJ3G,QAAS,mCACTK,YAAY,EACZO,MAAO,eAET,gBAAiB,CAKfZ,QACE,qHACFI,OAAQ,CACN0F,SAAU,CACR9F,QAAS,gBACTK,YAAY,GAEdC,OACE,+DACFC,YAAa,kBAEfK,MAAO,OAETgG,KAAM,CAIJ5G,QAASkG,EACP,kGACGrE,QAELxB,YAAY,EACZJ,QAAQ,EACRG,OAAQ,CACNe,QAAS,CACPnB,QAAS,sBACTK,YAAY,EACZD,OAAQ,CAAC,GAEXG,YAAa,YAGjBsG,OAAQ,CAIN7G,QAASkG,EACP,kGACGrE,QAELxB,YAAY,EACZJ,QAAQ,EACRG,OAAQ,CACNe,QAAS,CACPnB,QAAS,oBACTK,YAAY,EACZD,OAAQ,CAAC,GAEXG,YAAa,SAGjBuG,OAAQ,CAIN9G,QAASkG,EAAa,2BAA2BrE,QACjDxB,YAAY,EACZJ,QAAQ,EACRG,OAAQ,CACNe,QAAS,CACPnB,QAAS,uBACTK,YAAY,EACZD,OAAQ,CAAC,GAEXG,YAAa,QAGjB,eAAgB,CAGdP,QACE,mEACFK,YAAY,EACZJ,QAAQ,EACRW,MAAO,CAAC,OAAQ,YAElBmG,IAAK,CAIH/G,QAASkG,EACP,mGACGrE,QAELxB,YAAY,EACZJ,QAAQ,EACRG,OAAQ,CACNuF,SAAU,KACVxE,QAAS,CACPnB,QAAS,oBACTK,YAAY,EACZD,OAAQ,CAAC,GAEX0F,SAAU,CACR9F,QAAS,6BACTK,YAAY,GAEd0G,IAAK,CACH/G,QAAS,iBACTK,YAAY,GAEdC,OAAQ,CACNN,QAAS,oCACTK,YAAY,OAKnB,CAAC,MAAO,OAAQ,SAAU,UAAU2G,SAAQ,SAAU7C,GACpD,CAAC,MAAO,OAAQ,SAAU,SAAU,gBAAgB6C,SAAQ,SAC3D5G,GAEI+D,IAAU/D,IACZP,EAAMC,UAAUkG,SAAS7B,GAAO/D,OAAOe,QAAQf,OAAOA,GACpDP,EAAMC,UAAUkG,SAAS5F,GAE/B,GACF,IACAP,EAAMiB,MAAMC,IAAI,kBAAkB,SAAUC,GACrB,aAAjBA,EAAI+B,UAA4C,OAAjB/B,EAAI+B,UAGvC,SAASkB,EAAWC,GAClB,GAAKA,GAA4B,iBAAXA,EAGtB,IAAK,IAAIR,EAAI,EAAGuD,EAAI/C,EAAOP,OAAQD,EAAIuD,EAAGvD,IAAK,CAC7C,IAAIS,EAAQD,EAAOR,GACnB,GAAmB,SAAfS,EAAMlD,KAAV,CAiBA,IAAIiG,EAAW/C,EAAMhD,QAAQ,GACzBgG,EAAYhD,EAAMhD,QAAQ,GAC9B,GACE+F,GACAC,GACkB,kBAAlBD,EAASjG,MACU,eAAnBkG,EAAUlG,MACkB,iBAArBiG,EAAS/F,QAChB,CAGA,IAAIM,EAAOyF,EAAS/F,QACjBE,QAAQ,OAAQ,SAChBA,QAAQ,UAAW,MAElBT,EAAQ,aADZa,GAAQ,eAAe2F,KAAK3F,IAAS,CAAC,KAAK,GAAG4F,eAEzCF,EAAUvG,MAEuB,iBAApBuG,EAAUvG,MAC1BuG,EAAUvG,MAAQ,CAACuG,EAAUvG,MAAOA,GAEpCuG,EAAUvG,MAAMoB,KAAKpB,GAJrBuG,EAAUvG,MAAQ,CAACA,EAMvB,CArCA,MAFEqD,EAAWE,EAAMhD,QAwCrB,CACF,CACA8C,CAAWjD,EAAIkD,OACjB,IACArE,EAAMiB,MAAMC,IAAI,QAAQ,SAAUC,GAChC,GAAiB,eAAbA,EAAIC,KAAR,CAIA,IADA,IAAIiG,EAAW,GACNxD,EAAI,EAAGuD,EAAIjG,EAAIsG,QAAQ3D,OAAQD,EAAIuD,EAAGvD,IAAK,CAClD,IAAI6D,EAAMvG,EAAIsG,QAAQ5D,GAClBF,EAAQ,gBAAgB4D,KAAKG,GACjC,GAAI/D,EAAO,CACT0D,EAAW1D,EAAM,GACjB,KACF,CACF,CACA,IAiDmBvB,EAjDf4B,EAAUhE,EAAMC,UAAUoH,GAC9B,GAAKrD,EAoBH7C,EAAIG,QAAUtB,EAAM2H,WA4BHvF,EA3BHjB,EAAIG,QAAQC,MA6BjBa,EAAKZ,QAAQoG,EAAY,IACxBpG,QAAQ,iCAAiC,SAAUqG,EAAGnE,GAG9D,IAAInC,EADN,GAAgB,OADhBmC,EAAOA,EAAK8D,eACH,GAOP,OAJEjG,EADc,MAAZmC,EAAK,GACCoE,SAASpE,EAAKqE,MAAM,GAAI,IAExBC,OAAOtE,EAAKqE,MAAM,IAErBE,EAAc1G,GAErB,IAAI2G,EAAQC,EAAmBzE,GAC/B,OAAIwE,GAGGL,CAEX,KA9CI7D,EACAqD,QAtBF,GAAIA,GAAyB,SAAbA,GAAuBrH,EAAMoI,QAAQC,WAAY,CAC/D,IAAIC,EACF,OACA,IAAIC,MAAOC,UACX,IACAC,KAAKC,MAAsB,KAAhBD,KAAKE,UAClBxH,EAAIE,WAAe,GAAIiH,EACvBtI,EAAMoI,QAAQC,WAAWO,cAAcvB,GAAU,WAC/C,IAAIwB,EAAMC,SAASC,eAAeT,GAC9BO,IACFA,EAAIG,UAAYhJ,EAAM2H,UACpBkB,EAAII,YACJjJ,EAAMC,UAAUoH,GAChBA,GAGN,GACF,CA7BF,CAqCF,IACA,IAAIO,EAAa7F,OAAO/B,EAAMC,UAAUF,OAAOc,IAAIV,QAAQ6B,OAAQ,MAQ/DmG,EAAqB,CACvBe,IAAK,IACLC,GAAI,IACJC,GAAI,IACJC,KAAM,KAEJpB,EAAgBqB,OAAOrB,eAAiBqB,OAAOC,aA8BnDvJ,EAAMC,UAAUuJ,GAAKxJ,EAAMC,UAAUkG,QACtC,CAtaA,CAsaEnG,EACL,CA3aA4C,EAAOC,QAAUsD,EACjBA,EAASrD,YAAc,WACvBqD,EAASpD,QAAU,CAAC,K,YCCpB,SAAS0G,EAAMzJ,GACbA,EAAMC,UAAUwJ,MAAQ,CACtBC,OAAQ,CACNvJ,QACE,2GACFK,YAAY,EACZJ,QAAQ,GAEVF,QAAS,CACPC,QAAS,0BACTC,QAAQ,GAEVK,OAAQ,CACNN,QAAS,kCACTK,YAAY,EACZJ,QAAQ,GAGVoF,QACE,ggBACFC,QAAS,qBACTkE,UAAW,CACTxJ,QAAS,uBACTY,MAAO,cAETmF,SAAU,wBACVP,OAAQ,CACNxF,QACE,uFACFK,YAAY,GAEdsF,SAAU,0BACVpF,YAAa,kBAEjB,CArCAkC,EAAOC,QAAU4G,EACjBA,EAAM3G,YAAc,QACpB2G,EAAM1G,QAAU,E,YCChB,SAAS6G,EAAO5J,GACdA,EAAMC,UAAU2J,OAAS,CACvB1J,QAAS,CAAC,iBAAkB,OAC5BO,OAAQ,CACNN,QAAS,uBACTC,QAAQ,GAGVuF,OAAQ,iEACRH,QACE,8HACFU,SAAU,uBACVJ,SAAU,0CACVpF,YAAa,uBAEjB,CAlBAkC,EAAOC,QAAU+G,EACjBA,EAAO9G,YAAc,SACrB8G,EAAO7G,QAAU,E","sources":["../node_modules/refractor/lang/markup.js","../node_modules/refractor/lang/markup-templating.js","../node_modules/refractor/lang/maxscript.js","../node_modules/refractor/lang/makefile.js","../node_modules/refractor/lang/markdown.js","../node_modules/refractor/lang/magma.js","../node_modules/refractor/lang/matlab.js"],"sourcesContent":["'use strict'\n\nmodule.exports = markup\nmarkup.displayName = 'markup'\nmarkup.aliases = ['html', 'mathml', 'svg', 'xml', 'ssml', 'atom', 'rss']\nfunction markup(Prism) {\n  Prism.languages.markup = {\n    comment: {\n      pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n      greedy: true\n    },\n    prolog: {\n      pattern: /<\\?[\\s\\S]+?\\?>/,\n      greedy: true\n    },\n    doctype: {\n      // https://www.w3.org/TR/xml/#NT-doctypedecl\n      pattern:\n        /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n      greedy: true,\n      inside: {\n        'internal-subset': {\n          pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n          lookbehind: true,\n          greedy: true,\n          inside: null // see below\n        },\n        string: {\n          pattern: /\"[^\"]*\"|'[^']*'/,\n          greedy: true\n        },\n        punctuation: /^<!|>$|[[\\]]/,\n        'doctype-tag': /^DOCTYPE/i,\n        name: /[^\\s<>'\"]+/\n      }\n    },\n    cdata: {\n      pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n      greedy: true\n    },\n    tag: {\n      pattern:\n        /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n      greedy: true,\n      inside: {\n        tag: {\n          pattern: /^<\\/?[^\\s>\\/]+/,\n          inside: {\n            punctuation: /^<\\/?/,\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        },\n        'special-attr': [],\n        'attr-value': {\n          pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n          inside: {\n            punctuation: [\n              {\n                pattern: /^=/,\n                alias: 'attr-equals'\n              },\n              /\"|'/\n            ]\n          }\n        },\n        punctuation: /\\/?>/,\n        'attr-name': {\n          pattern: /[^\\s>\\/]+/,\n          inside: {\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        }\n      }\n    },\n    entity: [\n      {\n        pattern: /&[\\da-z]{1,8};/i,\n        alias: 'named-entity'\n      },\n      /&#x?[\\da-f]{1,8};/i\n    ]\n  }\n  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n    Prism.languages.markup['entity']\n  Prism.languages.markup['doctype'].inside['internal-subset'].inside =\n    Prism.languages.markup // Plugin to make entity title show the real entity, idea by Roman Komarov\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type === 'entity') {\n      env.attributes['title'] = env.content.value.replace(/&amp;/, '&')\n    }\n  })\n  Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n    /**\n     * Adds an inlined language to markup.\n     *\n     * An example of an inlined language is CSS with `<style>` tags.\n     *\n     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addInlined('style', 'css');\n     */\n    value: function addInlined(tagName, lang) {\n      var includedCdataInside = {}\n      includedCdataInside['language-' + lang] = {\n        pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n        lookbehind: true,\n        inside: Prism.languages[lang]\n      }\n      includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i\n      var inside = {\n        'included-cdata': {\n          pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n          inside: includedCdataInside\n        }\n      }\n      inside['language-' + lang] = {\n        pattern: /[\\s\\S]+/,\n        inside: Prism.languages[lang]\n      }\n      var def = {}\n      def[tagName] = {\n        pattern: RegExp(\n          /(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(\n            /__/g,\n            function () {\n              return tagName\n            }\n          ),\n          'i'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: inside\n      }\n      Prism.languages.insertBefore('markup', 'cdata', def)\n    }\n  })\n  Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n    /**\n     * Adds an pattern to highlight languages embedded in HTML attributes.\n     *\n     * An example of an inlined language is CSS with `style` attributes.\n     *\n     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addAttribute('style', 'css');\n     */\n    value: function (attrName, lang) {\n      Prism.languages.markup.tag.inside['special-attr'].push({\n        pattern: RegExp(\n          /(^|[\"'\\s])/.source +\n            '(?:' +\n            attrName +\n            ')' +\n            /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n          'i'\n        ),\n        lookbehind: true,\n        inside: {\n          'attr-name': /^[^\\s=]+/,\n          'attr-value': {\n            pattern: /=[\\s\\S]+/,\n            inside: {\n              value: {\n                pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                lookbehind: true,\n                alias: [lang, 'language-' + lang],\n                inside: Prism.languages[lang]\n              },\n              punctuation: [\n                {\n                  pattern: /^=/,\n                  alias: 'attr-equals'\n                },\n                /\"|'/\n              ]\n            }\n          }\n        }\n      })\n    }\n  })\n  Prism.languages.html = Prism.languages.markup\n  Prism.languages.mathml = Prism.languages.markup\n  Prism.languages.svg = Prism.languages.markup\n  Prism.languages.xml = Prism.languages.extend('markup', {})\n  Prism.languages.ssml = Prism.languages.xml\n  Prism.languages.atom = Prism.languages.xml\n  Prism.languages.rss = Prism.languages.xml\n}\n","'use strict'\n\nmodule.exports = markupTemplating\nmarkupTemplating.displayName = 'markupTemplating'\nmarkupTemplating.aliases = []\nfunction markupTemplating(Prism) {\n  ;(function (Prism) {\n    /**\n     * Returns the placeholder for the given language id and index.\n     *\n     * @param {string} language\n     * @param {string|number} index\n     * @returns {string}\n     */\n    function getPlaceholder(language, index) {\n      return '___' + language.toUpperCase() + index + '___'\n    }\n    Object.defineProperties((Prism.languages['markup-templating'] = {}), {\n      buildPlaceholders: {\n        /**\n         * Tokenize all inline templating expressions matching `placeholderPattern`.\n         *\n         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n         * `true` will be replaced.\n         *\n         * @param {object} env The environment of the `before-tokenize` hook.\n         * @param {string} language The language id.\n         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n         * @param {(match: string) => boolean} [replaceFilter]\n         */\n        value: function (env, language, placeholderPattern, replaceFilter) {\n          if (env.language !== language) {\n            return\n          }\n          var tokenStack = (env.tokenStack = [])\n          env.code = env.code.replace(placeholderPattern, function (match) {\n            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n              return match\n            }\n            var i = tokenStack.length\n            var placeholder // Check for existing strings\n            while (\n              env.code.indexOf((placeholder = getPlaceholder(language, i))) !==\n              -1\n            ) {\n              ++i\n            } // Create a sparse array\n            tokenStack[i] = match\n            return placeholder\n          }) // Switch the grammar to markup\n          env.grammar = Prism.languages.markup\n        }\n      },\n      tokenizePlaceholders: {\n        /**\n         * Replace placeholders with proper tokens after tokenizing.\n         *\n         * @param {object} env The environment of the `after-tokenize` hook.\n         * @param {string} language The language id.\n         */\n        value: function (env, language) {\n          if (env.language !== language || !env.tokenStack) {\n            return\n          } // Switch the grammar back\n          env.grammar = Prism.languages[language]\n          var j = 0\n          var keys = Object.keys(env.tokenStack)\n          function walkTokens(tokens) {\n            for (var i = 0; i < tokens.length; i++) {\n              // all placeholders are replaced already\n              if (j >= keys.length) {\n                break\n              }\n              var token = tokens[i]\n              if (\n                typeof token === 'string' ||\n                (token.content && typeof token.content === 'string')\n              ) {\n                var k = keys[j]\n                var t = env.tokenStack[k]\n                var s = typeof token === 'string' ? token : token.content\n                var placeholder = getPlaceholder(language, k)\n                var index = s.indexOf(placeholder)\n                if (index > -1) {\n                  ++j\n                  var before = s.substring(0, index)\n                  var middle = new Prism.Token(\n                    language,\n                    Prism.tokenize(t, env.grammar),\n                    'language-' + language,\n                    t\n                  )\n                  var after = s.substring(index + placeholder.length)\n                  var replacement = []\n                  if (before) {\n                    replacement.push.apply(replacement, walkTokens([before]))\n                  }\n                  replacement.push(middle)\n                  if (after) {\n                    replacement.push.apply(replacement, walkTokens([after]))\n                  }\n                  if (typeof token === 'string') {\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement))\n                  } else {\n                    token.content = replacement\n                  }\n                }\n              } else if (\n                token.content\n                /* && typeof token.content !== 'string' */\n              ) {\n                walkTokens(token.content)\n              }\n            }\n            return tokens\n          }\n          walkTokens(env.tokens)\n        }\n      }\n    })\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = maxscript\nmaxscript.displayName = 'maxscript'\nmaxscript.aliases = []\nfunction maxscript(Prism) {\n  ;(function (Prism) {\n    var keywords =\n      /\\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\\b/i\n    Prism.languages.maxscript = {\n      comment: {\n        pattern: /\\/\\*[\\s\\S]*?(?:\\*\\/|$)|--.*/,\n        greedy: true\n      },\n      string: {\n        pattern: /(^|[^\"\\\\@])(?:\"(?:[^\"\\\\]|\\\\[\\s\\S])*\"|@\"[^\"]*\")/,\n        lookbehind: true,\n        greedy: true\n      },\n      path: {\n        pattern: /\\$(?:[\\w/\\\\.*?]|'[^']*')*/,\n        greedy: true,\n        alias: 'string'\n      },\n      'function-call': {\n        pattern: RegExp(\n          '((?:' + // start of line\n            (/^/.source +\n              '|' + // operators and other language constructs\n              /[;=<>+\\-*/^({\\[]/.source +\n              '|' + // keywords as part of statements\n              /\\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\\b/\n                .source) +\n            ')[ \\t]*)' +\n            '(?!' +\n            keywords.source +\n            ')' +\n            /[a-z_]\\w*\\b/.source +\n            '(?=[ \\t]*(?:' + // variable\n            ('(?!' +\n              keywords.source +\n              ')' +\n              /[a-z_]/.source +\n              '|' + // number\n              /\\d|-\\.?\\d/.source +\n              '|' + // other expressions or literals\n              /[({'\"$@#?]/.source) +\n            '))',\n          'im'\n        ),\n        lookbehind: true,\n        greedy: true,\n        alias: 'function'\n      },\n      'function-definition': {\n        pattern: /(\\b(?:fn|function)\\s+)\\w+\\b/i,\n        lookbehind: true,\n        alias: 'function'\n      },\n      argument: {\n        pattern: /\\b[a-z_]\\w*(?=:)/i,\n        alias: 'attr-name'\n      },\n      keyword: keywords,\n      boolean: /\\b(?:false|true)\\b/,\n      time: {\n        pattern:\n          /(^|[^\\w.])(?:(?:(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eEdD][+-]\\d+|[LP])?[msft])+|\\d+:\\d+(?:\\.\\d*)?)(?![\\w.:])/,\n        lookbehind: true,\n        alias: 'number'\n      },\n      number: [\n        {\n          pattern:\n            /(^|[^\\w.])(?:(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eEdD][+-]\\d+|[LP])?|0x[a-fA-F0-9]+)(?![\\w.:])/,\n          lookbehind: true\n        },\n        /\\b(?:e|pi)\\b/\n      ],\n      constant: /\\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\\b/,\n      color: {\n        pattern: /\\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\\b/i,\n        alias: 'constant'\n      },\n      operator: /[-+*/<>=!]=?|[&^?]|#(?!\\()/,\n      punctuation: /[()\\[\\]{}.:,;]|#(?=\\()|\\\\$/m\n    }\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = makefile\nmakefile.displayName = 'makefile'\nmakefile.aliases = []\nfunction makefile(Prism) {\n  Prism.languages.makefile = {\n    comment: {\n      pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n      lookbehind: true\n    },\n    string: {\n      pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: true\n    },\n    'builtin-target': {\n      pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n      alias: 'builtin'\n    },\n    target: {\n      pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n      alias: 'symbol',\n      inside: {\n        variable: /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n      }\n    },\n    variable: /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n    // Directives\n    keyword:\n      /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n    function: {\n      pattern:\n        /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n      lookbehind: true\n    },\n    operator: /(?:::|[?:+!])?=|[|@]/,\n    punctuation: /[:;(){}]/\n  }\n}\n","'use strict'\n\nmodule.exports = markdown\nmarkdown.displayName = 'markdown'\nmarkdown.aliases = ['md']\nfunction markdown(Prism) {\n  ;(function (Prism) {\n    // Allow only one line break\n    var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source\n    /**\n     * This function is intended for the creation of the bold or italic pattern.\n     *\n     * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n     *\n     * _Note:_ Keep in mind that this adds a capturing group.\n     *\n     * @param {string} pattern\n     * @returns {RegExp}\n     */\n    function createInline(pattern) {\n      pattern = pattern.replace(/<inner>/g, function () {\n        return inner\n      })\n      return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')')\n    }\n    var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/\n      .source\n    var tableRow =\n      /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(\n        /__/g,\n        function () {\n          return tableCell\n        }\n      )\n    var tableLine =\n      /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/\n        .source\n    Prism.languages.markdown = Prism.languages.extend('markup', {})\n    Prism.languages.insertBefore('markdown', 'prolog', {\n      'front-matter-block': {\n        pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          punctuation: /^---|---$/,\n          'front-matter': {\n            pattern: /\\S+(?:\\s+\\S+)*/,\n            alias: ['yaml', 'language-yaml'],\n            inside: Prism.languages.yaml\n          }\n        }\n      },\n      blockquote: {\n        // > ...\n        pattern: /^>(?:[\\t ]*>)*/m,\n        alias: 'punctuation'\n      },\n      table: {\n        pattern: RegExp(\n          '^' + tableRow + tableLine + '(?:' + tableRow + ')*',\n          'm'\n        ),\n        inside: {\n          'table-data-rows': {\n            pattern: RegExp(\n              '^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'\n            ),\n            lookbehind: true,\n            inside: {\n              'table-data': {\n                pattern: RegExp(tableCell),\n                inside: Prism.languages.markdown\n              },\n              punctuation: /\\|/\n            }\n          },\n          'table-line': {\n            pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n            lookbehind: true,\n            inside: {\n              punctuation: /\\||:?-{3,}:?/\n            }\n          },\n          'table-header-row': {\n            pattern: RegExp('^' + tableRow + '$'),\n            inside: {\n              'table-header': {\n                pattern: RegExp(tableCell),\n                alias: 'important',\n                inside: Prism.languages.markdown\n              },\n              punctuation: /\\|/\n            }\n          }\n        }\n      },\n      code: [\n        {\n          // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n          pattern:\n            /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n          lookbehind: true,\n          alias: 'keyword'\n        },\n        {\n          // ```optional language\n          // code block\n          // ```\n          pattern: /^```[\\s\\S]*?^```$/m,\n          greedy: true,\n          inside: {\n            'code-block': {\n              pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n              lookbehind: true\n            },\n            'code-language': {\n              pattern: /^(```).+/,\n              lookbehind: true\n            },\n            punctuation: /```/\n          }\n        }\n      ],\n      title: [\n        {\n          // title 1\n          // =======\n          // title 2\n          // -------\n          pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n          alias: 'important',\n          inside: {\n            punctuation: /==+$|--+$/\n          }\n        },\n        {\n          // # title 1\n          // ###### title 6\n          pattern: /(^\\s*)#.+/m,\n          lookbehind: true,\n          alias: 'important',\n          inside: {\n            punctuation: /^#+|#+$/\n          }\n        }\n      ],\n      hr: {\n        // ***\n        // ---\n        // * * *\n        // -----------\n        pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n        lookbehind: true,\n        alias: 'punctuation'\n      },\n      list: {\n        // * item\n        // + item\n        // - item\n        // 1. item\n        pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n        lookbehind: true,\n        alias: 'punctuation'\n      },\n      'url-reference': {\n        // [id]: http://example.com \"Optional title\"\n        // [id]: http://example.com 'Optional title'\n        // [id]: http://example.com (Optional title)\n        // [id]: <http://example.com> \"Optional title\"\n        pattern:\n          /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n        inside: {\n          variable: {\n            pattern: /^(!?\\[)[^\\]]+/,\n            lookbehind: true\n          },\n          string:\n            /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n          punctuation: /^[\\[\\]!:]|[<>]/\n        },\n        alias: 'url'\n      },\n      bold: {\n        // **strong**\n        // __strong__\n        // allow one nested instance of italic text using the same delimiter\n        pattern: createInline(\n          /\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/\n            .source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          content: {\n            pattern: /(^..)[\\s\\S]+(?=..$)/,\n            lookbehind: true,\n            inside: {} // see below\n          },\n          punctuation: /\\*\\*|__/\n        }\n      },\n      italic: {\n        // *em*\n        // _em_\n        // allow one nested instance of bold text using the same delimiter\n        pattern: createInline(\n          /\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/\n            .source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          content: {\n            pattern: /(^.)[\\s\\S]+(?=.$)/,\n            lookbehind: true,\n            inside: {} // see below\n          },\n          punctuation: /[*_]/\n        }\n      },\n      strike: {\n        // ~~strike through~~\n        // ~strike~\n        // eslint-disable-next-line regexp/strict\n        pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          content: {\n            pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n            lookbehind: true,\n            inside: {} // see below\n          },\n          punctuation: /~~?/\n        }\n      },\n      'code-snippet': {\n        // `code`\n        // ``code``\n        pattern:\n          /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n        lookbehind: true,\n        greedy: true,\n        alias: ['code', 'keyword']\n      },\n      url: {\n        // [example](http://example.com \"Optional title\")\n        // [example][id]\n        // [example] [id]\n        pattern: createInline(\n          /!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/\n            .source\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          operator: /^!/,\n          content: {\n            pattern: /(^\\[)[^\\]]+(?=\\])/,\n            lookbehind: true,\n            inside: {} // see below\n          },\n          variable: {\n            pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n            lookbehind: true\n          },\n          url: {\n            pattern: /(^\\]\\()[^\\s)]+/,\n            lookbehind: true\n          },\n          string: {\n            pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n            lookbehind: true\n          }\n        }\n      }\n    })\n    ;['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n      ;['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (\n        inside\n      ) {\n        if (token !== inside) {\n          Prism.languages.markdown[token].inside.content.inside[inside] =\n            Prism.languages.markdown[inside]\n        }\n      })\n    })\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'markdown' && env.language !== 'md') {\n        return\n      }\n      function walkTokens(tokens) {\n        if (!tokens || typeof tokens === 'string') {\n          return\n        }\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i]\n          if (token.type !== 'code') {\n            walkTokens(token.content)\n            continue\n          }\n          /*\n           * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n           * is optional. But the grammar is defined so that there is only one case we have to handle:\n           *\n           * token.content = [\n           *     <span class=\"punctuation\">```</span>,\n           *     <span class=\"code-language\">xxxx</span>,\n           *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n           *     <span class=\"code-block\">...</span>,\n           *     '\\n', // exactly one new lines again\n           *     <span class=\"punctuation\">```</span>\n           * ];\n           */\n          var codeLang = token.content[1]\n          var codeBlock = token.content[3]\n          if (\n            codeLang &&\n            codeBlock &&\n            codeLang.type === 'code-language' &&\n            codeBlock.type === 'code-block' &&\n            typeof codeLang.content === 'string'\n          ) {\n            // this might be a language that Prism does not support\n            // do some replacements to support C++, C#, and F#\n            var lang = codeLang.content\n              .replace(/\\b#/g, 'sharp')\n              .replace(/\\b\\+\\+/g, 'pp') // only use the first word\n            lang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase()\n            var alias = 'language-' + lang // add alias\n            if (!codeBlock.alias) {\n              codeBlock.alias = [alias]\n            } else if (typeof codeBlock.alias === 'string') {\n              codeBlock.alias = [codeBlock.alias, alias]\n            } else {\n              codeBlock.alias.push(alias)\n            }\n          }\n        }\n      }\n      walkTokens(env.tokens)\n    })\n    Prism.hooks.add('wrap', function (env) {\n      if (env.type !== 'code-block') {\n        return\n      }\n      var codeLang = ''\n      for (var i = 0, l = env.classes.length; i < l; i++) {\n        var cls = env.classes[i]\n        var match = /language-(.+)/.exec(cls)\n        if (match) {\n          codeLang = match[1]\n          break\n        }\n      }\n      var grammar = Prism.languages[codeLang]\n      if (!grammar) {\n        if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n          var id =\n            'md-' +\n            new Date().valueOf() +\n            '-' +\n            Math.floor(Math.random() * 1e16)\n          env.attributes['id'] = id\n          Prism.plugins.autoloader.loadLanguages(codeLang, function () {\n            var ele = document.getElementById(id)\n            if (ele) {\n              ele.innerHTML = Prism.highlight(\n                ele.textContent,\n                Prism.languages[codeLang],\n                codeLang\n              )\n            }\n          })\n        }\n      } else {\n        env.content = Prism.highlight(\n          textContent(env.content.value),\n          grammar,\n          codeLang\n        )\n      }\n    })\n    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi')\n    /**\n     * A list of known entity names.\n     *\n     * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n     *\n     * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n     */\n    var KNOWN_ENTITY_NAMES = {\n      amp: '&',\n      lt: '<',\n      gt: '>',\n      quot: '\"'\n    } // IE 11 doesn't support `String.fromCodePoint`\n    var fromCodePoint = String.fromCodePoint || String.fromCharCode\n    /**\n     * Returns the text content of a given HTML source code string.\n     *\n     * @param {string} html\n     * @returns {string}\n     */\n    function textContent(html) {\n      // remove all tags\n      var text = html.replace(tagPattern, '') // decode known entities\n      text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n        code = code.toLowerCase()\n        if (code[0] === '#') {\n          var value\n          if (code[1] === 'x') {\n            value = parseInt(code.slice(2), 16)\n          } else {\n            value = Number(code.slice(1))\n          }\n          return fromCodePoint(value)\n        } else {\n          var known = KNOWN_ENTITY_NAMES[code]\n          if (known) {\n            return known\n          } // unable to decode\n          return m\n        }\n      })\n      return text\n    }\n    Prism.languages.md = Prism.languages.markdown\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = magma\nmagma.displayName = 'magma'\nmagma.aliases = []\nfunction magma(Prism) {\n  Prism.languages.magma = {\n    output: {\n      pattern:\n        /^(>.*(?:\\r(?:\\n|(?!\\n))|\\n))(?!>)(?:.+|(?:\\r(?:\\n|(?!\\n))|\\n)(?!>).*)(?:(?:\\r(?:\\n|(?!\\n))|\\n)(?!>).*)*/m,\n      lookbehind: true,\n      greedy: true\n    },\n    comment: {\n      pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?\\*\\//,\n      greedy: true\n    },\n    string: {\n      pattern: /(^|[^\\\\\"])\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"/,\n      lookbehind: true,\n      greedy: true\n    },\n    // http://magma.maths.usyd.edu.au/magma/handbook/text/82\n    keyword:\n      /\\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    generator: {\n      pattern: /\\b[a-z_]\\w*(?=\\s*<)/i,\n      alias: 'class-name'\n    },\n    function: /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    number: {\n      pattern:\n        /(^|[^\\w.]|\\.\\.)(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?(?:_[a-z]?)?(?=$|[^\\w.]|\\.\\.)/,\n      lookbehind: true\n    },\n    operator: /->|[-+*/^~!|#=]|:=|\\.\\./,\n    punctuation: /[()[\\]{}<>,;.:]/\n  }\n}\n","'use strict'\n\nmodule.exports = matlab\nmatlab.displayName = 'matlab'\nmatlab.aliases = []\nfunction matlab(Prism) {\n  Prism.languages.matlab = {\n    comment: [/%\\{[\\s\\S]*?\\}%/, /%.+/],\n    string: {\n      pattern: /\\B'(?:''|[^'\\r\\n])*'/,\n      greedy: true\n    },\n    // FIXME We could handle imaginary numbers as a whole\n    number: /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?(?:[ij])?|\\b[ij]\\b/,\n    keyword:\n      /\\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\\b/,\n    function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n    operator: /\\.?[*^\\/\\\\']|[+\\-:@]|[<>=~]=?|&&?|\\|\\|?/,\n    punctuation: /\\.{3}|[.,;\\[\\](){}!]/\n  }\n}\n"],"names":["markup","Prism","languages","comment","pattern","greedy","prolog","doctype","inside","lookbehind","string","punctuation","name","cdata","tag","namespace","alias","entity","hooks","add","env","type","attributes","content","value","replace","Object","defineProperty","tagName","lang","includedCdataInside","def","RegExp","source","insertBefore","attrName","push","html","mathml","svg","xml","extend","ssml","atom","rss","module","exports","displayName","aliases","markupTemplating","getPlaceholder","language","index","toUpperCase","defineProperties","buildPlaceholders","placeholderPattern","replaceFilter","tokenStack","code","match","placeholder","i","length","indexOf","grammar","tokenizePlaceholders","j","keys","walkTokens","tokens","token","k","t","s","before","substring","middle","Token","tokenize","after","replacement","apply","splice","concat","maxscript","keywords","path","argument","keyword","boolean","time","number","constant","color","operator","makefile","target","variable","function","markdown","inner","createInline","tableCell","tableRow","tableLine","yaml","blockquote","table","title","hr","list","bold","italic","strike","url","forEach","l","codeLang","codeBlock","exec","toLowerCase","classes","cls","highlight","tagPattern","m","parseInt","slice","Number","fromCodePoint","known","KNOWN_ENTITY_NAMES","plugins","autoloader","id","Date","valueOf","Math","floor","random","loadLanguages","ele","document","getElementById","innerHTML","textContent","amp","lt","gt","quot","String","fromCharCode","md","magma","output","generator","matlab"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor.micromark-107007b2.0f761c361a.chunk.v1_8_8.js","mappings":"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","sources":["../node_modules/micromark/lib/constructs.js","../node_modules/micromark/lib/create-tokenizer.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */\n\nimport {\n  attention,\n  autolink,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  list,\n  setextUnderline,\n  thematicBreak\n} from 'micromark-core-commonmark'\nimport {resolver as resolveText} from './initialize/text.js'\n\n/** @satisfies {Extension['document']} */\nexport const document = {\n  [42]: list,\n  [43]: list,\n  [45]: list,\n  [48]: list,\n  [49]: list,\n  [50]: list,\n  [51]: list,\n  [52]: list,\n  [53]: list,\n  [54]: list,\n  [55]: list,\n  [56]: list,\n  [57]: list,\n  [62]: blockQuote\n}\n\n/** @satisfies {Extension['contentInitial']} */\nexport const contentInitial = {\n  [91]: definition\n}\n\n/** @satisfies {Extension['flowInitial']} */\nexport const flowInitial = {\n  [-2]: codeIndented,\n  [-1]: codeIndented,\n  [32]: codeIndented\n}\n\n/** @satisfies {Extension['flow']} */\nexport const flow = {\n  [35]: headingAtx,\n  [42]: thematicBreak,\n  [45]: [setextUnderline, thematicBreak],\n  [60]: htmlFlow,\n  [61]: setextUnderline,\n  [95]: thematicBreak,\n  [96]: codeFenced,\n  [126]: codeFenced\n}\n\n/** @satisfies {Extension['string']} */\nexport const string = {\n  [38]: characterReference,\n  [92]: characterEscape\n}\n\n/** @satisfies {Extension['text']} */\nexport const text = {\n  [-5]: lineEnding,\n  [-4]: lineEnding,\n  [-3]: lineEnding,\n  [33]: labelStartImage,\n  [38]: characterReference,\n  [42]: attention,\n  [60]: [autolink, htmlText],\n  [91]: labelStartLink,\n  [92]: [hardBreakEscape, characterEscape],\n  [93]: labelEnd,\n  [95]: attention,\n  [96]: codeText\n}\n\n/** @satisfies {Extension['insideSpan']} */\nexport const insideSpan = {\n  null: [attention, resolveText]\n}\n\n/** @satisfies {Extension['attentionMarkers']} */\nexport const attentionMarkers = {\n  null: [42, 95]\n}\n\n/** @satisfies {Extension['disable']} */\nexport const disable = {\n  null: []\n}\n","/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * @callback Restore\n * @returns {void}\n *\n * @typedef Info\n * @property {Restore} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n  let chunks = []\n  /** @type {Array<Token>} */\n  let stack = []\n  /** @type {boolean | undefined} */\n  let consumed = true\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n\n  /**\n   * The state function.\n   *\n   * @type {State | void}\n   */\n  let state = initialize.tokenize.call(context, effects)\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n  return context\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main()\n\n    // Exit if we’re not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n    addResult(initialize, 0)\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {line, column, offset, _index, _bufferIndex} = point\n    return {\n      line,\n      column,\n      offset,\n      _index,\n      _bufferIndex\n    }\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index]\n\n      // If we’re in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++\n\n      // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code\n\n    // Mark as consumed.\n    consumed = true\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   */\n  function constructFactory(onreturn, fields) {\n    return hook\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | Construct | ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State | undefined} [bogusState]\n     * @returns {State}\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n      let constructIndex\n      /** @type {Construct} */\n      let currentConstruct\n      /** @type {Info} */\n      let info\n      return Array.isArray(constructs) /* c8 ignore next 1 */\n        ? handleListOfConstructs(constructs)\n        : 'tokenize' in constructs\n        ? // @ts-expect-error Looks like a construct.\n          handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n      function handleMapOfConstructs(map) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        if (list.length === 0) {\n          return bogusState\n        }\n        return handleConstruct(list[constructIndex])\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n      function handleConstruct(construct) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          // Always populated by defaults.\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a “live binding”, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        consumed = true\n        info.restore()\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n        return bogusState\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n\n    /**\n     * Restore state.\n     *\n     * @returns {void}\n     */\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {void}\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'end' | 'start'>} token\n * @returns {Array<Chunk>}\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n  let view\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n    if (startBufferIndex > -1) {\n      const head = view[0]\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex)\n      } else {\n        view.shift()\n      }\n    }\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n  return view\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean | undefined} [expandTabs=false]\n * @returns {string}\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n        case -4: {\n          value = '\\n'\n          break\n        }\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n    atTab = chunk === -2\n    result.push(value)\n  }\n  return result.join('')\n}\n"],"names":["document","list","blockQuote","contentInitial","definition","flowInitial","codeIndented","flow","headingAtx","thematicBreak","setextUnderline","htmlFlow","codeFenced","string","characterReference","characterEscape","text","lineEnding","labelStartImage","attention","autolink","htmlText","labelStartLink","hardBreakEscape","labelEnd","codeText","insideSpan","null","resolveText","attentionMarkers","disable","createTokenizer","parser","initialize","from","point","Object","assign","line","column","offset","_index","_bufferIndex","columnStart","resolveAllConstructs","chunks","stack","consumed","effects","consume","code","markdownLineEnding","accountForPotentialSkip","length","context","previous","enter","type","fields","token","start","now","events","push","exit","pop","end","attempt","constructFactory","construct","info","addResult","check","onsuccessfulcheck","interrupt","containerState","sliceStream","sliceSerialize","expandTabs","index","result","atTab","chunk","value","String","fromCharCode","join","serializeChunks","defineSkip","write","slice","main","resolveAll","expectedCode","state","tokenize","call","startIndex","startBufferIndex","endIndex","endBufferIndex","view","head","shift","sliceChunks","chunkIndex","go","charCodeAt","undefined","_","restore","onreturn","constructs","returnState","bogusState","listOfConstructs","constructIndex","currentConstruct","Array","isArray","handleListOfConstructs","map","def","all","handleMapOfConstructs","handleConstruct","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","store","partial","name","includes","nok","create","ok","resolve","splice","resolveTo"],"sourceRoot":""}
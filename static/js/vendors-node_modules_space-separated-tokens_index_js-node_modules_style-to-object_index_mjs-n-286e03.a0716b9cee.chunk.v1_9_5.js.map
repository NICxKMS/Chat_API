{"version":3,"file":"static/js/vendors-node_modules_space-separated-tokens_index_js-node_modules_style-to-object_index_mjs-n-286e03.a0716b9cee.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/unist-util-stringify-position/lib/index.js","../node_modules/style-to-object/index.mjs","../node_modules/unist-util-generated/lib/index.js","../node_modules/space-separated-tokens/index.js","../node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../node_modules/trim-lines/index.js","../node_modules/trough/lib/index.js","../node_modules/style-to-object/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","import StyleToObject from './index.js';\n\nexport default StyleToObject;\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > 👉 **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > it’s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","var parse = require('inline-style-parser');\n\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */\nfunction StyleToObject(style, iterator) {\n  var output = null;\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  var declaration;\n  var declarations = parse(style);\n  var hasIterator = typeof iterator === 'function';\n  var property;\n  var value;\n\n  for (var i = 0, len = declarations.length; i < len; i++) {\n    declaration = declarations[i];\n    property = declaration.property;\n    value = declaration.value;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      output || (output = {});\n      output[property] = value;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = StyleToObject;\nmodule.exports.default = StyleToObject; // ESM support\n"],"names":["stringifyPosition","value","position","point","index","line","column","pos","start","end","generated","node","parse","input","String","trim","split","stringify","values","join","convert","test","ok","check","castFactory","type","Array","isArray","tests","checks","length","_len","arguments","parameters","_key","call","this","anyFactory","key","propsFactory","Error","_len2","_key2","Boolean","EXIT","visit","tree","visitor","reverse","is","step","factory","parents","name","tagName","undefined","Object","defineProperty","subresult","offset","grandparents","result","toResult","children","concat","visitParents","parent","indexOf","tab","space","trimLines","source","search","match","exec","last","lines","push","trimLine","slice","startIndex","endIndex","code","codePointAt","trough","fns","pipeline","run","middlewareIndex","callback","pop","TypeError","next","error","fn","output","middleware","called","_len3","_key3","fnExpectsCallback","done","apply","then","_len4","_key4","wrap","use","middelware","require","StyleToObject","style","iterator","declaration","property","declarations","hasIterator","i","len","module","exports"],"sourceRoot":""}
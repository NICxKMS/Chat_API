{"version":3,"file":"static/js/vendors-node_modules_remark-math_index_js.b5ae18f381.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/micromark-extension-math/node_modules/micromark-util-character/index.js","../node_modules/micromark-extension-math/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-extension-math/lib/math-flow.js","../node_modules/micromark-extension-math/lib/math-text.js","../node_modules/remark-math/index.js","../node_modules/micromark-extension-math/lib/syntax.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options]\n * @returns {Construct}\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n"],"names":["markdownLineEnding","code","regexCheck","regex","test","String","fromCharCode","mathFlow","tokenize","effects","ok","nok","self","this","tail","events","length","initialSize","type","sliceSerialize","sizeOpen","enter","sequenceOpen","consume","exit","factorySpace","metaBefore","metaAfter","contentType","meta","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","after","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","size","sequenceClose","parser","constructs","disable","null","includes","undefined","afterSequenceClose","concrete","lineStart","lazy","now","line","mathText","options","single","singleDollarTextMath","token","between","data","resolve","resolveMathText","previous","index","tailExitIndex","headEnterIndex","end","splice","remarkMath","arguments","add","field","value","push","flow","text","math","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","resume","replace","node","setData","mathFlowFence","getData","stack","mathFlowValue","exitMathData","mathTextData","config","call","mathFromMarkdown","inlineMath","peek","unsafe","character","inConstruct","atBreak","handlers","_","context","safeOptions","raw","tracker","track","sequence","repeat","Math","max","substring","source","indexOf","expected","count","longestStreak","move","subexit","safe","before","encode","current","RegExp","pattern","expression","patternCompile","match","exec","position","codePointAt","slice","mathToMarkdown"],"sourceRoot":""}
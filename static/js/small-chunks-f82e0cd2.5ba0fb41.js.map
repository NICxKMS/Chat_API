{"version":3,"file":"static/js/small-chunks-f82e0cd2.5ba0fb41.js","mappings":"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","sources":["../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/is-alphabetical/index.js","../node_modules/mdast-util-gfm-footnote/node_modules/micromark-util-normalize-identifier/index.js","../node_modules/mdast-util-gfm-footnote/lib/index.js","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/is-buffer/index.js","../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/longest-streak/index.js","../node_modules/mdast-util-gfm/lib/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/is-alphanumerical/index.js","../node_modules/is-hexadecimal/index.js","../node_modules/is-decimal/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","'use strict'\n\nmodule.exports = alphabetical\n\n// Check if the given character code, or the character code at the first\n// character, is alphabetical.\nfunction alphabetical(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n","/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered “uppercase”, such as U+03F4 (`ϴ`), but if their\n * lowercase counterpart (U+03B8 (`θ`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Θ`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ')\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered “uppercase”, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasn’t a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","'use strict'\n\nvar alphabetical = require('is-alphabetical')\nvar decimal = require('is-decimal')\n\nmodule.exports = alphanumerical\n\n// Check if the given character code, or the character code at the first\n// character, is alphanumerical.\nfunction alphanumerical(character) {\n  return alphabetical(character) || decimal(character)\n}\n","'use strict'\n\nmodule.exports = hexadecimal\n\n// Check if the given character code, or the character code at the first\n// character, is hexadecimal.\nfunction hexadecimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n","'use strict'\n\nmodule.exports = decimal\n\n// Check if the given character code, or the character code at the first\n// character, is decimal.\nfunction decimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n"],"names":["gfmTaskListItemFromMarkdown","exit","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","token","parent","this","stack","length","type","checked","node","head","children","siblings","firstParaghraph","index","sibling","value","slice","shift","position","start","offset","column","Object","assign","gfmTaskListItemToMarkdown","unsafe","atBreak","character","after","handlers","listItem","context","safeOptions","checkable","checkbox","tracker","track","move","current","replace","$0","module","exports","code","charCodeAt","normalizeIdentifier","toLowerCase","toUpperCase","gfmFootnoteFromMarkdown","enter","gfmFootnoteDefinition","enterFootnoteDefinition","gfmFootnoteDefinitionLabelString","enterFootnoteDefinitionLabelString","gfmFootnoteCall","enterFootnoteCall","gfmFootnoteCallString","enterFootnoteCallString","exitFootnoteDefinition","exitFootnoteDefinitionLabelString","exitFootnoteCall","exitFootnoteCallString","gfmFootnoteToMarkdown","inConstruct","footnoteDefinition","footnoteReference","identifier","label","buffer","resume","sliceSerialize","_","subexit","safe","association","before","indentLines","containerFlow","map","line","blank","peek","handleDelete","gfmStrikethroughFromMarkdown","canContainEols","strikethrough","gfmStrikethroughToMarkdown","notInConstruct","delete","containerPhrasing","findAndReplace","tree","list","options","settings","ignored","convert","ignore","pairs","tupleOrList","result","Array","isArray","TypeError","tuple","push","toExpression","toFunction","toPairs","pairIndex","visitParents","visitor","parents","grandparent","undefined","indexOf","find","change","nodes","lastIndex","match","exec","matchObject","input","global","splice","handler","RegExp","escape","mathFromMarkdown","mathFlow","meta","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","mathText","setData","mathFlowFence","getData","mathFlowValue","exitMathData","mathTextData","config","call","mathToMarkdown","single","singleDollarTextMath","inlineMath","math","raw","sequence","repeat","Math","max","longestStreak","encode","size","test","pattern","expression","patternCompile","codePointAt","escapeStringRegexp","string","obj","constructor","isBuffer","gfmTableFromMarkdown","table","align","_align","d","tableData","enterCell","tableHeader","tableRow","codeText","$1","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","serializeData","handleTableRowAsData","handleTableAsData","tableCell","handleTableCell","inlineCode","includes","matrix","markdownTable","substring","source","String","expected","count","gfmFromMarkdown","gfmAutolinkLiteralFromMarkdown","gfmToMarkdown","extensions","gfmAutolinkLiteralToMarkdown","emptyOptions","toString","one","includeImageAlt","includeHtml","Boolean","alt","all","values","join","alphabetical","require","decimal"],"sourceRoot":""}
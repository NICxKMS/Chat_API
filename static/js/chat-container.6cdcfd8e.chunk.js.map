{"version":3,"file":"static/js/chat-container.6cdcfd8e.chunk.js","mappings":"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","sources":["components/chat/ChatContainer/index.js"],"sourcesContent":["import { memo, lazy, useRef, useEffect, useState, useCallback, Suspense } from 'react';\nimport { useChatLogic } from '../../../hooks/useChatLogic';\nimport { ChevronDownIcon } from '@primer/octicons-react';\nimport styles from './ChatContainer.module.css';\n\n// Lazy-loaded components\nconst MessageList = lazy(() => import(/* webpackChunkName: \"chat-messagelist\" */ '../MessageList'));\nconst ChatInput = lazy(() => import(/* webpackChunkName: \"chat-input\" */ '../ChatInput'));\nconst GlobalMetricsBar = lazy(() => import(/* webpackChunkName: \"chat-globalmetrics\" */ '../GlobalMetricsBar'));\nconst ModelSelectorButton = lazy(() => import(/* webpackChunkName: \"model-selector-button\" */ '../../models/ModelSelectorButton'));\n\n/**\n * Main chat container component\n */\nconst ChatContainer = memo(({ \n  selectedModel: passedSelectedModel,\n  isLoadingModels, \n  toggleModelSelector,\n  onNewChat,\n  onResetChat,\n  onDownloadChat,\n  onToggleSettings,\n  isSidebarOpen,\n  isSettingsOpen,\n  isModelSelectorOpen\n}) => {\n  const {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics, \n    selectedModel: modelFromLogic,\n    handleSendMessage,\n  } = useChatLogic();\n\n  // Add state to track which message is being edited\n  const [editingMessage, setEditingMessage] = useState(null);\n\n  const messageListRef = useRef(null);\n  const scrollContainerRef = useRef(null);\n  const isActiveChat = chatHistory.length > 0;\n  const [showScrollToBottomButton, setShowScrollToBottomButton] = useState(false);\n  const prevChatHistoryLength = useRef(chatHistory.length);\n  const prevWaitingForResponse = useRef(isWaitingForResponse);\n\n  // Effect to update input height CSS variable for scroll button positioning\n  useEffect(() => {\n    const updateInputHeight = () => {\n      const inputContainer = document.querySelector('.inputContainer') || \n                            document.querySelector(`.${styles.fixedInputArea}`);\n      if (inputContainer) {\n        const height = inputContainer.offsetHeight;\n        document.documentElement.style.setProperty('--input-height', `${height}px`);\n      }\n    };\n\n    // Initial update\n    updateInputHeight();\n\n    // Set up observer to track input container height changes\n    const resizeObserver = new ResizeObserver(updateInputHeight);\n    const inputContainer = document.querySelector('.inputContainer') || \n                          document.querySelector(`.${styles.fixedInputArea}`);\n    \n    if (inputContainer) {\n      resizeObserver.observe(inputContainer);\n    }\n\n    // Clean up observer on unmount\n    return () => {\n      if (inputContainer) {\n        resizeObserver.unobserve(inputContainer);\n      }\n      resizeObserver.disconnect();\n    };\n  }, [chatHistory, editingMessage]); // Re-run when chat history changes or edit mode changes\n\n  // Function to ensure the input field is focused\n  const focusInputField = useCallback(() => {\n    // Use a timeout to ensure the component is fully rendered and mounted\n    setTimeout(() => {\n      // Try to find the textarea within the ChatInput component\n      const inputField = document.querySelector('textarea.'+styles.chatInput) || \n                         document.querySelector('textarea[aria-label=\"Chat message input\"]');\n      if (inputField) {\n        inputField.focus();\n      }\n    }, 100);\n  }, []);\n\n  // Focus the input field when the component is mounted\n  useEffect(() => {\n    focusInputField();\n  }, [focusInputField]);\n\n  // Focus input when response is completed, only if UI elements aren't open\n  useEffect(() => {\n    // Check if response has just completed (was waiting, now not waiting)\n    if (prevWaitingForResponse.current && !isWaitingForResponse) {\n      // Only focus if no UI elements are open\n      const noUIElementsOpen = !isSidebarOpen && !isSettingsOpen && !isModelSelectorOpen && !editingMessage;\n      \n      if (noUIElementsOpen) {\n        focusInputField();\n      }\n    }\n    \n    // Update the ref for the next check\n    prevWaitingForResponse.current = isWaitingForResponse;\n  }, [isWaitingForResponse, isSidebarOpen, isSettingsOpen, isModelSelectorOpen, editingMessage, focusInputField]);\n\n  // Function to smoothly scroll to the bottom\n  const scrollToBottom = useCallback((behavior = 'smooth') => {\n    if (scrollContainerRef.current) {\n      scrollContainerRef.current.scrollTo({\n        top: scrollContainerRef.current.scrollHeight,\n        behavior: behavior\n      });\n      // Ensure button is hidden immediately after explicitly scrolling\n      setShowScrollToBottomButton(false);\n    }\n  }, []);\n\n  // Effect when new messages arrive (NO LONGER MANAGES BUTTON VISIBILITY)\n  useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container || !isActiveChat) return;\n\n    // Only proceed if chat history actually grew\n    if (chatHistory.length <= prevChatHistoryLength.current) {\n      prevChatHistoryLength.current = chatHistory.length;\n      return;\n    }\n\n    // Update previous length tracking\n    prevChatHistoryLength.current = chatHistory.length;\n\n    // We might still need to check scroll position *after* history updates\n    // to show the button if the new content itself pushes the view up.\n    // Let's add a check within the scroll handler effect as well.\n\n  }, [chatHistory, isActiveChat]); // Removed scrollToBottom from deps as it's not used here\n\n  // Effect to handle manual scrolling by the user (NOW MANAGES BUTTON VISIBILITY)\n  useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n\n    const handleScroll = () => {\n      const scrollThreshold = 10; // Pixels from bottom to consider \"at bottom\"\n      const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;\n      // Show the button if user is NOT at the bottom\n      setShowScrollToBottomButton(!atBottom);\n    };\n\n    // Run handler once initially to set correct state\n    handleScroll();\n\n    container.addEventListener('scroll', handleScroll, { passive: true });\n    return () => container.removeEventListener('scroll', handleScroll);\n\n  }, [showScrollToBottomButton]); // Dependency helps re-attach listener if needed, though primary logic is inside\n\n  // Need another effect to check scroll position when chatHistory length changes,\n  // as new content might make the button necessary even if user didn't scroll.\n  useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    // Check after a short delay to allow DOM to update with new message height\n    const checkScrollTimeout = setTimeout(() => {\n      const scrollThreshold = 10;\n      const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;\n      setShowScrollToBottomButton(!atBottom);\n    }, 100); // Adjust delay if needed\n\n    return () => clearTimeout(checkScrollTimeout);\n  }, [chatHistory]); // Run when chatHistory changes\n\n  // Use the selected model passed down for the button, but model from logic elsewhere\n  const displayModelName = passedSelectedModel?.name;\n  const displayProviderName = passedSelectedModel?.provider;\n\n  // Handle edit message request from a message\n  const handleEditMessage = useCallback((message) => {\n    // Can't edit while waiting for response\n    if (isWaitingForResponse) return;\n    setEditingMessage(message);\n    // Scroll to input area if needed\n    setTimeout(() => {\n      const inputArea = document.querySelector(`.${styles.fixedInputArea}`);\n      if (inputArea) {\n        inputArea.scrollIntoView({ behavior: 'smooth' });\n      }\n    }, 100);\n  }, [isWaitingForResponse]);\n\n  // Handle cancel edit\n  const handleCancelEdit = useCallback(() => {\n    setEditingMessage(null);\n  }, []);\n\n  // Disable editing if the model starts responding\n  useEffect(() => {\n    if (isWaitingForResponse && editingMessage) {\n      setEditingMessage(null);\n    }\n  }, [isWaitingForResponse, editingMessage]);\n\n  // Classes for the main container\n  const chatContainerClasses = `${styles.chatContainer} ${isActiveChat ? styles.activeChat : styles.emptyChat} ${editingMessage ? styles.editingMode : ''}`;\n\n  // Helper function to render the input area contents\n  const renderInputAreaContents = (isFixedLayout) => {\n    const isStaticLayout = !isFixedLayout;\n    \n    return (\n      <>\n        {/* Global Metrics: Only show when fixed */} \n        {isFixedLayout && !editingMessage && (\n          <Suspense fallback={<div className={styles.globalMetricsPlaceholder} />}>\n            <GlobalMetricsBar \n              metrics={metrics?.session}\n              modelName={modelFromLogic?.name} \n            />\n          </Suspense>\n        )}\n\n        <div className={styles.inputControlsWrapper}> \n          <Suspense fallback={<div className={styles.inputPlaceholder} />}>\n            <ChatInput\n              onSendMessage={handleSendMessage}\n              disabled={isWaitingForResponse} \n              selectedModel={modelFromLogic} \n              onNewChat={onNewChat}\n              isStaticLayout={isStaticLayout}\n              editingMessage={editingMessage}\n              onCancelEdit={handleCancelEdit}\n              isStreaming={isWaitingForResponse}\n              toggleModelSelector={toggleModelSelector}\n              onFocus={focusInputField}\n            />\n          </Suspense>\n        </div>\n      </>\n    );\n  };\n\n  return (\n    <div className={chatContainerClasses}>\n      {/* Container for the Model Selector Button */}\n      <div className={styles.modelButtonContainer}>\n        <Suspense fallback={null}> \n          <ModelSelectorButton \n            selectedModelName={displayModelName}\n            providerName={displayProviderName}\n            onClick={toggleModelSelector}\n            disabled={isLoadingModels}\n          />\n        </Suspense>\n      </div>\n\n      <div className={styles.chatAreaWrapper}>\n        <div className={styles.chatArea}>\n          {isActiveChat ? (\n            // Active Chat: Render MessageList inside scroll container\n            <div className={styles.scrollContainer} ref={scrollContainerRef}>\n              <div className={styles.scrollInner}>\n                <Suspense fallback={<div className={styles.messagePlaceholder} />}>\n                  <MessageList\n                    ref={messageListRef}\n                    messages={chatHistory}\n                    error={error}\n                    onEditMessage={handleEditMessage}\n                  />\n                </Suspense>\n              </div>\n            </div>\n          ) : (\n            // Empty Chat: Render Greeting and Input Area (Static Layout)\n            <div className={styles.emptyChatContent}>\n              <div className={styles.greetingMessage}>\n                <h2>Welcome to AI Chat!</h2>\n                <p>Select a model above and start your conversation.</p>\n              </div>\n              {/* Render input area directly below greeting */}\n              <div className={`${styles.inputArea} ${styles.staticInputArea}`}> \n                {renderInputAreaContents(false)} \n              </div>\n            </div>\n          )}\n        </div>\n\n        {/* Scroll to Bottom Button */}\n        {showScrollToBottomButton && isActiveChat && (\n          <button\n            className={styles.scrollToBottomButton}\n            onClick={() => scrollToBottom('smooth')}\n            aria-label=\"Scroll to bottom\"\n            title=\"Scroll to bottom\"\n          >\n            <ChevronDownIcon size={20} />\n          </button>\n        )}\n      </div>\n\n      {/* Fixed Input Area Wrapper (Only rendered when chat is active) */}\n      {isActiveChat && (\n        <div className={`${styles.inputArea} ${styles.fixedInputArea}`}> \n          {renderInputAreaContents(true)} \n        </div>\n      )}\n    </div>\n  );\n});\n\nChatContainer.displayName = 'ChatContainer';\n\nexport default ChatContainer; "],"names":["MessageList","lazy","ChatInput","GlobalMetricsBar","ModelSelectorButton","ChatContainer","memo","_ref","selectedModel","passedSelectedModel","isLoadingModels","toggleModelSelector","onNewChat","onResetChat","onDownloadChat","onToggleSettings","isSidebarOpen","isSettingsOpen","isModelSelectorOpen","chatHistory","isWaitingForResponse","error","metrics","modelFromLogic","handleSendMessage","useChatLogic","editingMessage","setEditingMessage","useState","messageListRef","useRef","scrollContainerRef","isActiveChat","length","showScrollToBottomButton","setShowScrollToBottomButton","prevChatHistoryLength","prevWaitingForResponse","useEffect","updateInputHeight","inputContainer","document","querySelector","styles","fixedInputArea","height","offsetHeight","documentElement","style","setProperty","resizeObserver","ResizeObserver","observe","unobserve","disconnect","focusInputField","useCallback","setTimeout","inputField","chatInput","focus","current","scrollToBottom","behavior","arguments","undefined","scrollTo","top","scrollHeight","container","handleScroll","atBottom","scrollTop","clientHeight","addEventListener","passive","removeEventListener","checkScrollTimeout","clearTimeout","displayModelName","name","displayProviderName","provider","handleEditMessage","message","inputArea","scrollIntoView","handleCancelEdit","chatContainerClasses","chatContainer","activeChat","emptyChat","editingMode","renderInputAreaContents","isFixedLayout","isStaticLayout","_jsxs","_Fragment","children","_jsx","Suspense","fallback","className","globalMetricsPlaceholder","session","modelName","inputControlsWrapper","inputPlaceholder","onSendMessage","disabled","onCancelEdit","isStreaming","onFocus","modelButtonContainer","selectedModelName","providerName","onClick","chatAreaWrapper","chatArea","scrollContainer","ref","scrollInner","messagePlaceholder","messages","onEditMessage","emptyChatContent","greetingMessage","staticInputArea","scrollToBottomButton","title","ChevronDownIcon","size","displayName"],"sourceRoot":""}
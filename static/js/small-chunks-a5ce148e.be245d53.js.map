{"version":3,"file":"static/js/small-chunks-a5ce148e.be245d53.js","mappings":"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AKC,KAElC,OAAOzC,CACT,CACA,KAAKpB,EAAAA,GAAK,CACR,MAAMkE,EAAU,GACV9C,EAAQF,EAAG,CAACmC,EAAMa,GAAUxF,GAClC,IAAK,MAAMmF,KAASnF,GACdiF,GAAWR,EAAWJ,EAAOc,KAC/BK,EAAQvC,KAAKiC,EAAKC,IAEtB,OAAOzC,CACT,EAGF,MAAM,QAACkB,GAAW5D,EAClB,OAAOwC,EAAG,CAACmC,EAAM,CAAChB,KAAMZ,EAAMa,YAAW5D,EAAM,EAGjD,OAAOkF,CAAI,EAiBJF,GAAaH,GAAQC,KAAUD,EAAM,IAAIrB,IAAKjB,EAA9CyC,CAAiDhF,GAAQuC,CAClE,EC3JA,EAA0C,mBAApBmD,gBAEpB,CAACC,EAAK9F,IACJA,IAAY,SAAUA,GAAW,UAAWA,GAC1CsC,EAAYyC,EAAUe,EAAK9F,IAAY6F,gBAAgBC,GAE3D,CAACA,EAAK9F,IAAYsC,EAAYyC,EAAUe,EAAK9F,G,+BCjBxC,SAAS+F,EAAMC,GACpB,OAAOA,CACT,C,4BCLAC,EAAOC,QAAU,IAAItC,IAAI,CACxB,KACA,KACA,KACA,KACA,KACA,KACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,Q,yDCvDM,MAAMuC,EAAWC,EAAM,OAUjBC,EAAaD,EAAM,SAUhC,SAASA,EAAMlD,GACb,OAQA,SAAerB,GACb,MAAMuE,EAASvE,GAAQA,EAAKC,UAAYD,EAAKC,SAASoB,IAAU,CAAC,EAEjE,GACwB,iBAAfkD,EAAMpE,MACboE,EAAMpE,K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","sources":["../node_modules/zwitch/index.js","../node_modules/@ungap/structured-clone/esm/types.js","../node_modules/unist-util-generated/lib/index.js","../node_modules/@ungap/structured-clone/esm/deserialize.js","../node_modules/@ungap/structured-clone/esm/serialize.js","../node_modules/@ungap/structured-clone/esm/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unicode-emoji-modifier-base/index.js","../node_modules/unist-util-position/lib/index.js","../node_modules/xtend/immutable.js","../node_modules/unist-util-find-after/lib/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/vfile-location/lib/index.js","../node_modules/web-namespaces/index.js","../node_modules/unist-util-visit/lib/index.js"],"sourcesContent":["/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and itâ€™s value is this functionâ€™s\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but itâ€™s set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnâ€™t have a `key` property, the special\n   * â€œinvalidâ€ handler will be called.\n   * If `value` has an unknown `key`, the special â€œunknownâ€ handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and itâ€™s result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but itâ€™s set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n","export const VOID       = -1;\nexport const PRIMITIVE  = 0;\nexport const ARRAY      = 1;\nexport const OBJECT     = 2;\nexport const DATE       = 3;\nexport const REGEXP     = 4;\nexport const MAP        = 5;\nexport const SET        = 6;\nexport const ERROR      = 7;\nexport const BIGINT     = 8;\n// export const SYMBOL = 9;\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n      case 'ArrayBuffer':\n        return as(new Uint8Array(value).buffer, value);\n      case 'DataView': {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n    case 'DataView':\n      return [ARRAY, asString];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === 'DataView') {\n            spread = new Uint8Array(value.buffer);\n          }\n          else if (type === 'ArrayBuffer') {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n","import {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} any a serializable value.\n * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with\n * a transfer option (ignored when polyfilled) and/or non standard fields that\n * fallback to the polyfill if present.\n * @returns {Record[]}\n */\nexport default typeof structuredClone === \"function\" ?\n  /* c8 ignore start */\n  (any, options) => (\n    options && ('json' in options || 'lossy' in options) ?\n      deserialize(serialize(any, options)) : structuredClone(any)\n  ) :\n  (any, options) => deserialize(serialize(any, options));\n  /* c8 ignore stop */\n\nexport {deserialize, serialize};\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","// Generated using `npm run build`. Do not edit!\nmodule.exports = new Set([\n\t0x261D,\n\t0x26F9,\n\t0x270A,\n\t0x270B,\n\t0x270C,\n\t0x270D,\n\t0x1F385,\n\t0x1F3C3,\n\t0x1F3C4,\n\t0x1F3CA,\n\t0x1F3CB,\n\t0x1F442,\n\t0x1F443,\n\t0x1F446,\n\t0x1F447,\n\t0x1F448,\n\t0x1F449,\n\t0x1F44A,\n\t0x1F44B,\n\t0x1F44C,\n\t0x1F44D,\n\t0x1F44E,\n\t0x1F44F,\n\t0x1F450,\n\t0x1F466,\n\t0x1F467,\n\t0x1F468,\n\t0x1F469,\n\t0x1F46E,\n\t0x1F470,\n\t0x1F471,\n\t0x1F472,\n\t0x1F473,\n\t0x1F474,\n\t0x1F475,\n\t0x1F476,\n\t0x1F477,\n\t0x1F478,\n\t0x1F47C,\n\t0x1F481,\n\t0x1F482,\n\t0x1F483,\n\t0x1F485,\n\t0x1F486,\n\t0x1F487,\n\t0x1F4AA,\n\t0x1F575,\n\t0x1F57A,\n\t0x1F590,\n\t0x1F595,\n\t0x1F596,\n\t0x1F645,\n\t0x1F646,\n\t0x1F647,\n\t0x1F64B,\n\t0x1F64C,\n\t0x1F64D,\n\t0x1F64E,\n\t0x1F64F,\n\t0x1F6A3,\n\t0x1F6B4,\n\t0x1F6B5,\n\t0x1F6B6,\n\t0x1F6C0,\n\t0x1F918,\n\t0x1F919,\n\t0x1F91A,\n\t0x1F91B,\n\t0x1F91C,\n\t0x1F91D,\n\t0x1F91E,\n\t0x1F926,\n\t0x1F930,\n\t0x1F933,\n\t0x1F934,\n\t0x1F935,\n\t0x1F936,\n\t0x1F937,\n\t0x1F938,\n\t0x1F939,\n\t0x1F93C,\n\t0x1F93D,\n\t0x1F93E\n]);\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodeâ€™s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @import {VFile, Value} from 'vfile'\n * @import {Location} from 'vfile-location'\n */\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file)\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = []\n\n  return {toOffset, toPoint}\n\n  /** @type {Location['toPoint']} */\n  function toPoint(offset) {\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\n      let index = 0\n\n      while (true) {\n        let end = indices[index]\n\n        if (end === undefined) {\n          const eol = next(value, indices[index - 1])\n          end = eol === -1 ? value.length + 1 : eol + 1\n          indices[index] = end\n        }\n\n        if (end > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          }\n        }\n\n        index++\n      }\n    }\n  }\n\n  /** @type {Location['toOffset']} */\n  function toOffset(point) {\n    if (\n      point &&\n      typeof point.line === 'number' &&\n      typeof point.column === 'number' &&\n      !Number.isNaN(point.line) &&\n      !Number.isNaN(point.column)\n    ) {\n      while (indices.length < point.line) {\n        const from = indices[indices.length - 1]\n        const eol = next(value, from)\n        const end = eol === -1 ? value.length + 1 : eol + 1\n        if (from === end) break\n        indices.push(end)\n      }\n\n      const offset =\n        (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1\n      // The given `column` could not exist on this line.\n      if (offset < indices[point.line - 1]) return offset\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @param {number} from\n */\nfunction next(value, from) {\n  const cr = value.indexOf('\\r', from)\n  const lf = value.indexOf('\\n', from)\n  if (lf === -1) return cr\n  if (cr === -1 || cr + 1 === lf) return lf\n  return cr < lf ? cr : lf\n}\n","/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nexport const webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when itâ€™s released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > ðŸ‘‰ **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnâ€™t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnâ€™t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n"],"names":["own","hasOwnProperty","zwitch","key","options","settings","one","value","fn","invalid","handlers","call","id","String","unknown","_len","arguments","length","parameters","Array","_key","this","VOID","PRIMITIVE","ARRAY","OBJECT","DATE","REGEXP","MAP","SET","ERROR","BIGINT","generated","node","position","start","line","column","end","env","self","globalThis","deserialize","serialized","deserializer","$","_","as","out","index","set","unpair","has","get","type","arr","push","object","Date","source","flags","RegExp","map","Map","Set","add","name","message","BigInt","Object","Uint8Array","buffer","DataView","EMPTY","toString","keys","typeOf","asString","slice","includes","shouldSkip","_ref","TYPE","serialize","json","lossy","undefined","serializer","strict","pair","entry","TypeError","spread","valueOf","toJSON","entries","toISOString","structuredClone","any","color","d","module","exports","pointEnd","point","pointStart","offset","target","i","prototype","findAfter","parent","test","is","convert","children","Error","Number","POSITIVE_INFINITY","indexOf","ok","castFactory","isArray","tests","checks","apply","anyFactory","check","checkAsRecord","all","nodeAsRecord","propsFactory","typeFactory","testFunction","Boolean","looksLikeANode","location","file","indices","toOffset","isNaN","from","eol","next","toPoint","cr","lf","webNamespaces","html","mathml","svg","xlink","xml","xmlns","visit","tree","testOrVisitor","visitorOrReverse","maybeReverse","reverse","visitor","visitParents","parents"],"sourceRoot":""}
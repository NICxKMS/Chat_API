{"version":3,"file":"static/js/vendor.remark-parse-849ad637.d64c0572.chunk.js","mappings":"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","sources":["../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/setext-underline.js","../node_modules/remark-parse/node_modules/micromark-factory-label/index.js","../node_modules/remark-parse/node_modules/micromark-factory-title/index.js","../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/thematic-break.js","../node_modules/remark-parse/node_modules/micromark-factory-whitespace/index.js","../node_modules/remark-parse/node_modules/micromark-factory-destination/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = 'setextHeadingText'\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== 'lineEnding' &&\n        self.events[index][1].type !== 'linePrefix' &&\n        self.events[index][1].type !== 'content'\n      ) {\n        paragraph = self.events[index][1].type === 'paragraph'\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      marker = code\n      return before(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('setextHeadingLineSequence')\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    effects.exit('setextHeadingLineSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'lineSuffix')(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse labels.\n *\n * > 👉 **Note**: labels in markdown are capped at 999 characters in the string.\n *\n * ###### Examples\n *\n * ```markdown\n * [a]\n * [a\n * b]\n * [a\\]b]\n * ```\n *\n * @this {TokenizeContext}\n *   Tokenize context.\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole label (`[a]`).\n * @param {TokenType} markerType\n *   Type for the markers (`[` and `]`).\n * @param {TokenType} stringType\n *   Type for the identifier (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /**\n   * Start of label.\n   *\n   * ```markdown\n   * > | [a]\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  /**\n   * In label, at something, before something else.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (\n      size > 999 ||\n      code === null ||\n      code === 91 ||\n      (code === 93 && !seen) ||\n      // To do: remove in the future once we’ve switched from\n      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n      // which doesn’t need this.\n      // Hidden footnotes hook.\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    // To do: indent? Link chunks and EOLs together?\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return labelInside(code)\n  }\n\n  /**\n   * In label, in text.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    if (!seen) seen = !markdownSpace(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | [a\\*a]\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * Parse titles.\n *\n * ###### Examples\n *\n * ```markdown\n * \"a\"\n * 'b'\n * (c)\n * \"a\n * b\"\n * 'a\n *     b'\n * (a\\)b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole title (`\"a\"`, `'b'`, `(c)`).\n * @param {TokenType} markerType\n *   Type for the markers (`\"`, `'`, `(`, and `)`).\n * @param {TokenType} stringType\n *   Type for the value (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of title.\n   *\n   * ```markdown\n   * > | \"a\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      effects.enter(type)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      marker = code === 40 ? 41 : code\n      return begin\n    }\n    return nok(code)\n  }\n\n  /**\n   * After opening marker.\n   *\n   * This is also used at the closing marker.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function begin(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    return atBreak(code)\n  }\n\n  /**\n   * At something, before something else.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return begin(marker)\n    }\n    if (code === null) {\n      return nok(code)\n    }\n\n    // Note: blank lines can’t exist in content.\n    if (markdownLineEnding(code)) {\n      // To do: use `space_or_tab_eol_with_options`, connect.\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atBreak, 'linePrefix')\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return inside(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? escape : inside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | \"a\\*b\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function escape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return inside\n    }\n    return inside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of thematic break.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('thematicBreak')\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at marker.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    marker = code\n    return atBreak(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n    if (size >= 3 && (code === null || markdownLineEnding(code))) {\n      effects.exit('thematicBreak')\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n    effects.exit('thematicBreakSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, atBreak, 'whitespace')(code)\n      : atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   line endings or spaces in markdown are often optional, in which case this\n *     factory can be used and `ok` will be switched to whether spaces were found\n *     or not\n * *   one line ending or space can be detected with\n *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @returns\n *   Start state.\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n/**\n * Parse destinations.\n *\n * ###### Examples\n *\n * ```markdown\n * <a>\n * <a\\>b>\n * <a b>\n * <a)>\n * a\n * a\\)b\n * a(b)c\n * a(b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type for whole (`<a>` or `b`).\n * @param {TokenType} literalType\n *   Type when enclosed (`<a>`).\n * @param {TokenType} literalMarkerType\n *   Type for enclosing (`<` and `>`).\n * @param {TokenType} rawType\n *   Type when not enclosed (`b`).\n * @param {TokenType} stringType\n *   Type for the value (`a` or `b`).\n * @param {number | undefined} [max=Infinity]\n *   Depth of nested parens (inclusive).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n\n  /**\n   * Start of destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *     ^\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return enclosedBefore\n    }\n\n    // ASCII control, space, closing paren.\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return raw(code)\n  }\n\n  /**\n   * After `<`, at an enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return enclosed(code)\n  }\n\n  /**\n   * In enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return enclosedBefore(code)\n    }\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? enclosedEscape : enclosed\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | <a\\*a>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return enclosed\n    }\n    return enclosed(code)\n  }\n\n  /**\n   * In raw destination.\n   *\n   * ```markdown\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function raw(code) {\n    if (\n      !balance &&\n      (code === null || code === 41 || markdownLineEndingOrSpace(code))\n    ) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n    if (balance < limit && code === 40) {\n      effects.consume(code)\n      balance++\n      return raw\n    }\n    if (code === 41) {\n      effects.consume(code)\n      balance--\n      return raw\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesn’t.\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? rawEscape : raw\n  }\n\n  /**\n   * After `\\`, at special character.\n   *\n   * ```markdown\n   * > | a\\*a\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function rawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return raw\n    }\n    return raw(code)\n  }\n}\n"],"names":["setextUnderline","name","tokenize","effects","ok","nok","self","this","marker","code","paragraph","index","events","length","type","parser","lazy","now","line","interrupt","enter","inside","before","consume","exit","markdownSpace","factorySpace","after","markdownLineEnding","resolveTo","context","content","text","definition","splice","heading","start","Object","assign","end","push","factoryLabel","markerType","stringType","seen","size","atBreak","constructs","contentType","labelInside","labelEscape","factoryTitle","begin","escape","thematicBreak","sequence","factoryWhitespace","factoryDestination","literalType","literalMarkerType","rawType","max","limit","Number","POSITIVE_INFINITY","balance","enclosedBefore","asciiControl","raw","enclosed","enclosedEscape","markdownLineEndingOrSpace","rawEscape"],"sourceRoot":""}
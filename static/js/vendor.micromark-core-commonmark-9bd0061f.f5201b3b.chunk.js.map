{"version":3,"file":"static/js/vendor.micromark-core-commonmark-9bd0061f.f5201b3b.chunk.js","mappings":"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","sources":["../node_modules/micromark-core-commonmark/lib/line-ending.js","../node_modules/micromark-core-commonmark/lib/list.js","../node_modules/micromark-core-commonmark/lib/label-end.js","../node_modules/micromark-core-commonmark/lib/label-start-image.js","../node_modules/micromark-core-commonmark/lib/label-start-link.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means we’d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We can’t have that, so it’s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, it’s nothing.\n   *\n   * There was an okay opening, but we didn’t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if there’s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (image) start.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  /**\n   * After `!`, at `[`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `![`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *         ^\n   * ```\n   *\n   * This is needed in because, when GFM footnotes are enabled, images never\n   * form when started with a `^`.\n   * Instead, links form:\n   *\n   * ```markdown\n   * ![^a](b)\n   *\n   * ![^a][b]\n   *\n   * [b]: c\n   * ```\n   *\n   * ```html\n   * <p>!<a href=\\\"b\\\">^a</a></p>\n   * <p>!<a href=\\\"c\\\">^a</a></p>\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // To do: use a new field to do this, this is still needed for\n    // `micromark-extension-gfm-footnote`, but the `label-start-link`\n    // behavior isn’t.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (link) start.\n   *\n   * ```markdown\n   * > | a [b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  /** @type {State} */\n  function after(code) {\n    // To do: this isn’t needed in `micromark-extension-gfm-footnote`,\n    // remove.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n"],"names":["lineEnding","name","tokenize","effects","ok","code","enter","consume","exit","factorySpace","list","nok","self","this","tail","events","length","initialSize","type","sliceSerialize","size","kind","containerState","marker","asciiDigit","_container","check","thematicBreak","atMarker","interrupt","inside","blankLine","onBlank","attempt","listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","markdownSpace","continuation","_closeFlow","undefined","furtherBlankLines","notInCurrentItem","indentConstruct","parser","constructs","disable","null","includes","partial","labelEnd","labelStart","defined","index","_balanced","_inactive","labelEndNok","normalizeIdentifier","start","end","now","after","resourceConstruct","labelEndOk","referenceFullConstruct","referenceNotFull","referenceCollapsedConstruct","resolveTo","context","token","open","close","media","offset","group","Object","assign","label","text","push","slice","resolveAll","insideSpan","splice","resourceBefore","markdownLineEndingOrSpace","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","factoryLabel","call","referenceFullAfter","referenceFullMissing","referenceCollapsedOpen","labelStartImage","labelStartLink"],"sourceRoot":""}
{"version":3,"file":"static/js/chat-messagelist.89450d89.chunk.js","mappings":"8IAKO,MAwTMA,EAA2BC,IAEtC,GAAoB,iBAATA,GAA8B,KAATA,EAC9B,MAAO,GAOT,MAaMC,EAAgB,IAAIC,OACxB,6HACA,MAIF,IAAIC,EAASH,EAAKI,QAAQH,GAAe,CACvCI,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,SAGgBC,IAAZR,EACKA,OAIaQ,IAAlBP,EAEK,GAAGA,MAAkBC,WAIPM,IAAnBJ,EAEK,GAAGA,MAAmBC,WAING,IAArBD,EAEK,IAAIA,EAAiBE,UAIvBV,IAWT,OAHAF,EAASA,EAAOC,QAAQ,UAAW,QACnCD,EAASA,EAAOC,QAAQ,UAAW,QAE5BD,CAAM,C","sources":["utils/formatters.js"],"sourcesContent":["/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...]\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};"],"names":["convertTeXToMathDollars","text","combinedRegex","RegExp","result","replace","match","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","undefined","trim"],"sourceRoot":""}
{"version":3,"file":"static/js/markdown-49ceb22a.d7ab05ee.chunk.js","mappings":"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","sources":["../node_modules/rehype-raw/lib/index.js","../node_modules/remark-math/index.js","../node_modules/remark-gfm/index.js","../node_modules/react-markdown/node_modules/vfile/lib/minpath.browser.js","../node_modules/react-markdown/node_modules/vfile/lib/minproc.browser.js","../node_modules/react-markdown/node_modules/vfile/lib/minurl.shared.js","../node_modules/react-markdown/node_modules/vfile/lib/minurl.browser.js","../node_modules/react-markdown/node_modules/vfile/lib/index.js","../node_modules/remark-emoji/index.ts"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast-util-raw').Options} RawOptions\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {Omit<RawOptions, 'file'>} Options\n *   Configuration.\n */\n\nimport {raw} from 'hast-util-raw'\n\n/**\n * Parse the tree (and raw nodes) again, keeping positional info okay.\n *\n * @param {Options | null | undefined}  [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeRaw(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {Root}\n   *   New tree.\n   */\n  return function (tree, file) {\n    // Assume root in -> root out.\n    const result = /** @type {Root} */ (raw(tree, {...options, file}))\n    return result\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether it’s a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string | URL} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` — `{value: options}`\n   * *   `URL` — `{path: options}`\n   * *   `VFile` — shallow copies its data over to the new file\n   * *   `object` — all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * It’s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesn’t understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there’s no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there’s no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it’s a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > 👉 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","import { get as getEmoji } from 'node-emoji';\nimport { emoticon } from 'emoticon';\nimport { findAndReplace, type Find, type Replace } from 'mdast-util-find-and-replace';\nimport type { Plugin } from 'unified';\nimport type { Root, Nodes, Text } from 'mdast';\n\nconst RE_EMOJI = /:\\+1:|:-1:|:[\\w-]+:/g;\nconst RE_SHORT = /[$@|*'\",;.=:\\-)([\\]\\\\/<>038BOopPsSdDxXzZ]{2,5}/g;\nconst RE_PUNCT = /(?:_|-(?!1))/g;\n\n/**\n * Configuration of remark-emoji plugin.\n */\nexport interface RemarkEmojiOptions {\n    /**\n     * Makes converted emoji and emoticon texts accessible by wrapping them with\n     * `span` element setting `role` and `aria-label` attributes.\n     *\n     * @defaultValue false\n     */\n    accessible?: boolean;\n    /**\n     * Adds an extra whitespace after emoji.\n     * Useful when browser handle emojis with half character length and\n     * the following character is hidden.\n     *\n     * @defaultValue false\n     */\n    padSpaceAfter?: boolean;\n    /**\n     * Whether to support emoticon shortcodes (e.g. :-) will be replaced by 😃)\n     *\n     * @defaultValue false\n     */\n    emoticon?: boolean;\n}\n\nconst DEFAULT_SETTINGS: RemarkEmojiOptions = {\n    padSpaceAfter: false,\n    emoticon: false,\n    accessible: false,\n};\n\nconst plugin: Plugin<[(RemarkEmojiOptions | null | undefined)?], Root> = options => {\n    const settings = Object.assign({}, DEFAULT_SETTINGS, options);\n    const pad = !!settings.padSpaceAfter;\n    const emoticonEnable = !!settings.emoticon;\n    const accessible = !!settings.accessible;\n\n    function aria(text: string, label: string): Text {\n        // Creating HTML node in Markdown node is undocumented.\n        // https://github.com/syntax-tree/mdast-util-math/blob/e70bb824dc70f5423324b31b0b68581cf6698fe8/index.js#L44-L55\n        return {\n            type: 'text',\n            value: text,\n            data: {\n                hName: 'span',\n                hProperties: {\n                    role: 'img',\n                    ariaLabel: label,\n                },\n                hChildren: [{ type: 'text', value: text }],\n            },\n        };\n    }\n\n    function replaceEmoticon(match: string): string | false | Text {\n        // find emoji by shortcode - full match or with-out last char as it could be from text e.g. :-),\n        const iconFull = emoticon.find(e => e.emoticons.includes(match)); // full match\n        const iconPart = emoticon.find(e => e.emoticons.includes(match.slice(0, -1))); // second search pattern\n        const icon = iconFull || iconPart;\n        if (!icon) {\n            return false;\n        }\n        const trimmedChar = !iconFull && iconPart ? match.slice(-1) : '';\n        const addPad = pad ? ' ' : '';\n        const replaced = icon.emoji + addPad + trimmedChar;\n        if (accessible) {\n            return aria(replaced, icon.name + ' emoticon');\n        }\n        return replaced;\n    }\n\n    function replaceEmoji(match: string): string | false | Text {\n        let got = getEmoji(match);\n\n        if (typeof got === 'undefined') {\n            return false;\n        }\n\n        if (pad) {\n            got = got + ' ';\n        }\n\n        if (accessible) {\n            const label = match.slice(1, -1).replace(RE_PUNCT, ' ') + ' emoji';\n            return aria(got, label);\n        }\n\n        return got;\n    }\n\n    const replacers: [Find, Replace][] = [[RE_EMOJI, replaceEmoji]];\n    if (emoticonEnable) {\n        replacers.push([RE_SHORT, replaceEmoticon]);\n    }\n\n    function transformer(tree: Nodes): void {\n        findAndReplace(tree, replacers);\n    }\n\n    return transformer;\n};\n\nexport default plugin;\n"],"names":["rehypeRaw","options","tree","file","raw","remarkMath","arguments","length","undefined","data","this","add","field","value","push","math","mathFromMarkdown","mathToMarkdown","remarkGfm","gfm","gfmFromMarkdown","gfmToMarkdown","path","basename","ext","TypeError","assertPath","seenNonSlash","start","end","index","charCodeAt","slice","firstNonSlashEnd","extIndex","dirname","unmatchedSlash","extname","startPart","startDot","preDotState","code","join","joined","_len","segments","Array","_key","absolute","allowAboveRoot","lastSlashIndex","result","lastSegmentLength","lastSlash","dots","lastIndexOf","normalizeString","normalize","sep","JSON","stringify","proc","cwd","isUrl","fileUrlOrPath","href","origin","urlToPath","URL","error","protocol","url","hostname","pathname","third","decodeURIComponent","getPathFromURLPosix","order","VFile","constructor","bufferLike","buffer","messages","history","stored","map","prop","includes","assertNonEmpty","assertPart","Error","stem","toString","encoding","message","reason","place","VFileMessage","name","fatal","info","fail","part","RE_EMOJI","RE_SHORT","RE_PUNCT","DEFAULT_SETTINGS","padSpaceAfter","emoticon","accessible","settings","Object","assign","pad","emoticonEnable","aria","text","label","type","hName","hProperties","role","ariaLabel","hChildren","replacers","match","got","getEmoji","replace","iconFull","find","e","emoticons","iconPart","icon","trimmedChar","addPad","replaced","emoji","findAndReplace"],"sourceRoot":""}
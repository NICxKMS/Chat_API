{"version":3,"file":"static/js/vendor.micromark-core-commonmark-63b8257e.8cd133340d.chunk.v1_9_0.js","mappings":"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","sources":["../node_modules/micromark-core-commonmark/lib/setext-underline.js","../node_modules/micromark-core-commonmark/lib/thematic-break.js","../node_modules/micromark-core-commonmark/lib/list.js","../node_modules/micromark-core-commonmark/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-core-commonmark/node_modules/micromark-util-character/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = 'setextHeadingText'\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== 'lineEnding' &&\n        self.events[index][1].type !== 'linePrefix' &&\n        self.events[index][1].type !== 'content'\n      ) {\n        paragraph = self.events[index][1].type === 'paragraph'\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      marker = code\n      return before(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('setextHeadingLineSequence')\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    effects.exit('setextHeadingLineSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'lineSuffix')(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of thematic break.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('thematicBreak')\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at marker.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    marker = code\n    return atBreak(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n    if (size >= 3 && (code === null || markdownLineEnding(code))) {\n      effects.exit('thematicBreak')\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n    effects.exit('thematicBreakSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, atBreak, 'whitespace')(code)\n      : atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n"],"names":["setextUnderline","name","tokenize","effects","ok","nok","self","this","marker","code","paragraph","index","events","length","type","parser","lazy","now","line","interrupt","enter","inside","before","consume","exit","markdownSpace","factorySpace","after","markdownLineEnding","resolveTo","context","content","text","definition","splice","heading","start","Object","assign","end","push","thematicBreak","size","atBreak","sequence","list","tail","initialSize","sliceSerialize","kind","containerState","asciiDigit","_container","check","atMarker","blankLine","onBlank","attempt","listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","continuation","_closeFlow","undefined","furtherBlankLines","notInCurrentItem","indentConstruct","constructs","disable","null","includes","partial","asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","asciiHexDigit","asciiPunctuation","markdownLineEndingOrSpace","regex","test","String","fromCharCode"],"sourceRoot":""}
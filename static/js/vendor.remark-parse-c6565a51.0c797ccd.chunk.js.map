{"version":3,"file":"static/js/vendor.remark-parse-c6565a51.0c797ccd.chunk.js","mappings":"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","sources":["../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/list.js","../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/line-ending.js","../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-start-link.js","../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-start-image.js","../node_modules/remark-parse/node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Canâ€™t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As weâ€™re closing flow, weâ€™re no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (link) start.\n   *\n   * ```markdown\n   * > | a [b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  /** @type {State} */\n  function after(code) {\n    // To do: this isnâ€™t needed in `micromark-extension-gfm-footnote`,\n    // remove.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (image) start.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  /**\n   * After `!`, at `[`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `![`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *         ^\n   * ```\n   *\n   * This is needed in because, when GFM footnotes are enabled, images never\n   * form when started with a `^`.\n   * Instead, links form:\n   *\n   * ```markdown\n   * ![^a](b)\n   *\n   * ![^a][b]\n   *\n   * [b]: c\n   * ```\n   *\n   * ```html\n   * <p>!<a href=\\\"b\\\">^a</a></p>\n   * <p>!<a href=\\\"c\\\">^a</a></p>\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // To do: use a new field to do this, this is still needed for\n    // `micromark-extension-gfm-footnote`, but the `label-start-link`\n    // behavior isnâ€™t.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n"],"names":["list","name","tokenize","effects","ok","nok","self","this","tail","events","length","initialSize","type","sliceSerialize","size","code","kind","containerState","marker","asciiDigit","enter","_container","check","thematicBreak","atMarker","interrupt","inside","consume","exit","blankLine","onBlank","attempt","listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","markdownSpace","continuation","_closeFlow","undefined","furtherBlankLines","factorySpace","notInCurrentItem","indentConstruct","parser","constructs","disable","null","includes","partial","lineEnding","labelStartLink","after","resolveAll","labelEnd","labelStartImage","open","labelStart","defined","index","_balanced","_inactive","labelEndNok","normalizeIdentifier","start","end","now","resourceConstruct","labelEndOk","referenceFullConstruct","referenceNotFull","referenceCollapsedConstruct","resolveTo","context","token","close","media","offset","group","Object","assign","label","text","push","slice","insideSpan","splice","resourceBefore","markdownLineEndingOrSpace","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","factoryLabel","call","referenceFullAfter","referenceFullMissing","referenceCollapsedOpen"],"sourceRoot":""}
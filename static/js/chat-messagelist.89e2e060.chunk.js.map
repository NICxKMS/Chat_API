{"version":3,"file":"static/js/chat-messagelist.89e2e060.chunk.js","mappings":"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","sources":["utils/formatters.js","utils/messageHelpers.js","components/common/LazyMarkdownRenderer/index.js","components/chat/ChatMessage/index.js","components/common/ImageOverlay/index.js","components/chat/MessageList/index.js"],"sourcesContent":["/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","import React, { lazy, Suspense } from 'react';\n\n// Lazy-load the heavy Markdown renderer only when first used\nconst MarkdownRenderer = lazy(() => import(/* webpackChunkName: \"markdown-renderer\", webpackPrefetch: true */ './MarkdownRenderer'));\n\nexport default function LazyMarkdownRenderer({ children }) {\n  return (\n    <Suspense fallback={<div>{children}</div>}>\n      <MarkdownRenderer>{children}</MarkdownRenderer>\n    </Suspense>\n  );\n} ","// eslint-disable import/first\nimport React, { memo, useMemo, useState, useEffect, useCallback, lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport { PersonIcon, CopilotIcon, GearIcon, AlertIcon, CheckIcon, CopyIcon, ClockIcon, PulseIcon, PencilIcon } from '@primer/octicons-react';\nimport styles from './ChatMessage.module.css';\nimport { formatTime } from '../../../utils/messageHelpers';\nimport { convertTeXToMathDollars } from '../../../utils/formatters';\n// Lazy-load Markdown renderer for user/system/error messages\nimport LazyMarkdownRenderer from '../../common/LazyMarkdownRenderer';\n// Dynamically load StreamingMessage to defer heavy modules\nconst StreamingMessage = lazy(() => import(/* webpackChunkName: \"streaming-message\", webpackPrefetch: true */ './StreamingMessage'));\n\n// Add a module-level singleton for the TeX worker so we only load the worker script once\nlet texWorker;\nconst getTexWorker = () => {\n  if (typeof Worker !== 'undefined' && !texWorker) {\n    texWorker = new Worker(new URL('../../../workers/texProcessor.js', import.meta.url), { type: 'module' });\n  }\n  return texWorker;\n};\n\n/**\n * ChatMessage component with optimized rendering for streaming content\n * @param {Object} props - Component props\n * @param {string} props.role - Message role (user, assistant, system, error)\n * @param {string} props.content - Message content\n * @param {number} props.index - Message index in the chat history\n * @param {boolean} props.isStreaming - Whether this message is currently streaming\n * @returns {JSX.Element} - Rendered component\n */\nconst ChatMessage = ({ message, isStreaming, onEditMessage }) => {\n  const [messageCopied, setMessageCopied] = useState(false);\n  const defaultProcessedMessage = useMemo(() => (\n    message.role === 'assistant'\n      ? message.content\n      : convertTeXToMathDollars(message.content)\n  ), [message.content, message.role]);\n  const [processedMessage, setProcessedMessage] = useState(defaultProcessedMessage);\n\n  useEffect(() => {\n    if (message.role !== 'assistant' || typeof message.content !== 'string' || typeof Worker === 'undefined') {\n      return;\n    }\n    const id = message.timestamp;\n    const worker = getTexWorker();\n    const handleMessage = (e) => {\n      if (e.data.id !== id) return;\n      if (e.data.success) setProcessedMessage(e.data.data);\n      else setProcessedMessage(message.content);\n    };\n    worker.addEventListener('message', handleMessage);\n    worker.postMessage({ id, content: message.content });\n    return () => {\n      worker.removeEventListener('message', handleMessage);\n    };\n  }, [message.content, message.role, message.timestamp]);\n  \n  // Choose appropriate icon based on message role\n  const icon = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return <PersonIcon size={16} className={styles.icon} />;\n      case 'assistant':\n        return <CopilotIcon size={16} className={styles.icon} />;\n      case 'system':\n        return <GearIcon size={16} className={styles.icon} />;\n      case 'error':\n        return <AlertIcon size={16} className={styles.icon} />;\n      default:\n        return null;\n    }\n  }, [message.role]);\n  \n  // Select CSS classes based on message role\n  const messageClass = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return styles.userMessage;\n      case 'assistant':\n        return styles.assistantMessage;\n      case 'system':\n        return styles.systemMessage;\n      case 'error':\n        return styles.errorMessage;\n      default:\n        return '';\n    }\n  }, [message.role]);\n  \n  // Determine if we should show metrics (only for assistant messages)\n  const shouldShowMetrics = useMemo(() => {\n    // Show metrics if this is an assistant message with any metrics\n    if (message.role !== 'assistant' || !message.metrics) return false;\n    return true;\n  }, [message.role, message.metrics]);\n  \n  // Copy message content to clipboard\n  const handleCopyMessage = useCallback(() => {\n    const content = typeof message.content === 'string' \n      ? message.content \n      : Array.isArray(message.content) \n        ? message.content\n            .filter(part => part.type === 'text')\n            .map(part => part.text)\n            .join('\\n')\n        : '';\n    navigator.clipboard.writeText(content).then(() => {\n      setMessageCopied(true);\n      setTimeout(() => setMessageCopied(false), 2000);\n    });\n  }, [message.content]);\n  \n  // === BUTTON JSX (Moved here for reuse) ===\n  const copyButtonJsx = useMemo(() => (\n    <button\n      className={`${styles.copyMessageButton} ${\n        (message.role === 'assistant' && shouldShowMetrics) ? styles.copyButtonInMetrics : styles.copyButtonBottomRight\n      }`}\n      onClick={handleCopyMessage}\n      aria-label=\"Copy message\"\n      title=\"Copy message\"\n    >\n      {messageCopied ? <CheckIcon size={16} /> : <CopyIcon size={16} />}\n    </button>\n  ), [handleCopyMessage, message.role, shouldShowMetrics, messageCopied]);\n\n  // Edit button only for user messages\n  const handleEditClick = useCallback(() => {\n    if (onEditMessage) onEditMessage(message);\n  }, [onEditMessage, message]);\n  const editButtonJsx = useMemo(() => message.role === 'user' ? (\n    <button\n      className={styles.editMessageButton}\n      onClick={handleEditClick}\n      aria-label=\"Edit message\"\n      title=\"Edit message\"\n    >\n      <PencilIcon size={16} />\n    </button>\n  ) : null, [message.role, handleEditClick]);\n  // ==========================================\n  \n  // Render performance metrics (only for assistant messages)\n  const renderMetrics = () => {\n    if (!shouldShowMetrics || !message.metrics) return null;\n    \n    // Use the specific isStreaming prop passed down to determine if THIS message is generating\n    const isGenerating = isStreaming;\n    const { \n      elapsedTime, \n      tokenCount, \n      tokensPerSecond, \n      timeToFirstToken, \n      promptTokens, \n      completionTokens, \n      totalTokens,\n      finishReason \n    } = message.metrics;\n    \n    // Check if we have any valid metrics to show\n    const hasValidMetrics = \n      elapsedTime != null || \n      tokenCount != null || \n      tokensPerSecond != null || \n      timeToFirstToken != null ||\n      promptTokens != null ||\n      completionTokens != null ||\n      totalTokens != null ||\n      finishReason != null;\n      \n    // Don't render anything if no valid metrics are found\n    if (!hasValidMetrics) return null;\n    \n    return (\n      <div className={styles.metricsContainer}>\n        {/* Time metrics */}\n        {timeToFirstToken != null && timeToFirstToken !== 0 && (\n          <span className={styles.metric}>\n            <ClockIcon size={14} className={styles.metricIcon} />\n            First Token: {formatTime(timeToFirstToken)}\n          </span>\n        )}\n        {elapsedTime != null && elapsedTime !== 0 && (\n          <span className={styles.metric}>\n            <ClockIcon size={14} className={styles.metricIcon} />\n            Total Time: {formatTime(elapsedTime)}\n          </span>\n        )}\n        \n        {/* Token metrics */}\n        {tokenCount != null && tokenCount !== 0 && (\n          <span className={styles.metric}>\n            <CopilotIcon size={14} className={styles.metricIcon} />\n            Tokens: {tokenCount}\n          </span>\n        )}\n        {promptTokens != null && promptTokens !== 0 && (\n          <span className={styles.metric}>\n            <CopilotIcon size={14} className={styles.metricIcon} />\n            Prompt: {promptTokens}\n          </span>\n        )}\n        {completionTokens != null && completionTokens !== 0 && (\n          <span className={styles.metric}>\n            <CopilotIcon size={14} className={styles.metricIcon} />\n            Completion: {completionTokens}\n          </span>\n        )}\n        {totalTokens != null && totalTokens !== 0 && (\n          <span className={styles.metric}>\n            <CopilotIcon size={14} className={styles.metricIcon} />\n            Total: {totalTokens}\n          </span>\n        )}\n        \n        {/* Speed metrics */}\n        {tokensPerSecond != null && tokensPerSecond !== 0 && (\n          <span className={styles.metric}>\n            <PulseIcon size={14} className={styles.metricIcon} />\n            Speed: {tokensPerSecond} t/s\n          </span>\n        )}\n        \n        {/* Status */}\n        {finishReason != null && finishReason !== '' && (\n          <span className={styles.metric}>\n            <AlertIcon size={14} className={styles.metricIcon} />\n            {finishReason}\n          </span>\n        )}\n        {isGenerating && (\n          <span className={`${styles.metric} ${styles.generatingIndicator}`}>\n            <span className={styles.generatingDot}></span>\n            Generating...\n          </span>\n        )}\n        \n        {/* Copy button */}\n        {copyButtonJsx}\n      </div>\n    );\n  };\n  \n  // Main return\n  return (\n    <div className={styles.message + ' ' + messageClass}>\n      {/* Avatar */}\n      <div className={styles.avatar}>{icon}</div>\n\n      {/* Message content section */}\n      <div className={styles.messageContentWrapper}>\n        <Suspense fallback={null}>\n          <div className={styles.messageContent}>\n            {message.role === 'assistant' ? (\n              <StreamingMessage\n                content={processedMessage}\n                isStreaming={isStreaming}\n              />\n            ) : (\n              // Render markdown lazily for user/system/error messages\n              <LazyMarkdownRenderer>\n                {processedMessage}\n              </LazyMarkdownRenderer>\n            )}\n          </div>\n        </Suspense>\n\n        {/* Render performance metrics for assistant messages */}\n        {message.role === 'assistant' && renderMetrics()}\n\n        {/* Copy button for non-user messages, hide when assistant metrics exist */}\n        {message.role !== 'user' && (message.role !== 'assistant' || !shouldShowMetrics) && copyButtonJsx}\n      </div>\n\n      {/* User-specific buttons */}\n      {message.role === 'user' && (\n        <div className={styles.userButtonContainer}>\n          {editButtonJsx}\n          {copyButtonJsx}\n        </div>\n      )}\n    </div>\n  );\n};\n\nChatMessage.propTypes = {\n  message: PropTypes.shape({\n    role: PropTypes.string.isRequired,\n    content: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.array\n    ]).isRequired\n  }).isRequired,\n  isStreaming: PropTypes.bool,\n  onEditMessage: PropTypes.func\n};\n\nexport default memo(ChatMessage); ","import ReactDOM from 'react-dom'; // Import ReactDOM\nimport PropTypes from 'prop-types';\nimport styles from './ImageOverlay.module.css';\n\n/**\n * Full-screen overlay for displaying an image using React Portal.\n * Clicking anywhere on the overlay closes it.\n */\nconst ImageOverlay = ({ src, onClose }) => {\n  if (!src) return null;\n\n  // Prevent clicks on the image itself from closing if needed (optional)\n  const handleImageClick = (e) => {\n    e.stopPropagation(); // Prevents the overlay click handler from firing\n    // Could potentially add other actions here, like zoom controls\n  };\n\n  // The overlay content\n  const overlayContent = (\n    <div className={styles.overlay} onClick={onClose} role=\"dialog\" aria-modal=\"true\" title=\"Click to close image\">\n      <img \n        src={src} \n        alt=\"Full screen view\" \n        className={styles.overlayImage}\n        onClick={handleImageClick} // Handle clicks on the image specifically\n      />\n    </div>\n  );\n\n  // Use ReactDOM.createPortal to render the overlay into document.body\n  return ReactDOM.createPortal(\n    overlayContent,\n    document.body \n  );\n};\n\nImageOverlay.propTypes = {\n  /** The URL of the image to display */\n  src: PropTypes.string,\n  /** Function to call when the overlay should be closed */\n  onClose: PropTypes.func.isRequired,\n};\n\nexport default ImageOverlay; ","import { forwardRef, useState, useMemo, memo } from 'react';\nimport styles from './MessageList.module.css';\nimport { useChatState } from '../../../contexts/ChatStateContext';\nimport ChatMessage from '../ChatMessage';\nimport ImageOverlay from '../../common/ImageOverlay';\nimport PropTypes from 'prop-types';\nimport { processMessageContent } from '../../../utils/messageHelpers';\n\n/**\n * Simple message list without virtualization\n * @param {Object} props - Component props\n * @param {Array} props.messages - Array of message objects\n * @param {string} props.error - Error message to display\n * @param {Function} props.onEditMessage - Function to handle message edit requests\n * @returns {JSX.Element} - Rendered component\n */\nconst MessageList = forwardRef(({ messages, error, onEditMessage }, ref) => {\n  const { isWaitingForResponse } = useChatState();\n  const [overlayImageSrc, setOverlayImageSrc] = useState(null);\n\n  // Combine regular messages with error content (if any)\n  const finalMessages = useMemo(() => {\n    const result = [...messages];\n    \n    // Add error message if any\n    if (error) {\n      result.push({\n        role: 'error',\n        content: error,\n        timestamp: Date.now()\n      });\n    }\n    \n    return result;\n  }, [messages, error]);\n\n  // Handlers for overlay\n  const handleImageClick = (src) => {\n    setOverlayImageSrc(src);\n  };\n\n  const handleCloseOverlay = () => {\n    setOverlayImageSrc(null);\n  };\n\n  return (\n    <>\n      <div \n        className={styles.messageListContainer} \n        ref={ref}\n        aria-live=\"polite\"\n        aria-relevant=\"additions text\"\n      >\n        {finalMessages.map((message, index) => {\n          // Determine if this message is currently streaming\n          const isLastMessage = index === finalMessages.length - 1;\n          const isStreaming = message.role === 'assistant' && \n                              isLastMessage && \n                              isWaitingForResponse &&\n                              !message.metrics?.isComplete;\n          \n          // Process message content for images and text\n          const { images, text } = processMessageContent(message.content);\n          \n          // Generate a unique key using timestamp if available, fallback to role-index\n          const messageKey = message.timestamp \n            ? `${message.role}-${message.timestamp}-${index}`\n            : `${message.role}-${index}`;\n          \n          return (\n            <div key={messageKey} className={styles.messageRow}>\n              {/* Render images first if it's a user message with images */}\n              {message.role === 'user' && images.length > 0 && (\n                <div className={styles.imageContainer}>\n                  {images.map((image, imgIndex) => (\n                    <img \n                      key={`${messageKey}-img-${imgIndex}`}\n                      src={image.url}\n                      alt={image.alt || `Uploaded image ${imgIndex + 1}`}\n                      className={`${styles.messageImage} ${styles.clickableImage}`}\n                      onClick={() => handleImageClick(image.url)}\n                    />\n                  ))}\n                </div>\n              )}\n              {/* Render ChatMessage if there's text content or it's not a user message */}\n              {(text || message.role !== 'user') && (\n                <ChatMessage\n                  message={{ ...message, content: text || message.content }}\n                  isStreaming={isStreaming}\n                  onEditMessage={message.role === 'user' ? onEditMessage : undefined}\n                />\n              )}\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Render the overlay component */}\n      <ImageOverlay src={overlayImageSrc} onClose={handleCloseOverlay} />\n    </>\n  );\n});\n\nMessageList.displayName = 'MessageList';\n\nMessageList.propTypes = {\n  messages: PropTypes.array.isRequired,\n  error: PropTypes.string,\n  onEditMessage: PropTypes.func\n};\n\nexport default memo(MessageList); "],"names":["convertTeXToMathDollars","text","combinedRegex","RegExp","result","replace","match","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","undefined","trim","formatTime","ms","toFixed","MarkdownRenderer","lazy","LazyMarkdownRenderer","_ref","children","_jsx","Suspense","fallback","StreamingMessage","texWorker","ChatMessage","message","isStreaming","onEditMessage","messageCopied","setMessageCopied","useState","defaultProcessedMessage","useMemo","role","content","processedMessage","setProcessedMessage","useEffect","Worker","id","timestamp","worker","URL","type","handleMessage","e","data","success","addEventListener","postMessage","removeEventListener","icon","PersonIcon","size","className","styles","CopilotIcon","GearIcon","AlertIcon","messageClass","userMessage","assistantMessage","systemMessage","errorMessage","shouldShowMetrics","metrics","handleCopyMessage","useCallback","Array","isArray","filter","part","map","join","navigator","clipboard","writeText","then","setTimeout","copyButtonJsx","copyMessageButton","copyButtonInMetrics","copyButtonBottomRight","onClick","title","CheckIcon","CopyIcon","handleEditClick","editButtonJsx","editMessageButton","PencilIcon","_jsxs","avatar","messageContentWrapper","messageContent","renderMetrics","isGenerating","elapsedTime","tokenCount","tokensPerSecond","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","metricsContainer","metric","ClockIcon","metricIcon","PulseIcon","generatingIndicator","generatingDot","userButtonContainer","memo","src","onClose","overlayContent","overlay","alt","overlayImage","stopPropagation","ReactDOM","document","body","MessageList","forwardRef","ref","messages","error","isWaitingForResponse","useChatState","overlayImageSrc","setOverlayImageSrc","finalMessages","push","Date","now","_Fragment","messageListContainer","index","_message$metrics","isLastMessage","length","isComplete","images","texts","reduce","acc","url","image_url","processMessageContent","messageKey","messageRow","imageContainer","image","imgIndex","messageImage","clickableImage","handleImageClick","ImageOverlay","handleCloseOverlay","displayName"],"sourceRoot":""}
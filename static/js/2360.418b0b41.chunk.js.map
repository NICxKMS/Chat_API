{"version":3,"file":"static/js/2360.418b0b41.chunk.js","mappings":"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","sources":["../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/mdast-util-gfm/lib/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/mdast-util-to-string/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n"],"names":["gfmTableFromMarkdown","enter","table","token","align","_align","this","type","map","d","children","setData","tableData","enterCell","tableHeader","tableRow","exit","codeText","value","resume","getData","replace","stack","length","$0","$1","gfmTableToMarkdown","options","settings","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","unsafe","character","inConstruct","atBreak","after","handlers","node","_","context","safeOptions","serializeData","index","result","subexit","handleTableRowAsData","handleTableAsData","slice","indexOf","tableCell","handleTableCell","inlineCode","parent","includes","containerPhrasing","before","matrix","markdownTable","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","checked","head","siblings","firstParaghraph","sibling","shift","position","start","offset","column","Object","assign","gfmTaskListItemToMarkdown","listItem","checkable","checkbox","tracker","track","move","current","gfmFromMarkdown","gfmAutolinkLiteralFromMarkdown","gfmFootnoteFromMarkdown","gfmStrikethroughFromMarkdown","gfmToMarkdown","extensions","gfmAutolinkLiteralToMarkdown","gfmFootnoteToMarkdown","gfmStrikethroughToMarkdown","mathFromMarkdown","mathFlow","meta","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","mathText","mathFlowFence","mathFlowValue","exitMathData","mathTextData","config","call","mathToMarkdown","single","singleDollarTextMath","inlineMath","peek","undefined","math","raw","sequence","repeat","Math","max","longestStreak","safe","encode","size","RegExp","test","pattern","expression","patternCompile","match","exec","codePointAt","emptyOptions","toString","one","includeImageAlt","includeHtml","Boolean","alt","all","Array","isArray","values","join"],"sourceRoot":""}
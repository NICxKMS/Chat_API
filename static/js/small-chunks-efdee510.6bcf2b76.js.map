{"version":3,"file":"static/js/small-chunks-efdee510.6bcf2b76.js","mappings":"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","sources":["../node_modules/hast-util-parse-selector/index.js","../node_modules/hast-util-whitespace/index.js","../node_modules/hast-util-is-element/lib/index.js","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","../node_modules/inline-style-parser/index.js","../node_modules/hast-util-from-html-isomorphic/lib/browser.js"],"sourcesContent":["'use strict'\n\nmodule.exports = parse\n\nvar search = /[#.]/g\n\n// Create a hast element from a simple CSS selector.\nfunction parse(selector, defaultTagName) {\n  var value = selector || ''\n  var name = defaultTagName || 'div'\n  var props = {}\n  var start = 0\n  var subvalue\n  var previous\n  var match\n\n  while (start < value.length) {\n    search.lastIndex = start\n    match = search.exec(value)\n    subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        name = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (props.className) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {type: 'element', tagName: name, properties: props, children: []}\n}\n","/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parents} Parents\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is an element.\n * @param {unknown} this\n *   Context object (`this`) to call `test` with\n * @param {unknown} [element]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | null | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n *\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary element.\n *\n *   * when `string`, checks that the element has that tag name\n *   * when `function`, see `TestFunction`\n *   * when `Array`, checks if one of the subtests pass\n *\n * @callback TestFunction\n *   Check if an element passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Element} element\n *   An element.\n * @param {number | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean | undefined | void}\n *   Whether this element passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `element` is an `Element` and whether it passes the given test.\n *\n * @param element\n *   Thing to check, typically `element`.\n * @param test\n *   Check for a specific element.\n * @param index\n *   Position of `element` in its parent.\n * @param parent\n *   Parent of `element`.\n * @param context\n *   Context object (`this`) to call `test` with.\n * @returns\n *   Whether `element` is an `Element` and passes a test.\n * @throws\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\n *   thrown when `element` is not a node or not an element.\n */\nexport const isElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((element?: null | undefined) => false) &\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [element]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parents | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (element, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== null &&\n        index !== undefined &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite `index`')\n      }\n\n      if (\n        parent !== null &&\n        parent !== undefined &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected valid `parent`')\n      }\n\n      if (\n        (index === null || index === undefined) !==\n        (parent === null || parent === undefined)\n      ) {\n        throw new Error('Expected both `index` and `parent`')\n      }\n\n      return looksLikeAnElement(element)\n        ? check.call(context, element, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate a check from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * an `element`, `index`, and `parent`.\n *\n * @param test\n *   A test for a specific element.\n * @returns\n *   A check.\n */\nexport const convertElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      // Assume array.\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as `test`')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction tagNameFactory(check) {\n  return castFactory(tagName)\n\n  /**\n   * @param {Element} element\n   * @returns {boolean}\n   */\n  function tagName(element) {\n    return element.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeAnElement(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} element\n * @returns {element is Element}\n */\nfunction element(element) {\n  return Boolean(\n    element &&\n      typeof element === 'object' &&\n      'type' in element &&\n      element.type === 'element' &&\n      'tagName' in element &&\n      typeof element.tagName === 'string'\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Element}\n */\nfunction looksLikeAnElement(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    'tagName' in value\n  )\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\n */\n\nimport {fromDom} from 'hast-util-from-dom'\n\nconst parser = new DOMParser()\n\n/** @type {FromHtmlIsomorphic} */\nexport function fromHtmlIsomorphic(value, options) {\n  const node = options?.fragment\n    ? parseFragment(value)\n    : parser.parseFromString(value, 'text/html')\n\n  return /** @type {Root} */ (fromDom(node))\n}\n\n/**\n * Parse as a fragment.\n *\n * @param {string} value\n * @returns {DocumentFragment}\n */\nfunction parseFragment(value) {\n  const template = document.createElement('template')\n  template.innerHTML = value\n  return template.content\n}\n"],"names":["module","exports","selector","defaultTagName","subvalue","previous","match","value","name","props","start","length","search","lastIndex","exec","slice","index","id","className","push","type","tagName","properties","children","whitespace","thing","replace","convertElement","test","element","check","castFactory","tagNameFactory","tests","checks","any","_len","arguments","parameters","Array","_key","apply","this","anyFactory","Error","testFunction","parent","Boolean","looksLikeAnElement","call","undefined","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","set","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","_len2","args","_key2","unwrap","_len3","_key3","storeNames","tx","sort","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","openDB","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","method","async","storeName","store","shift","all","oldTraps","callback","COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","EMPTY_STRING","trim","str","style","options","TypeError","lineno","column","updatePosition","lines","i","lastIndexOf","position","line","node","Position","end","source","content","errorsList","msg","err","reason","filename","silent","re","m","comments","rules","comment","pos","charAt","declaration","val","ret","property","decl","decls","declarations","parser","DOMParser","fromHtmlIsomorphic","fragment","template","document","createElement","innerHTML","parseFragment","parseFromString","fromDom"],"sourceRoot":""}
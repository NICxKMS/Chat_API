{"version":3,"file":"static/js/small-chunks-31743c5a.b728333a.js","mappings":"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","sources":["hooks/useChatLogic.js","contexts/ThemeContext.js","contexts/SettingsContext.js","contexts/AuthContext.js","contexts/ContextManager.js","hooks/useCacheToggle.js","index.js","hooks/useMediaQuery.js","contexts/ApiContext.js","firebaseConfig.js","hooks/useLocalStorage.js","contexts/ModelContext.js"],"sourcesContent":["import { useCallback } from 'react';\nimport { useChat } from '../contexts/ChatContext';\nimport { useModel } from '../contexts/ModelContext';\nimport { useSettings } from '../contexts/SettingsContext';\n\n// Helper to generate unique IDs\nconst generateUniqueId = () => {\n  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n};\n\n/**\n * Custom Hook for Chat Container Logic\n * Encapsulates state management, API calls, and event handlers \n * related to the chat interface.\n */\nexport const useChatLogic = () => {\n  const { \n    chatHistory, \n    isWaitingForResponse, \n    error,\n    metrics,\n    submitMessage,\n    resetChat, \n    downloadChatHistory \n  } = useChat();\n  \n  const { selectedModel } = useModel();\n  const { settings } = useSettings();\n  \n  // Enhanced function to handle sending messages, including edits\n  const handleSendMessage = useCallback(async (message, editedMessage = null) => {\n    const isEditing = !!editedMessage;\n    \n    // Handle both string and array payloads for content validation\n    const messageContent = Array.isArray(message) \n      ? message.map(part => part.type === 'text' ? part.text : '').join(' ').trim()\n      : message;\n\n    if (!messageContent && !Array.isArray(message)) return;\n    if (!selectedModel) return;\n    \n    try {\n      if (isEditing) {\n        // Get or create unique identifier for the message\n        const editMsgId = editedMessage.uniqueId || editedMessage.id || editedMessage.timestamp;\n        \n        // Find the index of the message being edited\n        let editIndex = -1;\n        \n        // First try to find by uniqueId (most reliable)\n        if (editMsgId) {\n          editIndex = chatHistory.findIndex(msg => \n            msg.uniqueId === editMsgId || msg.id === editMsgId\n          );\n        }\n        \n        // If not found yet, try by timestamp as fallback\n        if (editIndex === -1 && editedMessage.timestamp) {\n          editIndex = chatHistory.findIndex(msg => \n            msg.timestamp === editedMessage.timestamp && msg.role === 'user'\n          );\n        }\n        \n        // Last resort: try by content match\n        if (editIndex === -1 && typeof editedMessage.content === 'string') {\n          editIndex = chatHistory.findIndex(msg => \n            typeof msg.content === 'string' && \n            msg.content === editedMessage.content && \n            msg.role === 'user'\n          );\n        }\n        \n        if (editIndex === -1) {\n          console.error(\"Could not find message to edit\");\n          console.log(\"Edited message:\", editedMessage);\n          console.log(\"Chat history:\", chatHistory.map(m => ({ \n            role: m.role, \n            uniqueId: m.uniqueId, \n            timestamp: m.timestamp,\n            contentPreview: typeof m.content === 'string' ? m.content.substring(0, 20) : 'non-string'\n          })));\n          return;\n        }\n        \n        // Ensure the message to be submitted has the correct uniqueId\n        const finalMessage = Array.isArray(message) \n          ? message \n          : { type: 'text', text: message };\n        \n        // Add uniqueId to message\n        if (Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = editMsgId;\n        } else {\n          finalMessage.uniqueId = editMsgId;\n        }\n        \n        // Call the submitMessage function with the truncated history index\n        await submitMessage(finalMessage, editIndex);\n      } else {\n        // For new messages, generate a unique ID\n        const uniqueId = generateUniqueId();\n        \n        // Add uniqueId to new message\n        const finalMessage = Array.isArray(message) \n          ? message.map(part => ({...part, uniqueId}))\n          : message;\n          \n        if (!Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = uniqueId;\n        }\n        \n        // Normal message submission with uniqueId\n        await submitMessage(finalMessage);\n      }\n    } catch (err) {\n      console.error(`Error ${isEditing ? 'editing' : 'submitting'} message:`, err);\n    }\n  }, [selectedModel, submitMessage, chatHistory]);\n\n  // Return values needed by the ChatContainer component\n  return {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics,\n    selectedModel,\n    settings,\n    handleSendMessage,\n    resetChat, \n    downloadChatHistory,\n  };\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n\n// Create theme context\nconst ThemeContext = createContext();\n\n// Custom hook for using theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n\n// Theme provider component\nexport const ThemeProvider = ({ children }) => {\n  // Initialize theme from localStorage or default to 'dark'\n  const [theme, setTheme] = useState(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return savedTheme || 'dark';\n  });\n\n  // Toggle between light and dark themes\n  const toggleTheme = useCallback(() => {\n    setTheme(prevTheme => {\n      const newTheme = prevTheme === 'dark' ? 'light' : 'dark';\n      localStorage.setItem('theme', newTheme);\n      return newTheme;\n    });\n  }, []);\n\n  // Apply theme class to body element\n  useEffect(() => {\n    document.body.classList.remove('light-mode', 'dark-mode');\n    document.body.classList.add(`${theme}-mode`);\n  }, [theme]);\n\n  // Context value - memoized to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme, toggleTheme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}; ","import { createContext, useContext, useState, useCallback, useMemo, useEffect } from 'react';\n\n// Default settings values\nconst DEFAULT_SETTINGS = {\n  temperature: 0.7,\n  top_p: 1.0,\n  max_tokens: 8191,\n  frequency_penalty: 0,\n  presence_penalty: 0,\n  streaming: true,\n  systemPrompt: \"You are ChatGPT, a helpful and knowledgeable AI assistant. Your primary role is to assist Nikhil, a university engineering student, by providing clear, concise, and technically accurate information. Adopt a friendly and approachable tone, akin to a knowledgeable peer or mentor. Enhance your responses with relevant emojis to convey tone and emotion, making interactions more engaging. Structure your answers logically, using bullet points or numbered lists where appropriate to enhance clarity. When applicable, incorporate interactive elements such as code snippets or diagrams to facilitate deeper understanding. Encourage curiosity by suggesting related topics or questions that Nikhil might explore further. Always tailor your assistance to support Nikhil's academic and personal growth in the field of engineering\"\n};\n\n// Load settings from localStorage if available\nconst loadSavedSettings = () => {\n  try {\n    const savedSettings = localStorage.getItem('chatSettings');\n    if (savedSettings) {\n      const parsed = JSON.parse(savedSettings);\n      \n      // Make sure streaming is explicitly defined \n      if (parsed.streaming === undefined) {\n        parsed.streaming = DEFAULT_SETTINGS.streaming;\n      }\n      \n      console.log('[DEBUG] Loaded settings:', parsed);\n      return {...DEFAULT_SETTINGS, ...parsed};\n    }\n  } catch (e) {\n    console.error('Error loading settings from localStorage:', e);\n  }\n  return DEFAULT_SETTINGS;\n};\n\n// Create settings context\nconst SettingsContext = createContext();\n\n// Custom hook for using settings\nexport const useSettings = () => {\n  const context = useContext(SettingsContext);\n  if (context === undefined) {\n    throw new Error('useSettings must be used within a SettingsProvider');\n  }\n  return context;\n};\n\n// Settings provider component\nexport const SettingsProvider = ({ children }) => {\n  // Initialize settings state with defaults and saved values\n  const [settings, setSettings] = useState(loadSavedSettings());\n  \n  // Save settings to localStorage when they change\n  useEffect(() => {\n    try {\n      localStorage.setItem('chatSettings', JSON.stringify(settings));\n      console.log('[DEBUG] Saved settings:', settings);\n    } catch (e) {\n      console.error('Error saving settings to localStorage:', e);\n    }\n  }, [settings]);\n  \n  // Handle individual setting updates\n  const updateSetting = useCallback((key, value) => {\n    // Ensure the key is a valid setting we manage\n    if (key in DEFAULT_SETTINGS) {\n      console.log(`[SettingsContext] Updating '${key}' from ${settings[key]} to ${value}`);\n      setSettings(prev => ({\n        ...prev,\n        [key]: value\n      }));\n    }\n  }, [settings]);\n  \n  // Reset settings to defaults\n  const resetSettings = useCallback(() => {\n    console.log(\"[SettingsContext] Resetting settings to default\");\n    setSettings(DEFAULT_SETTINGS);\n  }, []);\n  \n  // Check if temperature should be restricted based on model name/series\n  const shouldRestrictTemperature = useCallback((model) => {\n    if (!model) return false;\n    \n    // More explicit flag checking for temperature restriction\n    // Check for specific model properties that indicate temperature restriction\n    return (\n      model.requiresFixedTemperature === true || \n      (model.properties && model.properties.includes('fixed_temperature')) ||\n      (model.id && model.id.toLowerCase().startsWith('o')) ||\n      (model.series && model.series.toLowerCase() === 'o-series')\n    );\n  }, []);\n  \n  // Get current settings with potential model-specific overrides\n  const getModelAdjustedSettings = useCallback((model) => {\n    if (shouldRestrictTemperature(model)) {\n      return {\n        ...settings,\n        temperature: 1.0\n      };\n    }\n    return settings;\n  }, [settings, shouldRestrictTemperature]);\n  \n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings\n  }), [\n    settings,\n    updateSetting, \n    resetSettings, \n    shouldRestrictTemperature, \n    getModelAdjustedSettings\n  ]);\n  \n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n}; ","import { createContext, useContext, useState, useEffect } from 'react';\n// Firebase is dynamically imported to avoid blocking\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [idToken, setIdToken] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially - we're proceeding anonymously\n  const [error, setError] = useState(null);\n  const [isLoggingIn, setIsLoggingIn] = useState(false); // State to trigger login UI\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\n\n  const login = async () => {\n    // This function now simply signals the intent to log in.\n    // The actual login mechanism (popup, redirect) will be handled\n    // by a dedicated Login component/page triggered by isLoggingIn state.\n    console.log(\"Login button clicked, setting isLoggingIn to true.\");\n    setIsLoggingIn(true);\n  };\n\n  const logout = async () => {\n    // Only attempt logout if Firebase is initialized\n    if (!isFirebaseInitialized) {\n      console.log(\"Firebase not initialized yet, cannot logout.\");\n      return;\n    }\n    \n    // Dynamically import Firebase auth functions\n    const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n    const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n    const auth = getFirebaseAuth();\n    if (!auth) {\n      setError(\"Firebase not initialized.\");\n      return;\n    }\n    try {\n      await firebaseSignOut(auth);\n      console.log(\"Sign out successful.\");\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      setError(err.message || 'Failed to logout.');\n    }\n  };\n\n  // Effect to listen for Firebase auth state changes\n  useEffect(() => {\n    let unsubscribe = null;\n\n    // Listen for the 'firebaseInitialized' event from App.js\n    const handleFirebaseInit = () => {\n      console.log(\"Received Firebase initialized event\");\n      setIsFirebaseInitialized(true);\n      initializeAuthListener();\n    };\n\n    // Function to initialize auth listener\n    const initializeAuthListener = async () => {\n      setLoading(true);\n      // Dynamically import Firebase auth\n      const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n      const { onAuthStateChanged: firebaseOnAuthStateChanged } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n      \n      const auth = getFirebaseAuth();\n      if (!auth) {\n        console.warn(\"Auth service not available for onAuthStateChanged listener.\");\n        setLoading(false);\n        return;\n      }\n      \n      console.log(\"Setting up Firebase onAuthStateChanged listener.\");\n      unsubscribe = firebaseOnAuthStateChanged(auth, async (user) => {\n        setCurrentUser(user);\n        if (user) {\n          try {\n            // Force refresh is false by default, gets cached token if available\n            const token = await user.getIdToken();\n            setIdToken(token);\n            setError(null); // Clear previous errors on successful login\n            setIsLoggingIn(false); // Ensure login UI closes if open\n            console.log(\"User signed in, token obtained.\");\n          } catch (err) {\n            console.error(\"Failed to get ID token:\", err);\n            setError(\"Failed to get authentication token.\");\n            setIdToken(null);\n            // Optionally sign out the user if token fetch fails critically\n            const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n            await firebaseSignOut(auth);\n          }\n        } else {\n          // User is signed out\n          setIdToken(null);\n          setIsLoggingIn(false); // Ensure login UI closes if open\n          console.log(\"User signed out.\");\n        }\n        setLoading(false); // Auth state determined\n      });\n    };\n\n    // Define a custom event for Firebase initialization\n    window.addEventListener('firebaseInitialized', handleFirebaseInit);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('firebaseInitialized', handleFirebaseInit);\n      if (typeof unsubscribe === 'function') {\n      console.log(\"Cleaning up Firebase onAuthStateChanged listener.\");\n        unsubscribe();\n      }\n    };\n  }, []);\n\n  const value = {\n    currentUser,\n    idToken,\n    loading,\n    error,\n    login,\n    logout,\n    isAuthenticated: !!currentUser && !!idToken, // Use state directly\n    isLoggingIn, // Expose state to trigger login UI\n    setIsLoggingIn, // Allow login UI to close itself\n    isFirebaseInitialized // Expose whether Firebase is initialized\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}; ","import { createContext, useContext, useMemo } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatProvider } from './ChatContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatProvider>\n                {children}\n              </ChatProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","import React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Suspense fallback={\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: '100vh' \n      }}>\n        Loading...\n      </div>\n    }>\n      <App />\n    </Suspense>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","import { useState, useEffect, useMemo } from 'react';\n\n// Define breakpoint constants in a single source of truth\nexport const BREAKPOINTS = {\n  mobile: '640px',\n  tablet: '1023px',\n  desktop: '1024px'\n};\n\n// Cached media query listeners\nconst mediaQueryListeners = new Map();\n\n/**\n * Custom hook that returns true if the current viewport matches the provided media query\n * @param {string} query - Media query string e.g., \"(max-width: 1024px)\"\n * @returns {boolean} - True if the media query matches\n */\nexport const useMediaQuery = (query) => {\n  // Initialize with the current match state\n  const [matches, setMatches] = useState(() => {\n    // Check for window to avoid SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  });\n\n  useEffect(() => {\n    // Avoid running in SSR context\n    if (typeof window === 'undefined') {\n      return undefined;\n    }\n\n    // Check if we already have a listener for this query\n    if (!mediaQueryListeners.has(query)) {\n      // Create media query list\n      const mediaQueryList = window.matchMedia(query);\n      \n      // Create listener registry for this query\n      mediaQueryListeners.set(query, {\n        mediaQueryList,\n        listeners: new Set()\n      });\n    }\n    \n    const queryData = mediaQueryListeners.get(query);\n    const { mediaQueryList, listeners } = queryData;\n\n    // Initial check\n    setMatches(mediaQueryList.matches);\n\n    // Define listener function\n    const listener = (event) => {\n      setMatches(event.matches);\n    };\n    \n    // Add listener to registry\n    listeners.add(listener);\n\n    // Modern browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener);\n      return () => {\n        mediaQueryList.removeEventListener('change', listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    } \n    // Legacy support for older browsers (e.g., IE, older Safari)\n    else if (mediaQueryList.addListener) {\n      mediaQueryList.addListener(listener);\n      return () => {\n        mediaQueryList.removeListener(listener);\n        listeners.delete(listener);\n        \n        // Clean up registry if no more listeners\n        if (listeners.size === 0) {\n          mediaQueryListeners.delete(query);\n        }\n      };\n    }\n\n    return undefined;\n  }, [query]);\n\n  return matches;\n};\n\n/**\n * Pre-configured hooks for common breakpoints\n */\nexport const useIsMobile = () => {\n  const query = useMemo(() => `(max-width: ${BREAKPOINTS.mobile})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsTablet = () => {\n  const query = useMemo(() => \n    `(min-width: calc(${BREAKPOINTS.mobile} + 1px)) and (max-width: ${BREAKPOINTS.tablet})`, []);\n  return useMediaQuery(query);\n};\n\nexport const useIsDesktop = () => {\n  const query = useMemo(() => `(min-width: ${BREAKPOINTS.desktop})`, []);\n  return useMediaQuery(query);\n};\n\n/**\n * Get a consistent breakpoint value across the app\n * @returns {{mobile: string, tablet: string, desktop: string}}\n */\nexport const useBreakpoints = () => {\n  return BREAKPOINTS;\n}; ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create API context\nconst ApiContext = createContext();\n\n// Custom hook for using API context\nexport const useApi = () => {\n  const context = useContext(ApiContext);\n  if (context === undefined) {\n    throw new Error('useApi must be used within an ApiProvider');\n  }\n  return context;\n};\n\n// API provider component\nexport const ApiProvider = ({ children }) => {\n  const [apiUrl] = useState(process.env.REACT_APP_API_URL || 'http://localhost:3000/api'); // Base API URL\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    apiUrl,\n  }), [apiUrl]);\n\n  return (\n    <ApiContext.Provider value={value}>\n      {children}\n    </ApiContext.Provider>\n  );\n}; ","import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\n\n// Fetch Firebase configuration from environment variables\nconst firebaseConfig = {\n  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,\n  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.REACT_APP_FIREBASE_APP_ID,\n  // measurementId: process.env.REACT_APP_FIREBASE_MEASUREMENT_ID // Optional\n};\n\nlet app = null;\nlet auth = null;\n\nexport const initializeFirebase = () => {\n  if (app) return { app, auth };\n\n  if (\n    firebaseConfig.apiKey &&\n    firebaseConfig.authDomain &&\n    firebaseConfig.projectId &&\n    firebaseConfig.appId\n  ) {\n    try {\n      app = initializeApp(firebaseConfig);\n      auth = getAuth(app);\n      console.log(\"Firebase initialized successfully.\");\n    } catch (error) {\n      console.error(\"Firebase initialization failed:\", error);\n      app = null;\n      auth = null;\n    }\n  } else {\n    console.warn(\n      \"Firebase configuration environment variables are missing. \" +\n      \"Please set REACT_APP_FIREBASE_API_KEY, REACT_APP_FIREBASE_AUTH_DOMAIN, \" +\n      \"REACT_APP_FIREBASE_PROJECT_ID, and REACT_APP_FIREBASE_APP_ID in your .env file.\"\n    );\n  }\n  \n  return { app, auth };\n};\n\nexport const getFirebaseAuth = () => {\n  if (!auth) {\n    const { auth: newAuth } = initializeFirebase();\n    return newAuth;\n  }\n  return auth;\n};\n\nexport const getFirebaseApp = () => {\n  if (!app) {\n    const { app: newApp } = initializeFirebase();\n    return newApp;\n  }\n  return app;\n}; ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\nimport { useApi } from './ApiContext';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\n\n// Cache expiry time in milliseconds (5 minutes)\nconst CACHE_EXPIRY_TIME = 5*60 * 60 * 1000;\n\n// Create separate contexts for models and filtering\nconst ModelContext = createContext();\nconst ModelFilterContext = createContext();\n\n// Custom hook for using model context\nexport const useModel = () => {\n  const context = useContext(ModelContext);\n  if (context === undefined) {\n    throw new Error('useModel must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Custom hook for using model filter context\nexport const useModelFilter = () => {\n  const context = useContext(ModelFilterContext);\n  if (context === undefined) {\n    throw new Error('useModelFilter must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Model provider component\nexport const ModelProvider = ({ children }) => {\n  const { apiUrl } = useApi();\n  const { idToken } = useAuth();\n  \n  // State for model data\n  const [allModels, setAllModels] = useState([]);\n  const [processedModels, setProcessedModels] = useState({});\n  const [experimentalModels, setExperimentalModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [isInitialLoad, setIsInitialLoad] = useState(true);\n  \n  // Filter state - moved to separate context\n  const [showExperimental, setShowExperimental] = useLocalStorage('showExperimental', false);\n  const [modelFilter, setModelFilter] = useState({\n    search: '',\n    categories: {\n      'Chat': true,\n      'Image': true,\n      'Embedding': true\n    }\n  });\n  \n  // Check if cache is valid\n  const isCacheValid = useCallback((cache) => {\n    return (\n      cache &&\n      cache.timestamp &&\n      Date.now() - cache.timestamp < CACHE_EXPIRY_TIME &&\n      cache.allModels &&\n      cache.processedModels &&\n      cache.experimentalModels\n    );\n  }, []);\n  \n  // Expose isCacheValid function for external access\n  useEffect(() => {\n    // Skip during server-side rendering\n    if (typeof window === 'undefined') return;\n    window.isCacheValid = isCacheValid;\n    \n    return () => {\n      delete window.isCacheValid;\n    };\n  }, [isCacheValid]);\n  \n  // Cache models to localStorage\n  const cacheModels = useCallback((data) => {\n    try {\n      const cache = {\n        allModels: data.allModels,\n        processedModels: data.processedModels,\n        experimentalModels: data.experimentalModels,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem('modelDropdownCache', JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error caching models:', error);\n    }\n  }, []);\n  \n  // Update category filter\n  const updateCategoryFilter = useCallback((category, isChecked) => {\n    setModelFilter(prev => ({\n      ...prev,\n      categories: {\n        ...prev.categories,\n        [category]: isChecked\n      }\n    }));\n  }, []);\n  \n  // Update search filter\n  const updateSearchFilter = useCallback((searchText) => {\n    setModelFilter(prev => ({\n      ...prev,\n      search: searchText\n    }));\n  }, []);\n  \n  // Select a model\n  const selectModel = useCallback((model) => {\n    // Check if the model is actually different to prevent unnecessary updates\n    if (selectedModel?.id !== model?.id) { \n      setSelectedModel(model);\n    }\n  }, [selectedModel, setSelectedModel]);\n  \n  // Fetch models from API\n  const fetchModels = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n    \n    console.log(\"Fetching models from API...\");\n    try {\n      // For initial load, fetch without auth to avoid Firebase initialization\n      // On subsequent loads, use auth token if available\n      const headers = {\n        'Accept': 'application/json'\n      };\n\n      // Only add authorization header if not initial load and token exists\n      if (!isInitialLoad && idToken) {\n        headers['Authorization'] = `Bearer ${idToken}`;\n      }\n\n      // Construct URL safely\n      const modelsUrl = new URL('/api/models/classified', apiUrl).toString();\n      const response = await fetch(modelsUrl, { headers });\n      console.log('Models response:', response);\n      \n      // After first successful fetch, mark initial load complete\n      if (isInitialLoad) {\n        setIsInitialLoad(false);\n      }\n      \n      if (!response.ok) {\n        let errorMsg = `Error fetching models: ${response.status}`;\n        console.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n      \n      const rawData = await response.json();\n      console.log(\"[ModelContext] Spawning worker for model processing...\");\n      // Offload model processing to Web Worker\n      const worker = new Worker(new URL('../workers/modelProcessor.js', import.meta.url), { type: 'module' });\n      worker.postMessage(rawData);\n      worker.onmessage = ({ data: msg }) => {\n        if (msg.error) {\n          console.error('[ModelContext] Worker error:', msg.error);\n          setError(msg.error);\n        } else {\n          const {\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          } = msg;\n          setAllModels(fetchedAllModels);\n          setProcessedModels(fetchedProcessedModels);\n          setExperimentalModels(fetchedExperimentalModels);\n          // Cache the processed results\n          cacheModels({\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          });\n          // Initial model selection moved to a separate useEffect\n        }\n        setIsLoading(false);\n        worker.terminate();\n      };\n      worker.onerror = (err) => {\n        console.error('[ModelContext] Worker unexpected error:', err);\n        setError(err.message);\n        setIsLoading(false);\n        worker.terminate();\n      };\n    } catch (err) {\n      console.error('Failed to fetch or process models:', err);\n      setError(err.message || 'Failed to load model data');\n      // Attempt to load from potentially expired cache as a last resort?\n    }\n  }, [\n    apiUrl,\n    cacheModels,\n    idToken,\n    isInitialLoad\n  ]);\n  \n  // Fetch models on initial mount\n  useEffect(() => {\n    fetchModels();\n    // Run only once on mount, or when fetchModels function reference changes\n    // (which it shouldn't unless dependencies like apiUrl change)\n  }, [fetchModels]);\n  \n  // Set initial model after models are loaded\n  useEffect(() => {\n    // Select first model if none selected and models are loaded\n    if (!selectedModel && allModels.length > 0) {\n      setSelectedModel(allModels[0]);\n    }\n  }, [allModels, selectedModel]);\n  \n  // Create toggleExperimentalModels callback at the top level\n  const toggleExperimentalModels = useCallback(() => {\n    setShowExperimental(prev => !prev);\n  }, [setShowExperimental]);\n  \n  // Main model context value - no filter state\n  const modelValue = useMemo(() => ({\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    isExperimentalModelsEnabled: showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    refreshModels: fetchModels\n  }), [\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    fetchModels\n  ]);\n  \n  // Filter context value - only filter-related state\n  const filterValue = useMemo(() => ({\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  }), [\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  ]);\n  \n  return (\n    <ModelContext.Provider value={modelValue}>\n      <ModelFilterContext.Provider value={filterValue}>\n        {children}\n      </ModelFilterContext.Provider>\n    </ModelContext.Provider>\n  );\n}; "],"names":["useChatLogic","chatHistory","isWaitingForResponse","error","metrics","submitMessage","resetChat","downloadChatHistory","useChat","selectedModel","useModel","settings","useSettings","handleSendMessage","useCallback","async","message","editedMessage","arguments","length","undefined","isEditing","Array","isArray","map","part","type","text","join","trim","editMsgId","uniqueId","id","timestamp","editIndex","findIndex","msg","role","content","finalMessage","Date","now","Math","random","toString","substring","err","ThemeContext","createContext","useTheme","context","useContext","Error","ThemeProvider","_ref","children","theme","setTheme","useState","localStorage","getItem","toggleTheme","prevTheme","newTheme","setItem","useEffect","document","body","classList","remove","add","value","useMemo","isDark","_jsx","Provider","DEFAULT_SETTINGS","temperature","top_p","max_tokens","frequency_penalty","presence_penalty","streaming","systemPrompt","SettingsContext","SettingsProvider","setSettings","loadSavedSettings","savedSettings","parsed","JSON","parse","e","stringify","updateSetting","key","prev","resetSettings","shouldRestrictTemperature","model","requiresFixedTemperature","properties","includes","toLowerCase","startsWith","series","getModelAdjustedSettings","AuthContext","useAuth","AuthProvider","currentUser","setCurrentUser","idToken","setIdToken","loading","setLoading","setError","isLoggingIn","setIsLoggingIn","isFirebaseInitialized","setIsFirebaseInitialized","unsubscribe","handleFirebaseInit","initializeAuthListener","getFirebaseAuth","onAuthStateChanged","firebaseOnAuthStateChanged","auth","user","token","getIdToken","signOut","firebaseSignOut","window","addEventListener","removeEventListener","login","logout","isAuthenticated","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ApiProvider","ModelProvider","ChatProvider","useCacheToggle","cacheEnabled","setCacheEnabled","useLocalStorage","clearModelCache","removeItem","toggleCache","enabled","newValue","refreshModels","originalFunc","isCacheValid","cache","allModels","processedModels","experimentalModels","ReactDOM","getElementById","render","React","Suspense","fallback","style","display","justifyContent","alignItems","height","App","reportWebVitals","serviceWorkerRegistration","onUpdate","registration","waitingServiceWorker","waiting","event","target","state","location","reload","postMessage","BREAKPOINTS","mobile","tablet","desktop","mediaQueryListeners","Map","useMediaQuery","query","matches","setMatches","matchMedia","has","mediaQueryList","set","listeners","Set","queryData","get","listener","delete","size","addListener","removeListener","useIsDesktop","ApiContext","useApi","apiUrl","process","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","app","initializeFirebase","initializeApp","getAuth","newAuth","getFirebaseApp","newApp","initialValue","initialValueRef","useRef","storedValue","setStoredValue","item","current","setValue","valueToStore","Function","CACHE_EXPIRY_TIME","ModelContext","ModelFilterContext","useModelFilter","setAllModels","setProcessedModels","setExperimentalModels","setSelectedModel","isLoading","setIsLoading","isInitialLoad","setIsInitialLoad","showExperimental","setShowExperimental","modelFilter","setModelFilter","search","categories","cacheModels","data","updateCategoryFilter","category","isChecked","updateSearchFilter","searchText","selectModel","fetchModels","headers","modelsUrl","URL","response","fetch","ok","errorMsg","status","rawData","json","worker","Worker","onmessage","_ref2","fetchedAllModels","fetchedProcessedModels","fetchedExperimentalModels","terminate","onerror","toggleExperimentalModels","modelValue","isExperimentalModelsEnabled","filterValue"],"sourceRoot":""}
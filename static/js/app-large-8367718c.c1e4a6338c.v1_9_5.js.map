{"version":3,"file":"static/js/app-large-8367718c.c1e4a6338c.v1_9_5.js","mappings":"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","sources":["contexts/LoadingContext.js","contexts/ModelContext.js","contexts/PerformanceMetricsContext.js","contexts/ContextManager.js"],"sourcesContent":["import React, { createContext, useContext, useState, useCallback } from 'react';\n\n// Context to track multiple loading tags\nconst LoadingContext = createContext(null);\n\n/**\n * Provider to wrap application and manage loading states by tags\n */\nexport const LoadingProvider = ({ children }) => {\n  const [loadingMap, setLoadingMap] = useState({});\n\n  const setLoading = useCallback((tag, isLoading) => {\n    setLoadingMap(prev => ({ ...prev, [tag]: isLoading }));\n  }, []);\n\n  const isLoading = useCallback(tag => !!loadingMap[tag], [loadingMap]);\n  const anyLoading = Object.values(loadingMap).some(val => val);\n\n  return (\n    <LoadingContext.Provider value={{ setLoading, isLoading, anyLoading }}>\n      {children}\n    </LoadingContext.Provider>\n  );\n};\n\n/**\n * Hook to control loading for a specific tag\n * @param {string} tag - Unique identifier for loading scope\n * @returns {[boolean, function, function]} [isLoading, startLoading, stopLoading]\n */\nexport const useLoading = (tag) => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useLoading must be used within LoadingProvider');\n  const { setLoading, isLoading } = context;\n  const startLoading = useCallback(() => setLoading(tag, true), [setLoading, tag]);\n  const stopLoading = useCallback(() => setLoading(tag, false), [setLoading, tag]);\n  return [isLoading(tag), startLoading, stopLoading];\n};\n\n/**\n * Hook to check if any loading is active globally\n * @returns {boolean}\n */\nexport const useGlobalLoading = () => {\n  const context = useContext(LoadingContext);\n  if (!context) throw new Error('useGlobalLoading must be used within LoadingProvider');\n  return context.anyLoading;\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport { useCacheToggle } from '../hooks/useCacheToggle';\nimport { useToast } from './ToastContext';\nimport { useLoading } from './LoadingContext';\n// Inline model processing worker via worker-loader to avoid chunk loading issues\nimport ModelProcessorWorker from '../workers/modelProcessor.js';\n// Cache expiry time in milliseconds (5 days)\nconst CACHE_EXPIRY_TIME = 5 * 24 * 60 * 60 * 1000;\n\n// Create separate contexts for models and filtering\nconst ModelContext = createContext();\nconst ModelFilterContext = createContext();\n\n// Custom hook for using model context\nexport const useModel = () => {\n  const context = useContext(ModelContext);\n  if (context === undefined) {\n    throw new Error('useModel must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Custom hook for using model filter context\nexport const useModelFilter = () => {\n  const context = useContext(ModelFilterContext);\n  if (context === undefined) {\n    throw new Error('useModelFilter must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Model provider component\nexport const ModelProvider = ({ children }) => {\n  const { cacheEnabled } = useCacheToggle();\n  const { apiUrl } = useApi();\n  const { idToken } = useAuth();\n  const { showToast } = useToast();\n  \n  // State for model data\n  const [allModels, setAllModels] = useState([]);\n  const [processedModels, setProcessedModels] = useState({});\n  const [experimentalModels, setExperimentalModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useLocalStorage('selectedModel', null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Filter state - moved to separate context\n  const [showExperimental, setShowExperimental] = useLocalStorage('showExperimental', false);\n  const [modelFilter, setModelFilter] = useState({\n    search: '',\n    categories: {\n      'Chat': true,\n      'Image': true,\n      'Embedding': true\n    }\n  });\n  \n  // Sync with global loading context\n  const [, startModelsLoading, stopModelsLoading] = useLoading('models');\n  useEffect(() => {\n    if (isLoading) startModelsLoading();\n    else stopModelsLoading();\n  }, [isLoading, startModelsLoading, stopModelsLoading]);\n  \n  // Check if cache is valid\n  const isCacheValid = useCallback((cache) => {\n    return (\n      cache &&\n      cache.timestamp &&\n      Date.now() - cache.timestamp < CACHE_EXPIRY_TIME &&\n      cache.allModels &&\n      cache.processedModels &&\n      cache.experimentalModels\n    );\n  }, []);\n  \n  // Expose isCacheValid function for external access\n  useEffect(() => {\n    // Skip during server-side rendering\n    if (typeof window === 'undefined') return;\n    window.isCacheValid = isCacheValid;\n    \n    return () => {\n      delete window.isCacheValid;\n    };\n  }, [isCacheValid]);\n  \n  // Cache models to localStorage\n  const cacheModels = useCallback((data) => {\n    try {\n      const cache = {\n        allModels: data.allModels,\n        processedModels: data.processedModels,\n        experimentalModels: data.experimentalModels,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem('modelDropdownCache', JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error caching models:', error);\n    }\n  }, []);\n  \n  // Update category filter\n  const updateCategoryFilter = useCallback((category, isChecked) => {\n    setModelFilter(prev => ({\n      ...prev,\n      categories: {\n        ...prev.categories,\n        [category]: isChecked\n      }\n    }));\n  }, []);\n  \n  // Update search filter\n  const updateSearchFilter = useCallback((searchText) => {\n    setModelFilter(prev => ({\n      ...prev,\n      search: searchText\n    }));\n  }, []);\n  \n  // Select a model\n  const selectModel = useCallback((model) => {\n    // Check if the model is actually different to prevent unnecessary updates\n    if (selectedModel?.id !== model?.id) { \n      setSelectedModel(model);\n    }\n  }, [selectedModel, setSelectedModel]);\n  \n  // Fetch models from API, optionally using auth token or override token\n  const fetchModels = useCallback(async (authRequired = false, overrideToken = null) => {\n    setIsLoading(true);\n    setError(null);\n    \n    console.log(`Fetching models from API (auth: ${authRequired})...`);\n    try {\n      const headers = { 'Accept': 'application/json' };\n      if (authRequired) {\n        // Prefer overrideToken (cached) over current idToken\n        const tokenToUse = overrideToken || idToken;\n        if (tokenToUse) {\n          headers['Authorization'] = `Bearer ${tokenToUse}`;\n        }\n      }\n      const modelsUrl = new URL('/api/models/classified', apiUrl).toString();\n      const response = await fetch(modelsUrl, { headers });\n      console.log('Models response:', response);\n      \n      if (!response.ok) {\n        let errorMsg = `Error fetching models: ${response.status}`;\n        console.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n      \n      const rawData = await response.json();\n      console.log(\"[ModelContext] Raw data:\", rawData);\n      console.log(\"[ModelContext] Spawning worker for model processing...\");\n      // Offload model processing to Web Worker via inline blob\n      const worker = new ModelProcessorWorker();\n      \n      // Set up event handlers BEFORE posting the message\n      worker.onmessage = ({ data: msg }) => {\n        console.log(\"[ModelContext] Worker message received:\", msg);\n        if (msg.error) {\n          console.error('[ModelContext] Worker error:', msg.error);\n          setError(msg.error);\n          showToast({ type: 'error', message: msg.error });\n        } else {\n          const {\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          } = msg;\n          if (cacheEnabled) {\n            const rawPrev = localStorage.getItem('modelDropdownCache');\n            let prevCache;\n            try { prevCache = JSON.parse(rawPrev); } catch { prevCache = null; }\n            const changed = !prevCache ||\n              JSON.stringify(prevCache.allModels) !== JSON.stringify(fetchedAllModels) ||\n              JSON.stringify(prevCache.processedModels) !== JSON.stringify(fetchedProcessedModels) ||\n              JSON.stringify(prevCache.experimentalModels) !== JSON.stringify(fetchedExperimentalModels);\n            if (changed) {\n              setAllModels(fetchedAllModels);\n              setProcessedModels(fetchedProcessedModels);\n              setExperimentalModels(fetchedExperimentalModels);\n              cacheModels({ allModels: fetchedAllModels, processedModels: fetchedProcessedModels, experimentalModels: fetchedExperimentalModels });\n            }\n          } else {\n            setAllModels(fetchedAllModels);\n            setProcessedModels(fetchedProcessedModels);\n            setExperimentalModels(fetchedExperimentalModels);\n          }\n          // Initial model selection moved to a separate useEffect\n        }\n        setIsLoading(false);\n        worker.terminate();\n      };\n      worker.onerror = (err) => {\n        console.error('[ModelContext] Worker unexpected error:', err);\n        setError(err.message);\n        showToast({ type: 'error', message: err.message });\n        setIsLoading(false);\n        worker.terminate();\n      };\n      \n      // Now post the message to the worker\n      worker.postMessage(rawData);\n      console.log(\"[ModelContext] Message posted to worker, worker object:\", worker);\n\n    } catch (err) {\n      console.error('Failed to fetch or process models:', err);\n      setError(err.message || 'Failed to load model data');\n      showToast({ type: 'error', message: err.message || 'Failed to load model data' });\n      // Attempt to load from potentially expired cache as a last resort?\n    }\n  }, [apiUrl, cacheModels, idToken, cacheEnabled, showToast]);\n  \n  // Initial fetch once on mount\n  const initialFetchDoneRef = useRef(false);\n  // track if we've already fetched models with authentication\n  const didAuthFetchRef = useRef(false);\n\n  useEffect(() => {\n    if (!initialFetchDoneRef.current) {\n      if (cacheEnabled) {\n        const rawCache = localStorage.getItem('modelDropdownCache');\n        let parsedCache;\n        try { parsedCache = JSON.parse(rawCache); } catch { parsedCache = null; }\n        if (parsedCache && window.isCacheValid(parsedCache)) {\n          setAllModels(parsedCache.allModels);\n          setProcessedModels(parsedCache.processedModels);\n          setExperimentalModels(parsedCache.experimentalModels);\n          setIsLoading(false);\n        }\n      }\n      let cachedToken = null;\n      try { cachedToken = localStorage.getItem('idToken'); } catch {}\n      if (cachedToken) {\n        // initial authenticated fetch\n        didAuthFetchRef.current = true;\n        fetchModels(true, cachedToken);\n      } else {\n        // initial unauthenticated fetch\n        fetchModels(false);\n      }\n      initialFetchDoneRef.current = true;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // After login, fetch authenticated models\n  useEffect(() => {\n    // only fetch once after obtaining idToken if not already done\n    if (initialFetchDoneRef.current && idToken && !didAuthFetchRef.current) {\n      didAuthFetchRef.current = true;\n      fetchModels(true);\n    }\n  }, [idToken, fetchModels]);\n  \n  // Set initial model after models are loaded\n  useEffect(() => {\n    // Select first model if none selected and models are loaded\n    if (!selectedModel && allModels.length > 0) {\n      setSelectedModel(allModels[0]);\n    }\n  }, [allModels, selectedModel, setSelectedModel]);\n  \n  // Create toggleExperimentalModels callback at the top level\n  const toggleExperimentalModels = useCallback(() => {\n    setShowExperimental(prev => !prev);\n  }, [setShowExperimental]);\n  \n  // Main model context value - no filter state\n  const modelValue = useMemo(() => ({\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    isExperimentalModelsEnabled: showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    refreshModels: fetchModels\n  }), [\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    fetchModels\n  ]);\n  \n  // Filter context value - only filter-related state\n  const filterValue = useMemo(() => ({\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  }), [\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  ]);\n  \n  return (\n    <ModelContext.Provider value={modelValue}>\n      <ModelFilterContext.Provider value={filterValue}>\n        {children}\n      </ModelFilterContext.Provider>\n    </ModelContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useCallback, useMemo, useEffect } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\n\n// Create performance metrics context\nconst PerformanceMetricsContext = createContext();\n\n// Hook to use performance metrics context\nexport const usePerformanceMetrics = () => {\n  const context = useContext(PerformanceMetricsContext);\n  if (context === undefined) {\n    throw new Error('usePerformanceMetrics must be used within a PerformanceMetricsProvider');\n  }\n  return context;\n};\n\n// Provider component for performance metrics\nexport const PerformanceMetricsProvider = ({ children }) => {\n  const { setChatHistory } = useChatHistory();\n  const [currentMessageMetrics, setCurrentMessageMetrics] = useState({\n    startTime: null,\n    endTime: null,\n    elapsedTime: null,\n    tokenCount: null,\n    tokensPerSecond: null,\n    isComplete: false,\n    timeToFirstToken: null,\n    promptTokens: null,\n    completionTokens: null,\n    totalTokens: null,\n    finishReason: null\n  });\n\n  const resetPerformanceMetrics = useCallback(() => {\n    setCurrentMessageMetrics({\n      startTime: null,\n      endTime: null,\n      elapsedTime: null,\n      tokenCount: null,\n      tokensPerSecond: null,\n      isComplete: false,\n      timeToFirstToken: null,\n      promptTokens: null,\n      completionTokens: null,\n      totalTokens: null,\n      finishReason: null\n    });\n  }, []);\n\n  const startPerformanceTimer = useCallback(() => {\n    setCurrentMessageMetrics(prev => ({\n      ...prev,\n      startTime: Date.now(),\n      isComplete: false\n    }));\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const updatePerformanceMetrics = useCallback((newTokenCount, isComplete = false, tokenInfo = null, finishReason = null) => {\n    setCurrentMessageMetrics(prev => {\n      const endTime = Date.now();\n      const elapsedTime = prev.startTime ? endTime - prev.startTime : 0;\n      const tokensPerSecond = newTokenCount && elapsedTime ?\n        Math.round((newTokenCount / (elapsedTime / 1000)) * 10) / 10 :\n        prev.tokensPerSecond;\n      const timeToFirstToken = prev.timeToFirstToken ||\n        (newTokenCount > 0 ? elapsedTime : null);\n\n      const newMetrics = {\n        startTime: prev.startTime,\n        endTime,\n        elapsedTime,\n        tokenCount: newTokenCount,\n        tokensPerSecond,\n        isComplete,\n        timeToFirstToken,\n        promptTokens: tokenInfo?.promptTokens || prev.promptTokens,\n        completionTokens: tokenInfo?.completionTokens || prev.completionTokens,\n        totalTokens: tokenInfo?.totalTokens || prev.totalTokens,\n        finishReason: finishReason || prev.finishReason\n      };\n\n      return newMetrics;\n    });\n  }, []);\n\n  // Sync performance metrics into chat history after a metrics update\n  useEffect(() => {\n    if (currentMessageMetrics.endTime != null) {\n      setChatHistory(prevHistory => {\n        const newHistory = [...prevHistory];\n        const lastMsg = newHistory[newHistory.length - 1];\n        if (lastMsg && lastMsg.role === 'assistant') {\n          lastMsg.metrics = { ...currentMessageMetrics };\n        }\n        return newHistory;\n      });\n    }\n  }, [currentMessageMetrics, setChatHistory]);\n\n  // Direct function to set token metrics for the last message - for debugging/testing\n  const setTokenMetricsForLastMessage = useCallback((metrics) => {\n    setChatHistory(prevHistory => {\n      const newHistory = [...prevHistory];\n      const lastMsg = newHistory[newHistory.length - 1];\n      if (lastMsg && lastMsg.role === 'assistant') {\n        lastMsg.metrics = {\n          ...(lastMsg.metrics || {}),\n          ...metrics,\n          isComplete: true\n        };\n      }\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  const value = useMemo(() => ({\n    currentMessageMetrics,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    updatePerformanceMetrics,\n    setTokenMetricsForLastMessage\n  }), [currentMessageMetrics, resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics, setTokenMetricsForLastMessage]);\n\n  return (\n    <PerformanceMetricsContext.Provider value={value}>\n      {children}\n    </PerformanceMetricsContext.Provider>\n  );\n}; ","import { createContext, useContext, useMemo, useEffect } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatStatusProvider } from './ChatStatusContext';\nimport { ChatHistoryProvider } from './ChatHistoryContext';\nimport { PerformanceMetricsProvider } from './PerformanceMetricsContext';\nimport { StreamingEventsProvider } from './StreamingEventsContext';\nimport { ChatStateProvider } from './ChatStateContext';\nimport { ChatControlProvider } from './ChatControlContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n  // Mark as initialized once on mount\n  useEffect(() => {\n    initializationState.setInitialized(true);\n  }, [initializationState]);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatStatusProvider>\n                <ChatHistoryProvider>\n                  <PerformanceMetricsProvider>\n                    <StreamingEventsProvider>\n                      <ChatStateProvider>\n                        <ChatControlProvider>\n                          {children}\n                        </ChatControlProvider>\n                      </ChatStateProvider>\n                    </StreamingEventsProvider>\n                  </PerformanceMetricsProvider>\n                </ChatHistoryProvider>\n              </ChatStatusProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; "],"names":["LoadingContext","createContext","LoadingProvider","_ref","children","loadingMap","setLoadingMap","useState","setLoading","useCallback","tag","isLoading","prev","anyLoading","Object","values","some","val","_jsx","Provider","value","useLoading","context","useContext","Error","startLoading","stopLoading","ModelContext","ModelFilterContext","useModel","undefined","useModelFilter","ModelProvider","cacheEnabled","useCacheToggle","apiUrl","useApi","idToken","useAuth","showToast","useToast","allModels","setAllModels","processedModels","setProcessedModels","experimentalModels","setExperimentalModels","selectedModel","setSelectedModel","useLocalStorage","setIsLoading","error","setError","showExperimental","setShowExperimental","modelFilter","setModelFilter","search","categories","startModelsLoading","stopModelsLoading","useEffect","isCacheValid","cache","timestamp","Date","now","window","cacheModels","data","localStorage","setItem","JSON","stringify","updateCategoryFilter","category","isChecked","updateSearchFilter","searchText","selectModel","model","id","fetchModels","async","authRequired","arguments","length","overrideToken","headers","tokenToUse","modelsUrl","URL","toString","response","fetch","ok","errorMsg","status","rawData","json","worker","ModelProcessorWorker","onmessage","_ref2","msg","type","message","fetchedAllModels","fetchedProcessedModels","fetchedExperimentalModels","rawPrev","getItem","prevCache","parse","terminate","onerror","err","postMessage","initialFetchDoneRef","useRef","didAuthFetchRef","current","rawCache","parsedCache","cachedToken","toggleExperimentalModels","modelValue","useMemo","isExperimentalModelsEnabled","refreshModels","filterValue","PerformanceMetricsContext","usePerformanceMetrics","PerformanceMetricsProvider","setChatHistory","useChatHistory","currentMessageMetrics","setCurrentMessageMetrics","startTime","endTime","elapsedTime","tokenCount","tokensPerSecond","isComplete","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","resetPerformanceMetrics","startPerformanceTimer","updatePerformanceMetrics","newTokenCount","tokenInfo","Math","round","prevHistory","newHistory","lastMsg","role","metrics","setTokenMetricsForLastMessage","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ThemeProvider","ApiProvider","SettingsProvider","ChatStatusProvider","ChatHistoryProvider","StreamingEventsProvider","ChatStateProvider","ChatControlProvider"],"sourceRoot":""}
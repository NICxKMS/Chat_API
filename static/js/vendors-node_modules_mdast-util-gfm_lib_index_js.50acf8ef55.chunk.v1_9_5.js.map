{"version":3,"file":"static/js/vendors-node_modules_mdast-util-gfm_lib_index_js.50acf8ef55.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/ccount/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/unist-util-is/lib/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/escape-string-regexp/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark-util-character/index.js","../node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/mdast-util-gfm-autolink-literal/lib/index.js","../node_modules/mdast-util-gfm-footnote/lib/index.js","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/markdown-table/index.js","../node_modules/mdast-util-gfm-table/lib/index.js","../node_modules/mdast-util-gfm-task-list-item/lib/index.js","../node_modules/mdast-util-gfm/lib/index.js"],"sourcesContent":["/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      // To do next major: don’t return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesn’t understand but it’s perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasn’t a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n// To do: next major: expose functions instead of extensions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Link | Array<PhrasingContent> | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesn’t place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its “visible” size;\n *   note that what is and isn’t visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['中文', 'Charlie'],\n *     ['👩‍❤️‍👩', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | 中文 | Charlie |\n *   | 👩‍❤️‍👩 | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['中文', 'Charlie'],\n *       ['👩‍❤️‍👩', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | 中文  | Charlie |\n *   | 👩‍❤️‍👩    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n","/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n"],"names":["ccount","value","character","source","String","TypeError","count","index","indexOf","length","convert","test","ok","check","castFactory","node","type","Array","isArray","tests","checks","_len","arguments","parameters","_key","call","this","anyFactory","key","propsFactory","Error","_len2","_key2","Boolean","EXIT","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","undefined","Object","defineProperty","visit","subresult","offset","grandparents","result","toResult","children","concat","own","hasOwnProperty","toExpression","find","RegExp","string","replace","escape","toFunction","regexCheck","unicodePunctuation","unicodeWhitespace","regex","code","fromCharCode","inConstruct","notInConstruct","gfmAutolinkLiteralFromMarkdown","transforms","options","settings","schema","ignored","ignore","pairs","push","toPairs","pairIndex","grandparent","parent","start","change","nodes","lastIndex","match","exec","position","matchObject","input","stack","slice","global","splice","handler","findAndReplace","findUrl","findEmail","enter","literalAutolink","token","title","url","literalAutolinkEmail","enterLiteralAutolinkValue","literalAutolinkHttp","literalAutolinkWww","exit","config","autolinkEmail","autolinkProtocol","data","sliceSerialize","gfmAutolinkLiteralToMarkdown","unsafe","before","after","_","protocol","domain","path","prefix","previous","parts","split","isCorrectDomain","trailExec","trail","closingParenIndex","openingParens","closingParens","splitUrl","atext","label","email","charCodeAt","enterFootnoteDefinition","identifier","enterFootnoteDefinitionLabelString","buffer","exitFootnoteDefinitionLabelString","resume","normalizeIdentifier","toLowerCase","exitFootnoteDefinition","enterFootnoteCall","enterFootnoteCallString","exitFootnoteCallString","exitFootnoteCall","footnoteReference","context","safeOptions","tracker","track","move","subexit","safe","association","current","footnoteDefinition","shift","indentLines","containerFlow","map","line","blank","peek","handleDelete","gfmStrikethroughFromMarkdown","canContainEols","strikethrough","gfmStrikethroughToMarkdown","handlers","delete","containerPhrasing","defaultStringLength","toAlignment","codePointAt","gfmTableFromMarkdown","table","align","_align","d","setData","tableData","enterCell","tableHeader","tableRow","codeText","getData","$0","$1","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","atBreak","serializeData","handleTableRowAsData","handleTableAsData","tableCell","handleTableCell","inlineCode","includes","matrix","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","row","sizes","columnIndex","cell","size","Math","max","repeat","lines","delimiterStart","delimiterEnd","join","markdownTable","gfmTaskListItemFromMarkdown","taskListCheckValueChecked","exitCheck","taskListCheckValueUnchecked","paragraph","checked","head","siblings","firstParaghraph","sibling","column","assign","gfmTaskListItemToMarkdown","listItem","checkable","checkbox","gfmFromMarkdown","gfmFootnoteDefinition","gfmFootnoteDefinitionLabelString","gfmFootnoteCall","gfmFootnoteCallString","gfmToMarkdown","extensions"],"sourceRoot":""}
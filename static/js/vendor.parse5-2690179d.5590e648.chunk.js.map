{"version":3,"file":"static/js/vendor.parse5-2690179d.5590e648.chunk.js","mappings":"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","sources":["../node_modules/parse5/dist/tree-adapters/default.js","../node_modules/parse5/dist/parser/formatting-element-list.js","../node_modules/parse5/dist/parser/open-element-stack.js","../node_modules/parse5/dist/serializer/index.js","../node_modules/parse5/dist/tokenizer/preprocessor.js"],"sourcesContent":["import { DOCUMENT_MODE } from '../common/html.js';\nexport const defaultTreeAdapter = {\n    //Node construction\n    createDocument() {\n        return {\n            nodeName: '#document',\n            mode: DOCUMENT_MODE.NO_QUIRKS,\n            childNodes: [],\n        };\n    },\n    createDocumentFragment() {\n        return {\n            nodeName: '#document-fragment',\n            childNodes: [],\n        };\n    },\n    createElement(tagName, namespaceURI, attrs) {\n        return {\n            nodeName: tagName,\n            tagName,\n            attrs,\n            namespaceURI,\n            childNodes: [],\n            parentNode: null,\n        };\n    },\n    createCommentNode(data) {\n        return {\n            nodeName: '#comment',\n            data,\n            parentNode: null,\n        };\n    },\n    createTextNode(value) {\n        return {\n            nodeName: '#text',\n            value,\n            parentNode: null,\n        };\n    },\n    //Tree mutation\n    appendChild(parentNode, newNode) {\n        parentNode.childNodes.push(newNode);\n        newNode.parentNode = parentNode;\n    },\n    insertBefore(parentNode, newNode, referenceNode) {\n        const insertionIdx = parentNode.childNodes.indexOf(referenceNode);\n        parentNode.childNodes.splice(insertionIdx, 0, newNode);\n        newNode.parentNode = parentNode;\n    },\n    setTemplateContent(templateElement, contentElement) {\n        templateElement.content = contentElement;\n    },\n    getTemplateContent(templateElement) {\n        return templateElement.content;\n    },\n    setDocumentType(document, name, publicId, systemId) {\n        const doctypeNode = document.childNodes.find((node) => node.nodeName === '#documentType');\n        if (doctypeNode) {\n            doctypeNode.name = name;\n            doctypeNode.publicId = publicId;\n            doctypeNode.systemId = systemId;\n        }\n        else {\n            const node = {\n                nodeName: '#documentType',\n                name,\n                publicId,\n                systemId,\n                parentNode: null,\n            };\n            defaultTreeAdapter.appendChild(document, node);\n        }\n    },\n    setDocumentMode(document, mode) {\n        document.mode = mode;\n    },\n    getDocumentMode(document) {\n        return document.mode;\n    },\n    detachNode(node) {\n        if (node.parentNode) {\n            const idx = node.parentNode.childNodes.indexOf(node);\n            node.parentNode.childNodes.splice(idx, 1);\n            node.parentNode = null;\n        }\n    },\n    insertText(parentNode, text) {\n        if (parentNode.childNodes.length > 0) {\n            const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];\n            if (defaultTreeAdapter.isTextNode(prevNode)) {\n                prevNode.value += text;\n                return;\n            }\n        }\n        defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text));\n    },\n    insertTextBefore(parentNode, text, referenceNode) {\n        const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];\n        if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {\n            prevNode.value += text;\n        }\n        else {\n            defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text), referenceNode);\n        }\n    },\n    adoptAttributes(recipient, attrs) {\n        const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));\n        for (let j = 0; j < attrs.length; j++) {\n            if (!recipientAttrsMap.has(attrs[j].name)) {\n                recipient.attrs.push(attrs[j]);\n            }\n        }\n    },\n    //Tree traversing\n    getFirstChild(node) {\n        return node.childNodes[0];\n    },\n    getChildNodes(node) {\n        return node.childNodes;\n    },\n    getParentNode(node) {\n        return node.parentNode;\n    },\n    getAttrList(element) {\n        return element.attrs;\n    },\n    //Node data\n    getTagName(element) {\n        return element.tagName;\n    },\n    getNamespaceURI(element) {\n        return element.namespaceURI;\n    },\n    getTextNodeContent(textNode) {\n        return textNode.value;\n    },\n    getCommentNodeContent(commentNode) {\n        return commentNode.data;\n    },\n    getDocumentTypeNodeName(doctypeNode) {\n        return doctypeNode.name;\n    },\n    getDocumentTypeNodePublicId(doctypeNode) {\n        return doctypeNode.publicId;\n    },\n    getDocumentTypeNodeSystemId(doctypeNode) {\n        return doctypeNode.systemId;\n    },\n    //Node types\n    isTextNode(node) {\n        return node.nodeName === '#text';\n    },\n    isCommentNode(node) {\n        return node.nodeName === '#comment';\n    },\n    isDocumentTypeNode(node) {\n        return node.nodeName === '#documentType';\n    },\n    isElementNode(node) {\n        return Object.prototype.hasOwnProperty.call(node, 'tagName');\n    },\n    // Source code location\n    setNodeSourceCodeLocation(node, location) {\n        node.sourceCodeLocation = location;\n    },\n    getNodeSourceCodeLocation(node) {\n        return node.sourceCodeLocation;\n    },\n    updateNodeSourceCodeLocation(node, endLocation) {\n        node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };\n    },\n};\n","//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n    EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n    EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType || (EntryType = {}));\nconst MARKER = { type: EntryType.Marker };\n//List of formatting elements\nexport class FormattingElementList {\n    constructor(treeAdapter) {\n        this.treeAdapter = treeAdapter;\n        this.entries = [];\n        this.bookmark = null;\n    }\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement, neAttrs) {\n        const candidates = [];\n        const neAttrsLength = neAttrs.length;\n        const neTagName = this.treeAdapter.getTagName(newElement);\n        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n        for (let i = 0; i < this.entries.length; i++) {\n            const entry = this.entries[i];\n            if (entry.type === EntryType.Marker) {\n                break;\n            }\n            const { element } = entry;\n            if (this.treeAdapter.getTagName(element) === neTagName &&\n                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n                if (elementAttrs.length === neAttrsLength) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n        return candidates;\n    }\n    _ensureNoahArkCondition(newElement) {\n        if (this.entries.length < NOAH_ARK_CAPACITY)\n            return;\n        const neAttrs = this.treeAdapter.getAttrList(newElement);\n        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n        if (candidates.length < NOAH_ARK_CAPACITY)\n            return;\n        //NOTE: build attrs map for the new element, so we can perform fast lookups\n        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));\n        let validCandidates = 0;\n        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n        for (let i = 0; i < candidates.length; i++) {\n            const candidate = candidates[i];\n            // We know that `candidate.attrs.length === neAttrs.length`\n            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n                validCandidates += 1;\n                if (validCandidates >= NOAH_ARK_CAPACITY) {\n                    this.entries.splice(candidate.idx, 1);\n                }\n            }\n        }\n    }\n    //Mutations\n    insertMarker() {\n        this.entries.unshift(MARKER);\n    }\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n        this.entries.unshift({\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    insertElementAfterBookmark(element, token) {\n        const bookmarkIdx = this.entries.indexOf(this.bookmark);\n        this.entries.splice(bookmarkIdx, 0, {\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    removeEntry(entry) {\n        const entryIndex = this.entries.indexOf(entry);\n        if (entryIndex >= 0) {\n            this.entries.splice(entryIndex, 1);\n        }\n    }\n    /**\n     * Clears the list of formatting elements up to the last marker.\n     *\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n     */\n    clearToLastMarker() {\n        const markerIdx = this.entries.indexOf(MARKER);\n        if (markerIdx >= 0) {\n            this.entries.splice(0, markerIdx + 1);\n        }\n        else {\n            this.entries.length = 0;\n        }\n    }\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n        return entry && entry.type === EntryType.Element ? entry : null;\n    }\n    getElementEntry(element) {\n        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);\n    }\n}\n","import { TAG_ID as $, NS, NUMBERED_HEADERS } from '../common/html.js';\n//Element utils\nconst IMPLICIT_END_TAG_REQUIRED = new Set([$.DD, $.DT, $.LI, $.OPTGROUP, $.OPTION, $.P, $.RB, $.RP, $.RT, $.RTC]);\nconst IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([\n    ...IMPLICIT_END_TAG_REQUIRED,\n    $.CAPTION,\n    $.COLGROUP,\n    $.TBODY,\n    $.TD,\n    $.TFOOT,\n    $.TH,\n    $.THEAD,\n    $.TR,\n]);\nconst SCOPING_ELEMENTS_HTML = new Set([\n    $.APPLET,\n    $.CAPTION,\n    $.HTML,\n    $.MARQUEE,\n    $.OBJECT,\n    $.TABLE,\n    $.TD,\n    $.TEMPLATE,\n    $.TH,\n]);\nconst SCOPING_ELEMENTS_HTML_LIST = new Set([...SCOPING_ELEMENTS_HTML, $.OL, $.UL]);\nconst SCOPING_ELEMENTS_HTML_BUTTON = new Set([...SCOPING_ELEMENTS_HTML, $.BUTTON]);\nconst SCOPING_ELEMENTS_MATHML = new Set([$.ANNOTATION_XML, $.MI, $.MN, $.MO, $.MS, $.MTEXT]);\nconst SCOPING_ELEMENTS_SVG = new Set([$.DESC, $.FOREIGN_OBJECT, $.TITLE]);\nconst TABLE_ROW_CONTEXT = new Set([$.TR, $.TEMPLATE, $.HTML]);\nconst TABLE_BODY_CONTEXT = new Set([$.TBODY, $.TFOOT, $.THEAD, $.TEMPLATE, $.HTML]);\nconst TABLE_CONTEXT = new Set([$.TABLE, $.TEMPLATE, $.HTML]);\nconst TABLE_CELLS = new Set([$.TD, $.TH]);\n//Stack of open elements\nexport class OpenElementStack {\n    get currentTmplContentOrNode() {\n        return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;\n    }\n    constructor(document, treeAdapter, handler) {\n        this.treeAdapter = treeAdapter;\n        this.handler = handler;\n        this.items = [];\n        this.tagIDs = [];\n        this.stackTop = -1;\n        this.tmplCount = 0;\n        this.currentTagId = $.UNKNOWN;\n        this.current = document;\n    }\n    //Index of element\n    _indexOf(element) {\n        return this.items.lastIndexOf(element, this.stackTop);\n    }\n    //Update current element\n    _isInTemplate() {\n        return this.currentTagId === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;\n    }\n    _updateCurrentElement() {\n        this.current = this.items[this.stackTop];\n        this.currentTagId = this.tagIDs[this.stackTop];\n    }\n    //Mutations\n    push(element, tagID) {\n        this.stackTop++;\n        this.items[this.stackTop] = element;\n        this.current = element;\n        this.tagIDs[this.stackTop] = tagID;\n        this.currentTagId = tagID;\n        if (this._isInTemplate()) {\n            this.tmplCount++;\n        }\n        this.handler.onItemPush(element, tagID, true);\n    }\n    pop() {\n        const popped = this.current;\n        if (this.tmplCount > 0 && this._isInTemplate()) {\n            this.tmplCount--;\n        }\n        this.stackTop--;\n        this._updateCurrentElement();\n        this.handler.onItemPop(popped, true);\n    }\n    replace(oldElement, newElement) {\n        const idx = this._indexOf(oldElement);\n        this.items[idx] = newElement;\n        if (idx === this.stackTop) {\n            this.current = newElement;\n        }\n    }\n    insertAfter(referenceElement, newElement, newElementID) {\n        const insertionIdx = this._indexOf(referenceElement) + 1;\n        this.items.splice(insertionIdx, 0, newElement);\n        this.tagIDs.splice(insertionIdx, 0, newElementID);\n        this.stackTop++;\n        if (insertionIdx === this.stackTop) {\n            this._updateCurrentElement();\n        }\n        this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);\n    }\n    popUntilTagNamePopped(tagName) {\n        let targetIdx = this.stackTop + 1;\n        do {\n            targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);\n        } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);\n        this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);\n    }\n    shortenToLength(idx) {\n        while (this.stackTop >= idx) {\n            const popped = this.current;\n            if (this.tmplCount > 0 && this._isInTemplate()) {\n                this.tmplCount -= 1;\n            }\n            this.stackTop--;\n            this._updateCurrentElement();\n            this.handler.onItemPop(popped, this.stackTop < idx);\n        }\n    }\n    popUntilElementPopped(element) {\n        const idx = this._indexOf(element);\n        this.shortenToLength(idx < 0 ? 0 : idx);\n    }\n    popUntilPopped(tagNames, targetNS) {\n        const idx = this._indexOfTagNames(tagNames, targetNS);\n        this.shortenToLength(idx < 0 ? 0 : idx);\n    }\n    popUntilNumberedHeaderPopped() {\n        this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);\n    }\n    popUntilTableCellPopped() {\n        this.popUntilPopped(TABLE_CELLS, NS.HTML);\n    }\n    popAllUpToHtmlElement() {\n        //NOTE: here we assume that the root <html> element is always first in the open element stack, so\n        //we perform this fast stack clean up.\n        this.tmplCount = 0;\n        this.shortenToLength(1);\n    }\n    _indexOfTagNames(tagNames, namespace) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    clearBackTo(tagNames, targetNS) {\n        const idx = this._indexOfTagNames(tagNames, targetNS);\n        this.shortenToLength(idx + 1);\n    }\n    clearBackToTableContext() {\n        this.clearBackTo(TABLE_CONTEXT, NS.HTML);\n    }\n    clearBackToTableBodyContext() {\n        this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);\n    }\n    clearBackToTableRowContext() {\n        this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);\n    }\n    remove(element) {\n        const idx = this._indexOf(element);\n        if (idx >= 0) {\n            if (idx === this.stackTop) {\n                this.pop();\n            }\n            else {\n                this.items.splice(idx, 1);\n                this.tagIDs.splice(idx, 1);\n                this.stackTop--;\n                this._updateCurrentElement();\n                this.handler.onItemPop(element, false);\n            }\n        }\n    }\n    //Search\n    tryPeekProperlyNestedBodyElement() {\n        //Properly nested <body> element (should be second element in stack).\n        return this.stackTop >= 1 && this.tagIDs[1] === $.BODY ? this.items[1] : null;\n    }\n    contains(element) {\n        return this._indexOf(element) > -1;\n    }\n    getCommonAncestor(element) {\n        const elementIdx = this._indexOf(element) - 1;\n        return elementIdx >= 0 ? this.items[elementIdx] : null;\n    }\n    isRootHtmlElementCurrent() {\n        return this.stackTop === 0 && this.tagIDs[0] === $.HTML;\n    }\n    //Element in scope\n    hasInDynamicScope(tagName, htmlScope) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.tagIDs[i];\n            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {\n                case NS.HTML: {\n                    if (tn === tagName)\n                        return true;\n                    if (htmlScope.has(tn))\n                        return false;\n                    break;\n                }\n                case NS.SVG: {\n                    if (SCOPING_ELEMENTS_SVG.has(tn))\n                        return false;\n                    break;\n                }\n                case NS.MATHML: {\n                    if (SCOPING_ELEMENTS_MATHML.has(tn))\n                        return false;\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n    hasInScope(tagName) {\n        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);\n    }\n    hasInListItemScope(tagName) {\n        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);\n    }\n    hasInButtonScope(tagName) {\n        return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);\n    }\n    hasNumberedHeaderInScope() {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.tagIDs[i];\n            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {\n                case NS.HTML: {\n                    if (NUMBERED_HEADERS.has(tn))\n                        return true;\n                    if (SCOPING_ELEMENTS_HTML.has(tn))\n                        return false;\n                    break;\n                }\n                case NS.SVG: {\n                    if (SCOPING_ELEMENTS_SVG.has(tn))\n                        return false;\n                    break;\n                }\n                case NS.MATHML: {\n                    if (SCOPING_ELEMENTS_MATHML.has(tn))\n                        return false;\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n    hasInTableScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n                continue;\n            }\n            switch (this.tagIDs[i]) {\n                case tagName: {\n                    return true;\n                }\n                case $.TABLE:\n                case $.HTML: {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    hasTableBodyContextInTableScope() {\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n                continue;\n            }\n            switch (this.tagIDs[i]) {\n                case $.TBODY:\n                case $.THEAD:\n                case $.TFOOT: {\n                    return true;\n                }\n                case $.TABLE:\n                case $.HTML: {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    hasInSelectScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {\n                continue;\n            }\n            switch (this.tagIDs[i]) {\n                case tagName: {\n                    return true;\n                }\n                case $.OPTION:\n                case $.OPTGROUP: {\n                    break;\n                }\n                default: {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    //Implied end tags\n    generateImpliedEndTags() {\n        while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {\n            this.pop();\n        }\n    }\n    generateImpliedEndTagsThoroughly() {\n        while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {\n            this.pop();\n        }\n    }\n    generateImpliedEndTagsWithExclusion(exclusionId) {\n        while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {\n            this.pop();\n        }\n    }\n}\n","import { TAG_NAMES as $, NS, hasUnescapedText } from '../common/html.js';\nimport { escapeText, escapeAttribute } from 'entities/lib/escape.js';\nimport { defaultTreeAdapter } from '../tree-adapters/default.js';\n// Sets\nconst VOID_ELEMENTS = new Set([\n    $.AREA,\n    $.BASE,\n    $.BASEFONT,\n    $.BGSOUND,\n    $.BR,\n    $.COL,\n    $.EMBED,\n    $.FRAME,\n    $.HR,\n    $.IMG,\n    $.INPUT,\n    $.KEYGEN,\n    $.LINK,\n    $.META,\n    $.PARAM,\n    $.SOURCE,\n    $.TRACK,\n    $.WBR,\n]);\nfunction isVoidElement(node, options) {\n    return (options.treeAdapter.isElementNode(node) &&\n        options.treeAdapter.getNamespaceURI(node) === NS.HTML &&\n        VOID_ELEMENTS.has(options.treeAdapter.getTagName(node)));\n}\nconst defaultOpts = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };\n/**\n * Serializes an AST node to an HTML string.\n *\n * @example\n *\n * ```js\n * const parse5 = require('parse5');\n *\n * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');\n *\n * // Serializes a document.\n * const html = parse5.serialize(document);\n *\n * // Serializes the <html> element content.\n * const str = parse5.serialize(document.childNodes[1]);\n *\n * console.log(str); //> '<head></head><body>Hi there!</body>'\n * ```\n *\n * @param node Node to serialize.\n * @param options Serialization options.\n */\nexport function serialize(node, options) {\n    const opts = { ...defaultOpts, ...options };\n    if (isVoidElement(node, opts)) {\n        return '';\n    }\n    return serializeChildNodes(node, opts);\n}\n/**\n * Serializes an AST element node to an HTML string, including the element node.\n *\n * @example\n *\n * ```js\n * const parse5 = require('parse5');\n *\n * const document = parse5.parseFragment('<div>Hello, <b>world</b>!</div>');\n *\n * // Serializes the <div> element.\n * const str = parse5.serializeOuter(document.childNodes[0]);\n *\n * console.log(str); //> '<div>Hello, <b>world</b>!</div>'\n * ```\n *\n * @param node Node to serialize.\n * @param options Serialization options.\n */\nexport function serializeOuter(node, options) {\n    const opts = { ...defaultOpts, ...options };\n    return serializeNode(node, opts);\n}\nfunction serializeChildNodes(parentNode, options) {\n    let html = '';\n    // Get container of the child nodes\n    const container = options.treeAdapter.isElementNode(parentNode) &&\n        options.treeAdapter.getTagName(parentNode) === $.TEMPLATE &&\n        options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML\n        ? options.treeAdapter.getTemplateContent(parentNode)\n        : parentNode;\n    const childNodes = options.treeAdapter.getChildNodes(container);\n    if (childNodes) {\n        for (const currentNode of childNodes) {\n            html += serializeNode(currentNode, options);\n        }\n    }\n    return html;\n}\nfunction serializeNode(node, options) {\n    if (options.treeAdapter.isElementNode(node)) {\n        return serializeElement(node, options);\n    }\n    if (options.treeAdapter.isTextNode(node)) {\n        return serializeTextNode(node, options);\n    }\n    if (options.treeAdapter.isCommentNode(node)) {\n        return serializeCommentNode(node, options);\n    }\n    if (options.treeAdapter.isDocumentTypeNode(node)) {\n        return serializeDocumentTypeNode(node, options);\n    }\n    // Return an empty string for unknown nodes\n    return '';\n}\nfunction serializeElement(node, options) {\n    const tn = options.treeAdapter.getTagName(node);\n    return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? '' : `${serializeChildNodes(node, options)}</${tn}>`}`;\n}\nfunction serializeAttributes(node, { treeAdapter }) {\n    let html = '';\n    for (const attr of treeAdapter.getAttrList(node)) {\n        html += ' ';\n        if (attr.namespace) {\n            switch (attr.namespace) {\n                case NS.XML: {\n                    html += `xml:${attr.name}`;\n                    break;\n                }\n                case NS.XMLNS: {\n                    if (attr.name !== 'xmlns') {\n                        html += 'xmlns:';\n                    }\n                    html += attr.name;\n                    break;\n                }\n                case NS.XLINK: {\n                    html += `xlink:${attr.name}`;\n                    break;\n                }\n                default: {\n                    html += `${attr.prefix}:${attr.name}`;\n                }\n            }\n        }\n        else {\n            html += attr.name;\n        }\n        html += `=\"${escapeAttribute(attr.value)}\"`;\n    }\n    return html;\n}\nfunction serializeTextNode(node, options) {\n    const { treeAdapter } = options;\n    const content = treeAdapter.getTextNodeContent(node);\n    const parent = treeAdapter.getParentNode(node);\n    const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);\n    return parentTn &&\n        treeAdapter.getNamespaceURI(parent) === NS.HTML &&\n        hasUnescapedText(parentTn, options.scriptingEnabled)\n        ? content\n        : escapeText(content);\n}\nfunction serializeCommentNode(node, { treeAdapter }) {\n    return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;\n}\nfunction serializeDocumentTypeNode(node, { treeAdapter }) {\n    return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;\n}\n","import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code, cpOffset) {\n        const { line, col, offset } = this;\n        const startCol = col + cpOffset;\n        const startOffset = offset + cpOffset;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol,\n            endCol: startCol,\n            startOffset,\n            endOffset: startOffset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code, 0));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if (isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        const code = this.html.charCodeAt(pos);\n        return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === $.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if (isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === $.LINE_FEED ||\n            cp === $.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if (isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        }\n        else if (isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\n"],"names":["defaultTreeAdapter","createDocument","nodeName","mode","DOCUMENT_MODE","NO_QUIRKS","childNodes","createDocumentFragment","createElement","tagName","namespaceURI","attrs","parentNode","createCommentNode","data","createTextNode","value","appendChild","newNode","push","insertBefore","referenceNode","insertionIdx","indexOf","splice","setTemplateContent","templateElement","contentElement","content","getTemplateContent","setDocumentType","document","name","publicId","systemId","doctypeNode","find","node","setDocumentMode","getDocumentMode","detachNode","idx","insertText","text","length","prevNode","isTextNode","insertTextBefore","adoptAttributes","recipient","recipientAttrsMap","Set","map","attr","j","has","getFirstChild","getChildNodes","getParentNode","getAttrList","element","getTagName","getNamespaceURI","getTextNodeContent","textNode","getCommentNodeContent","commentNode","getDocumentTypeNodeName","getDocumentTypeNodePublicId","getDocumentTypeNodeSystemId","isCommentNode","isDocumentTypeNode","isElementNode","Object","prototype","hasOwnProperty","call","setNodeSourceCodeLocation","location","sourceCodeLocation","getNodeSourceCodeLocation","updateNodeSourceCodeLocation","endLocation","EntryType","MARKER","type","Marker","FormattingElementList","constructor","treeAdapter","this","entries","bookmark","_getNoahArkConditionCandidates","newElement","neAttrs","candidates","neAttrsLength","neTagName","neNamespaceURI","i","entry","elementAttrs","_ensureNoahArkCondition","neAttrsMap","Map","neAttr","validCandidates","candidate","every","cAttr","get","insertMarker","unshift","pushElement","token","Element","insertElementAfterBookmark","bookmarkIdx","removeEntry","entryIndex","clearToLastMarker","markerIdx","getElementEntryInScopeWithTagName","getElementEntry","IMPLICIT_END_TAG_REQUIRED","$","DD","DT","LI","OPTGROUP","OPTION","P","RB","RP","RT","RTC","IMPLICIT_END_TAG_REQUIRED_THOROUGHLY","CAPTION","COLGROUP","TBODY","TD","TFOOT","TH","THEAD","TR","SCOPING_ELEMENTS_HTML","APPLET","HTML","MARQUEE","OBJECT","TABLE","TEMPLATE","SCOPING_ELEMENTS_HTML_LIST","OL","UL","SCOPING_ELEMENTS_HTML_BUTTON","BUTTON","SCOPING_ELEMENTS_MATHML","ANNOTATION_XML","MI","MN","MO","MS","MTEXT","SCOPING_ELEMENTS_SVG","DESC","FOREIGN_OBJECT","TITLE","TABLE_ROW_CONTEXT","TABLE_BODY_CONTEXT","TABLE_CONTEXT","TABLE_CELLS","OpenElementStack","currentTmplContentOrNode","_isInTemplate","current","handler","items","tagIDs","stackTop","tmplCount","currentTagId","UNKNOWN","_indexOf","lastIndexOf","NS","_updateCurrentElement","tagID","onItemPush","pop","popped","onItemPop","replace","oldElement","insertAfter","referenceElement","newElementID","popUntilTagNamePopped","targetIdx","shortenToLength","popUntilElementPopped","popUntilPopped","tagNames","targetNS","_indexOfTagNames","popUntilNumberedHeaderPopped","NUMBERED_HEADERS","popUntilTableCellPopped","popAllUpToHtmlElement","namespace","clearBackTo","clearBackToTableContext","clearBackToTableBodyContext","clearBackToTableRowContext","remove","tryPeekProperlyNestedBodyElement","BODY","contains","getCommonAncestor","elementIdx","isRootHtmlElementCurrent","hasInDynamicScope","htmlScope","tn","SVG","MATHML","hasInScope","hasInListItemScope","hasInButtonScope","hasNumberedHeaderInScope","hasInTableScope","hasTableBodyContextInTableScope","hasInSelectScope","generateImpliedEndTags","generateImpliedEndTagsThoroughly","generateImpliedEndTagsWithExclusion","exclusionId","AREA","BASE","BASEFONT","BGSOUND","BR","COL","EMBED","FRAME","HR","IMG","INPUT","KEYGEN","LINK","META","PARAM","SOURCE","TRACK","WBR","Preprocessor","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","col","Number","offset","getError","code","cpOffset","startCol","startOffset","startLine","endLine","endCol","endOffset","_err","onParseError","_addGap","_processSurrogate","cp","nextCp","charCodeAt","isSurrogatePair","getSurrogatePairCodePoint","EOF","ERR","surrogateInInputStream","willDropParsedChunk","dropParsedChunk","substring","write","chunk","isLastChunk","insertHtmlAtCurrentPos","startsWith","pattern","caseSensitive","peek","CARRIAGE_RETURN","LINE_FEED","advance","isSurrogate","_checkForProblematicCharacters","isControlCodePoint","controlCharacterInInputStream","isUndefinedCodePoint","noncharacterInInputStream","retreat","count"],"sourceRoot":""}
{"version":3,"file":"static/js/markdown-27545368.cd69629d9e.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/unist-util-is/lib/index.js","../node_modules/remark-rehype/node_modules/micromark-util-character/index.js","../node_modules/remark-rehype/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/remark-rehype/node_modules/micromark-util-sanitize-uri/index.js","../node_modules/unist-util-stringify-position/lib/index.js","../node_modules/remark-rehype/node_modules/unist-util-position/lib/index.js","../node_modules/remark-gfm/index.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-generated/lib/index.js","../node_modules/react-markdown/node_modules/is-buffer/index.js","../node_modules/remark-emoji/index.ts","../node_modules/react-markdown/node_modules/unified/lib/index.js","../node_modules/react-markdown/node_modules/remark-parse/lib/index.js","../node_modules/react-markdown/lib/rehype-filter.js","../node_modules/react-markdown/lib/ast-to-react.js","../node_modules/react-markdown/lib/react-markdown.js","../node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../node_modules/remark-math/index.js","../node_modules/react-markdown/lib/uri-transformer.js","../node_modules/unist-util-find-after/lib/index.js","../node_modules/react-markdown/node_modules/react-is/cjs/react-is.production.min.js","../node_modules/react-markdown/node_modules/react-is/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The node’s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","import {asciiAlphanumeric} from 'micromark-util-character'\nimport {encode} from 'micromark-util-encode'\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''))\n  if (!protocol) {\n    return value\n  }\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n  if (\n    // If there is no protocol, it’s relative.\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    protocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n  return ''\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n  let start = 0\n  let skip = 0\n  while (++index < value.length) {\n    const code = value.charCodeAt(index)\n    /** @type {string} */\n    let replace = ''\n\n    // A correct percent encoded value.\n    if (\n      code === 37 &&\n      asciiAlphanumeric(value.charCodeAt(index + 1)) &&\n      asciiAlphanumeric(value.charCodeAt(index + 2))\n    ) {\n      skip = 2\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code)\n      }\n    }\n    // Astral.\n    else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1)\n\n      // A correct surrogate pair.\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next)\n        skip = 1\n      }\n      // Lone surrogate.\n      else {\n        replace = '\\uFFFD'\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code)\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace))\n      start = index + skip + 1\n      replace = ''\n    }\n    if (skip) {\n      index += skip\n      skip = 0\n    }\n  }\n  return result.join('') + value.slice(start)\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","/**\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {NodeLike | Node | null | undefined} [node]\n *   Node.\n * @returns {Position}\n *   Position.\n */\nexport function position(node) {\n  return {start: pointStart(node), end: pointEnd(node)}\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'start' | 'end'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {NodeLike | Node | null | undefined} [node]\n   * @returns {Point}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    // To do: next major: don’t return points when invalid.\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: point.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: point.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: point.offset > -1 ? point.offset : null\n    }\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   > 👉 **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesn’t improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesn’t hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isn’t a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","import { get as getEmoji } from 'node-emoji';\nimport { emoticon } from 'emoticon';\nimport { findAndReplace, type Find, type Replace } from 'mdast-util-find-and-replace';\nimport type { Plugin } from 'unified';\nimport type { Root, Nodes, Text } from 'mdast';\n\nconst RE_EMOJI = /:\\+1:|:-1:|:[\\w-]+:/g;\nconst RE_SHORT = /[$@|*'\",;.=:\\-)([\\]\\\\/<>038BOopPsSdDxXzZ]{2,5}/g;\nconst RE_PUNCT = /(?:_|-(?!1))/g;\n\n/**\n * Configuration of remark-emoji plugin.\n */\nexport interface RemarkEmojiOptions {\n    /**\n     * Makes converted emoji and emoticon texts accessible by wrapping them with\n     * `span` element setting `role` and `aria-label` attributes.\n     *\n     * @defaultValue false\n     */\n    accessible?: boolean;\n    /**\n     * Adds an extra whitespace after emoji.\n     * Useful when browser handle emojis with half character length and\n     * the following character is hidden.\n     *\n     * @defaultValue false\n     */\n    padSpaceAfter?: boolean;\n    /**\n     * Whether to support emoticon shortcodes (e.g. :-) will be replaced by 😃)\n     *\n     * @defaultValue false\n     */\n    emoticon?: boolean;\n}\n\nconst DEFAULT_SETTINGS: RemarkEmojiOptions = {\n    padSpaceAfter: false,\n    emoticon: false,\n    accessible: false,\n};\n\nconst plugin: Plugin<[(RemarkEmojiOptions | null | undefined)?], Root> = options => {\n    const settings = Object.assign({}, DEFAULT_SETTINGS, options);\n    const pad = !!settings.padSpaceAfter;\n    const emoticonEnable = !!settings.emoticon;\n    const accessible = !!settings.accessible;\n\n    function aria(text: string, label: string): Text {\n        // Creating HTML node in Markdown node is undocumented.\n        // https://github.com/syntax-tree/mdast-util-math/blob/e70bb824dc70f5423324b31b0b68581cf6698fe8/index.js#L44-L55\n        return {\n            type: 'text',\n            value: text,\n            data: {\n                hName: 'span',\n                hProperties: {\n                    role: 'img',\n                    ariaLabel: label,\n                },\n                hChildren: [{ type: 'text', value: text }],\n            },\n        };\n    }\n\n    function replaceEmoticon(match: string): string | false | Text {\n        // find emoji by shortcode - full match or with-out last char as it could be from text e.g. :-),\n        const iconFull = emoticon.find(e => e.emoticons.includes(match)); // full match\n        const iconPart = emoticon.find(e => e.emoticons.includes(match.slice(0, -1))); // second search pattern\n        const icon = iconFull || iconPart;\n        if (!icon) {\n            return false;\n        }\n        const trimmedChar = !iconFull && iconPart ? match.slice(-1) : '';\n        const addPad = pad ? ' ' : '';\n        const replaced = icon.emoji + addPad + trimmedChar;\n        if (accessible) {\n            return aria(replaced, icon.name + ' emoticon');\n        }\n        return replaced;\n    }\n\n    function replaceEmoji(match: string): string | false | Text {\n        let got = getEmoji(match);\n\n        if (typeof got === 'undefined') {\n            return false;\n        }\n\n        if (pad) {\n            got = got + ' ';\n        }\n\n        if (accessible) {\n            const label = match.slice(1, -1).replace(RE_PUNCT, ' ') + ' emoji';\n            return aria(got, label);\n        }\n\n        return got;\n    }\n\n    const replacers: [Find, Replace][] = [[RE_EMOJI, replaceEmoji]];\n    if (emoticonEnable) {\n        replacers.push([RE_SHORT, replaceEmoticon]);\n    }\n\n    function transformer(tree: Nodes): void {\n        findAndReplace(tree, replacers);\n    }\n\n    return transformer;\n};\n\nexport default plugin;\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} Options\n */\n\nimport {fromMarkdown} from 'mdast-util-from-markdown'\n\n/**\n * @this {import('unified').Processor}\n * @type {import('unified').Plugin<[Options?] | void[], string, Root>}\n */\nexport default function remarkParse(options) {\n  /** @type {import('unified').ParserFunction<Root>} */\n  const parser = (doc) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return fromMarkdown(\n      doc,\n      Object.assign({}, settings, options, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data('micromarkExtensions') || [],\n        mdastExtensions: this.data('fromMarkdownExtensions') || []\n      })\n    )\n  }\n\n  Object.assign(this, {Parser: parser})\n}\n","import {visit} from 'unist-util-visit'\n\n/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n *\n * @callback AllowElement\n * @param {Element} element\n * @param {number} index\n * @param {Element|Root} parent\n * @returns {boolean|undefined}\n *\n * @typedef Options\n * @property {Array<string>} [allowedElements]\n * @property {Array<string>} [disallowedElements=[]]\n * @property {AllowElement} [allowElement]\n * @property {boolean} [unwrapDisallowed=false]\n */\n\n/**\n * @type {import('unified').Plugin<[Options], Root>}\n */\nexport default function rehypeFilter(options) {\n  if (options.allowedElements && options.disallowedElements) {\n    throw new TypeError(\n      'Only one of `allowedElements` and `disallowedElements` should be defined'\n    )\n  }\n\n  if (\n    options.allowedElements ||\n    options.disallowedElements ||\n    options.allowElement\n  ) {\n    return (tree) => {\n      visit(tree, 'element', (node, index, parent_) => {\n        const parent = /** @type {Element|Root} */ (parent_)\n        /** @type {boolean|undefined} */\n        let remove\n\n        if (options.allowedElements) {\n          remove = !options.allowedElements.includes(node.tagName)\n        } else if (options.disallowedElements) {\n          remove = options.disallowedElements.includes(node.tagName)\n        }\n\n        if (!remove && options.allowElement && typeof index === 'number') {\n          remove = !options.allowElement(node, index, parent)\n        }\n\n        if (remove && typeof index === 'number') {\n          if (options.unwrapDisallowed && node.children) {\n            parent.children.splice(index, 1, ...node.children)\n          } else {\n            parent.children.splice(index, 1)\n          }\n\n          return index\n        }\n\n        return undefined\n      })\n    }\n  }\n}\n","/**\n * @template T\n * @typedef {import('react').ComponentType<T>} ComponentType<T>\n */\n\n/**\n * @template {import('react').ElementType} T\n * @typedef {import('react').ComponentPropsWithoutRef<T>} ComponentPropsWithoutRef<T>\n */\n\n/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('unist').Position} Position\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('./complex-types.js').ReactMarkdownProps} ReactMarkdownProps\n *\n * @typedef Raw\n * @property {'raw'} type\n * @property {string} value\n *\n * @typedef Context\n * @property {Options} options\n * @property {Schema} schema\n * @property {number} listDepth\n *\n * @callback TransformLink\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {string}\n *\n * @callback TransformImage\n * @param {string} src\n * @param {string} alt\n * @param {string?} title\n * @returns {string}\n *\n * @typedef {import('react').HTMLAttributeAnchorTarget} TransformLinkTargetType\n *\n * @callback TransformLinkTarget\n * @param {string} href\n * @param {Array<ElementContent>} children\n * @param {string?} title\n * @returns {TransformLinkTargetType|undefined}\n *\n * @typedef {keyof JSX.IntrinsicElements} ReactMarkdownNames\n *\n * To do: is `data-sourcepos` typeable?\n *\n * @typedef {ComponentPropsWithoutRef<'code'> & ReactMarkdownProps & {inline?: boolean}} CodeProps\n * @typedef {ComponentPropsWithoutRef<'h1'> & ReactMarkdownProps & {level: number}} HeadingProps\n * @typedef {ComponentPropsWithoutRef<'li'> & ReactMarkdownProps & {checked: boolean|null, index: number, ordered: boolean}} LiProps\n * @typedef {ComponentPropsWithoutRef<'ol'> & ReactMarkdownProps & {depth: number, ordered: true}} OrderedListProps\n * @typedef {ComponentPropsWithoutRef<'td'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: false}} TableDataCellProps\n * @typedef {ComponentPropsWithoutRef<'th'> & ReactMarkdownProps & {style?: Record<string, unknown>, isHeader: true}} TableHeaderCellProps\n * @typedef {ComponentPropsWithoutRef<'tr'> & ReactMarkdownProps & {isHeader: boolean}} TableRowProps\n * @typedef {ComponentPropsWithoutRef<'ul'> & ReactMarkdownProps & {depth: number, ordered: false}} UnorderedListProps\n *\n * @typedef {ComponentType<CodeProps>} CodeComponent\n * @typedef {ComponentType<HeadingProps>} HeadingComponent\n * @typedef {ComponentType<LiProps>} LiComponent\n * @typedef {ComponentType<OrderedListProps>} OrderedListComponent\n * @typedef {ComponentType<TableDataCellProps>} TableDataCellComponent\n * @typedef {ComponentType<TableHeaderCellProps>} TableHeaderCellComponent\n * @typedef {ComponentType<TableRowProps>} TableRowComponent\n * @typedef {ComponentType<UnorderedListProps>} UnorderedListComponent\n *\n * @typedef SpecialComponents\n * @property {CodeComponent|ReactMarkdownNames} code\n * @property {HeadingComponent|ReactMarkdownNames} h1\n * @property {HeadingComponent|ReactMarkdownNames} h2\n * @property {HeadingComponent|ReactMarkdownNames} h3\n * @property {HeadingComponent|ReactMarkdownNames} h4\n * @property {HeadingComponent|ReactMarkdownNames} h5\n * @property {HeadingComponent|ReactMarkdownNames} h6\n * @property {LiComponent|ReactMarkdownNames} li\n * @property {OrderedListComponent|ReactMarkdownNames} ol\n * @property {TableDataCellComponent|ReactMarkdownNames} td\n * @property {TableHeaderCellComponent|ReactMarkdownNames} th\n * @property {TableRowComponent|ReactMarkdownNames} tr\n * @property {UnorderedListComponent|ReactMarkdownNames} ul\n *\n * @typedef {Partial<Omit<import('./complex-types.js').NormalComponents, keyof SpecialComponents> & SpecialComponents>} Components\n *\n * @typedef Options\n * @property {boolean} [sourcePos=false]\n * @property {boolean} [rawSourcePos=false]\n * @property {boolean} [skipHtml=false]\n * @property {boolean} [includeElementIndex=false]\n * @property {null|false|TransformLink} [transformLinkUri]\n * @property {TransformImage} [transformImageUri]\n * @property {TransformLinkTargetType|TransformLinkTarget} [linkTarget]\n * @property {Components} [components]\n */\n\nimport React from 'react'\nimport ReactIs from 'react-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport style from 'style-to-object'\nimport {uriTransformer} from './uri-transformer.js'\n\nconst own = {}.hasOwnProperty\n\n// The table-related elements that must not contain whitespace text according\n// to React.\nconst tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])\n\n/**\n * @param {Context} context\n * @param {Element|Root} node\n */\nexport function childrenToReact(context, node) {\n  /** @type {Array<ReactNode>} */\n  const children = []\n  let childIndex = -1\n  /** @type {Comment|Doctype|Element|Raw|Text} */\n  let child\n\n  while (++childIndex < node.children.length) {\n    child = node.children[childIndex]\n\n    if (child.type === 'element') {\n      children.push(toReact(context, child, childIndex, node))\n    } else if (child.type === 'text') {\n      // Currently, a warning is triggered by react for *any* white space in\n      // tables.\n      // So we drop it.\n      // See: <https://github.com/facebook/react/pull/7081>.\n      // See: <https://github.com/facebook/react/pull/7515>.\n      // See: <https://github.com/remarkjs/remark-react/issues/64>.\n      // See: <https://github.com/remarkjs/react-markdown/issues/576>.\n      if (\n        node.type !== 'element' ||\n        !tableElements.has(node.tagName) ||\n        !whitespace(child)\n      ) {\n        children.push(child.value)\n      }\n    } else if (child.type === 'raw' && !context.options.skipHtml) {\n      // Default behavior is to show (encoded) HTML.\n      children.push(child.value)\n    }\n  }\n\n  return children\n}\n\n/**\n * @param {Context} context\n * @param {Element} node\n * @param {number} index\n * @param {Element|Root} parent\n */\nfunction toReact(context, node, index, parent) {\n  const options = context.options\n  const transform =\n    options.transformLinkUri === undefined\n      ? uriTransformer\n      : options.transformLinkUri\n  const parentSchema = context.schema\n  /** @type {ReactMarkdownNames} */\n  // @ts-expect-error assume a known HTML/SVG element.\n  const name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const properties = {}\n  let schema = parentSchema\n  /** @type {string} */\n  let property\n\n  if (parentSchema.space === 'html' && name === 'svg') {\n    schema = svg\n    context.schema = schema\n  }\n\n  if (node.properties) {\n    for (property in node.properties) {\n      if (own.call(node.properties, property)) {\n        addProperty(properties, property, node.properties[property], context)\n      }\n    }\n  }\n\n  if (name === 'ol' || name === 'ul') {\n    context.listDepth++\n  }\n\n  const children = childrenToReact(context, node)\n\n  if (name === 'ol' || name === 'ul') {\n    context.listDepth--\n  }\n\n  // Restore parent schema.\n  context.schema = parentSchema\n\n  // Nodes created by plugins do not have positional info, in which case we use\n  // an object that matches the position interface.\n  const position = node.position || {\n    start: {line: null, column: null, offset: null},\n    end: {line: null, column: null, offset: null}\n  }\n  const component =\n    options.components && own.call(options.components, name)\n      ? options.components[name]\n      : name\n  const basic = typeof component === 'string' || component === React.Fragment\n\n  if (!ReactIs.isValidElementType(component)) {\n    throw new TypeError(\n      `Component for name \\`${name}\\` not defined or is not renderable`\n    )\n  }\n\n  properties.key = index\n\n  if (name === 'a' && options.linkTarget) {\n    properties.target =\n      typeof options.linkTarget === 'function'\n        ? options.linkTarget(\n            String(properties.href || ''),\n            node.children,\n            typeof properties.title === 'string' ? properties.title : null\n          )\n        : options.linkTarget\n  }\n\n  if (name === 'a' && transform) {\n    properties.href = transform(\n      String(properties.href || ''),\n      node.children,\n      typeof properties.title === 'string' ? properties.title : null\n    )\n  }\n\n  if (\n    !basic &&\n    name === 'code' &&\n    parent.type === 'element' &&\n    parent.tagName !== 'pre'\n  ) {\n    properties.inline = true\n  }\n\n  if (\n    !basic &&\n    (name === 'h1' ||\n      name === 'h2' ||\n      name === 'h3' ||\n      name === 'h4' ||\n      name === 'h5' ||\n      name === 'h6')\n  ) {\n    properties.level = Number.parseInt(name.charAt(1), 10)\n  }\n\n  if (name === 'img' && options.transformImageUri) {\n    properties.src = options.transformImageUri(\n      String(properties.src || ''),\n      String(properties.alt || ''),\n      typeof properties.title === 'string' ? properties.title : null\n    )\n  }\n\n  if (!basic && name === 'li' && parent.type === 'element') {\n    const input = getInputElement(node)\n    properties.checked =\n      input && input.properties ? Boolean(input.properties.checked) : null\n    properties.index = getElementsBeforeCount(parent, node)\n    properties.ordered = parent.tagName === 'ol'\n  }\n\n  if (!basic && (name === 'ol' || name === 'ul')) {\n    properties.ordered = name === 'ol'\n    properties.depth = context.listDepth\n  }\n\n  if (name === 'td' || name === 'th') {\n    if (properties.align) {\n      if (!properties.style) properties.style = {}\n      // @ts-expect-error assume `style` is an object\n      properties.style.textAlign = properties.align\n      delete properties.align\n    }\n\n    if (!basic) {\n      properties.isHeader = name === 'th'\n    }\n  }\n\n  if (!basic && name === 'tr' && parent.type === 'element') {\n    properties.isHeader = Boolean(parent.tagName === 'thead')\n  }\n\n  // If `sourcePos` is given, pass source information (line/column info from markdown source).\n  if (options.sourcePos) {\n    properties['data-sourcepos'] = flattenPosition(position)\n  }\n\n  if (!basic && options.rawSourcePos) {\n    properties.sourcePosition = node.position\n  }\n\n  // If `includeElementIndex` is given, pass node index info to components.\n  if (!basic && options.includeElementIndex) {\n    properties.index = getElementsBeforeCount(parent, node)\n    properties.siblingCount = getElementsBeforeCount(parent)\n  }\n\n  if (!basic) {\n    properties.node = node\n  }\n\n  // Ensure no React warnings are emitted for void elements w/ children.\n  return children.length > 0\n    ? React.createElement(component, properties, children)\n    : React.createElement(component, properties)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {Element?}\n */\nfunction getInputElement(node) {\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'input') {\n      return child\n    }\n  }\n\n  return null\n}\n\n/**\n * @param {Element|Root} parent\n * @param {Element} [node]\n * @returns {number}\n */\nfunction getElementsBeforeCount(parent, node) {\n  let index = -1\n  let count = 0\n\n  while (++index < parent.children.length) {\n    if (parent.children[index] === node) break\n    if (parent.children[index].type === 'element') count++\n  }\n\n  return count\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {unknown} value\n * @param {Context} ctx\n */\nfunction addProperty(props, prop, value, ctx) {\n  const info = find(ctx.schema, prop)\n  let result = value\n\n  // Ignore nullish and `NaN` values.\n  // eslint-disable-next-line no-self-compare\n  if (result === null || result === undefined || result !== result) {\n    return\n  }\n\n  // Accept `array`.\n  // Most props are space-separated.\n  if (Array.isArray(result)) {\n    result = info.commaSeparated ? commas(result) : spaces(result)\n  }\n\n  if (info.property === 'style' && typeof result === 'string') {\n    result = parseStyle(result)\n  }\n\n  if (info.space && info.property) {\n    props[\n      own.call(hastToReact, info.property)\n        ? hastToReact[info.property]\n        : info.property\n    ] = result\n  } else if (info.attribute) {\n    props[info.attribute] = result\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Record<string, string>}\n */\nfunction parseStyle(value) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    style(value, iterator)\n  } catch {\n    // Silent.\n  }\n\n  return result\n\n  /**\n   * @param {string} name\n   * @param {string} v\n   */\n  function iterator(name, v) {\n    const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name\n    result[k.replace(/-([a-z])/g, styleReplacer)] = v\n  }\n}\n\n/**\n * @param {unknown} _\n * @param {string} $1\n */\nfunction styleReplacer(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos\n * @returns {string}\n */\nfunction flattenPosition(pos) {\n  return [\n    pos.start.line,\n    ':',\n    pos.start.column,\n    '-',\n    pos.end.line,\n    ':',\n    pos.end.column\n  ]\n    .map(String)\n    .join('')\n}\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('react').ReactElement<{}>} ReactElement\n * @typedef {import('unified').PluggableList} PluggableList\n * @typedef {import('hast').Root} Root\n * @typedef {import('./rehype-filter.js').Options} FilterOptions\n * @typedef {import('./ast-to-react.js').Options} TransformOptions\n *\n * @typedef CoreOptions\n * @property {string} children\n *\n * @typedef PluginOptions\n * @property {PluggableList} [remarkPlugins=[]]\n * @property {PluggableList} [rehypePlugins=[]]\n * @property {import('remark-rehype').Options | undefined} [remarkRehypeOptions={}]\n *\n * @typedef LayoutOptions\n * @property {string} [className]\n *\n * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions\n *\n * @typedef Deprecation\n * @property {string} id\n * @property {string} [to]\n */\n\nimport React from 'react'\nimport {VFile} from 'vfile'\nimport {unified} from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport PropTypes from 'prop-types'\nimport {html} from 'property-information'\nimport rehypeFilter from './rehype-filter.js'\nimport {childrenToReact} from './ast-to-react.js'\n\nconst own = {}.hasOwnProperty\nconst changelog =\n  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'\n\n/** @type {Record<string, Deprecation>} */\nconst deprecated = {\n  plugins: {to: 'remarkPlugins', id: 'change-plugins-to-remarkplugins'},\n  renderers: {to: 'components', id: 'change-renderers-to-components'},\n  astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},\n  allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},\n  escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},\n  source: {to: 'children', id: 'change-source-to-children'},\n  allowNode: {\n    to: 'allowElement',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  allowedTypes: {\n    to: 'allowedElements',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  disallowedTypes: {\n    to: 'disallowedElements',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes'\n  },\n  includeNodeIndex: {\n    to: 'includeElementIndex',\n    id: 'change-includenodeindex-to-includeelementindex'\n  }\n}\n\n/**\n * React component to render markdown.\n *\n * @param {ReactMarkdownOptions} options\n * @returns {ReactElement}\n */\nexport function ReactMarkdown(options) {\n  for (const key in deprecated) {\n    if (own.call(deprecated, key) && own.call(options, key)) {\n      const deprecation = deprecated[key]\n      console.warn(\n        `[react-markdown] Warning: please ${\n          deprecation.to ? `use \\`${deprecation.to}\\` instead of` : 'remove'\n        } \\`${key}\\` (see <${changelog}#${deprecation.id}> for more info)`\n      )\n      delete deprecated[key]\n    }\n  }\n\n  const processor = unified()\n    .use(remarkParse)\n    .use(options.remarkPlugins || [])\n    .use(remarkRehype, {\n      ...options.remarkRehypeOptions,\n      allowDangerousHtml: true\n    })\n    .use(options.rehypePlugins || [])\n    .use(rehypeFilter, options)\n\n  const file = new VFile()\n\n  if (typeof options.children === 'string') {\n    file.value = options.children\n  } else if (options.children !== undefined && options.children !== null) {\n    console.warn(\n      `[react-markdown] Warning: please pass a string as \\`children\\` (not: \\`${options.children}\\`)`\n    )\n  }\n\n  const hastNode = processor.runSync(processor.parse(file), file)\n\n  if (hastNode.type !== 'root') {\n    throw new TypeError('Expected a `root` node')\n  }\n\n  /** @type {ReactElement} */\n  let result = React.createElement(\n    React.Fragment,\n    {},\n    childrenToReact({options, schema: html, listDepth: 0}, hastNode)\n  )\n\n  if (options.className) {\n    result = React.createElement('div', {className: options.className}, result)\n  }\n\n  return result\n}\n\nReactMarkdown.propTypes = {\n  // Core options:\n  children: PropTypes.string,\n  // Layout options:\n  className: PropTypes.string,\n  // Filter options:\n  allowElement: PropTypes.func,\n  allowedElements: PropTypes.arrayOf(PropTypes.string),\n  disallowedElements: PropTypes.arrayOf(PropTypes.string),\n  unwrapDisallowed: PropTypes.bool,\n  // Plugin options:\n  remarkPlugins: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.object,\n      PropTypes.func,\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([\n          PropTypes.bool,\n          PropTypes.string,\n          PropTypes.object,\n          PropTypes.func,\n          PropTypes.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            PropTypes.any\n          )\n        ])\n      )\n    ])\n  ),\n  rehypePlugins: PropTypes.arrayOf(\n    PropTypes.oneOfType([\n      PropTypes.object,\n      PropTypes.func,\n      PropTypes.arrayOf(\n        PropTypes.oneOfType([\n          PropTypes.bool,\n          PropTypes.string,\n          PropTypes.object,\n          PropTypes.func,\n          PropTypes.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            PropTypes.any\n          )\n        ])\n      )\n    ])\n  ),\n  // Transform options:\n  sourcePos: PropTypes.bool,\n  rawSourcePos: PropTypes.bool,\n  skipHtml: PropTypes.bool,\n  includeElementIndex: PropTypes.bool,\n  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  transformImageUri: PropTypes.func,\n  components: PropTypes.object\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","const protocols = ['http', 'https', 'mailto', 'tel']\n\n/**\n * @param {string} uri\n * @returns {string}\n */\nexport function uriTransformer(uri) {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  if (first === '#' || first === '/') {\n    return url\n  }\n\n  const colon = url.indexOf(':')\n  if (colon === -1) {\n    return url\n  }\n\n  let index = -1\n\n  while (++index < protocols.length) {\n    const protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      url.slice(0, protocol.length).toLowerCase() === protocol\n    ) {\n      return url\n    }\n  }\n\n  index = url.indexOf('?')\n  if (index !== -1 && colon > index) {\n    return url\n  }\n\n  index = url.indexOf('#')\n  if (index !== -1 && colon > index) {\n    return url\n  }\n\n  // eslint-disable-next-line no-script-url\n  return 'javascript:void(0)'\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var b=Symbol.for(\"react.element\"),c=Symbol.for(\"react.portal\"),d=Symbol.for(\"react.fragment\"),e=Symbol.for(\"react.strict_mode\"),f=Symbol.for(\"react.profiler\"),g=Symbol.for(\"react.provider\"),h=Symbol.for(\"react.context\"),k=Symbol.for(\"react.server_context\"),l=Symbol.for(\"react.forward_ref\"),m=Symbol.for(\"react.suspense\"),n=Symbol.for(\"react.suspense_list\"),p=Symbol.for(\"react.memo\"),q=Symbol.for(\"react.lazy\"),t=Symbol.for(\"react.offscreen\"),u;u=Symbol.for(\"react.module.reference\");\nfunction v(a){if(\"object\"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}exports.ContextConsumer=h;exports.ContextProvider=g;exports.Element=b;exports.ForwardRef=l;exports.Fragment=d;exports.Lazy=q;exports.Memo=p;exports.Portal=c;exports.Profiler=f;exports.StrictMode=e;exports.Suspense=m;\nexports.SuspenseList=n;exports.isAsyncMode=function(){return!1};exports.isConcurrentMode=function(){return!1};exports.isContextConsumer=function(a){return v(a)===h};exports.isContextProvider=function(a){return v(a)===g};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===b};exports.isForwardRef=function(a){return v(a)===l};exports.isFragment=function(a){return v(a)===d};exports.isLazy=function(a){return v(a)===q};exports.isMemo=function(a){return v(a)===p};\nexports.isPortal=function(a){return v(a)===c};exports.isProfiler=function(a){return v(a)===f};exports.isStrictMode=function(a){return v(a)===e};exports.isSuspense=function(a){return v(a)===m};exports.isSuspenseList=function(a){return v(a)===n};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||\"object\"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};exports.typeOf=v;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n"],"names":["convert","test","ok","castFactory","Array","isArray","tests","checks","index","length","_len","arguments","parameters","_key","apply","this","anyFactory","check","checkAsRecord","node","nodeAsRecord","key","propsFactory","type","Error","testFunction","value","parent","Boolean","looksLikeANode","call","undefined","regexCheck","asciiAlphanumeric","regex","code","String","fromCharCode","normalizeUri","result","start","skip","charCodeAt","replace","next","push","slice","encodeURIComponent","join","stringifyPosition","position","point","line","column","pos","end","pointStart","pointEnd","offset","remarkGfm","options","data","add","field","gfm","gfmFromMarkdown","gfmToMarkdown","empty","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","Object","defineProperty","visit","subresult","grandparents","toResult","children","nodeAsParent","concat","child","generated","module","exports","obj","constructor","isBuffer","RE_EMOJI","RE_SHORT","RE_PUNCT","DEFAULT_SETTINGS","padSpaceAfter","emoticon","accessible","settings","assign","pad","emoticonEnable","aria","text","label","hName","hProperties","role","ariaLabel","hChildren","replacers","match","got","getEmoji","iconFull","find","e","emoticons","includes","iconPart","icon","trimmedChar","addPad","replaced","emoji","findAndReplace","unified","base","transformers","trough","attachers","frozen","namespace","freezeIndex","processor","assertUnfrozen","own","Parser","Compiler","freeze","attacher","transformer","use","Number","POSITIVE_INFINITY","addPlugin","TypeError","addList","addPreset","plugin","plugins","entry","isPlainObj","extend","parse","doc","file","vfile","assertParser","newable","stringify","assertCompiler","assertNode","compile","run","callback","Promise","executor","resolve","reject","error","runSync","complete","bail","assertDone","process","done","processSync","destination","hasOwnProperty","prototype","keys","asyncName","looksLikeAVFile","VFile","remarkParse","fromMarkdown","extensions","mdastExtensions","rehypeFilter","allowedElements","disallowedElements","allowElement","parent_","remove","unwrapDisallowed","splice","tableElements","Set","childrenToReact","context","childIndex","toReact","has","whitespace","skipHtml","transform","transformLinkUri","uriTransformer","parentSchema","schema","properties","property","space","svg","addProperty","listDepth","component","components","basic","React","ReactIs","linkTarget","target","href","title","inline","level","parseInt","charAt","transformImageUri","src","alt","input","getInputElement","checked","getElementsBeforeCount","ordered","depth","align","style","textAlign","isHeader","sourcePos","map","rawSourcePos","sourcePosition","includeElementIndex","siblingCount","count","props","prop","ctx","info","commaSeparated","commas","spaces","v","k","styleReplacer","parseStyle","hastToReact","attribute","_","$1","toUpperCase","deprecated","to","id","renderers","astPlugins","allowDangerousHtml","escapeHtml","source","allowNode","allowedTypes","disallowedTypes","includeNodeIndex","ReactMarkdown","remarkPlugins","remarkRehype","remarkRehypeOptions","rehypePlugins","hastNode","html","className","propTypes","PropTypes","_len2","_key2","indexOf","remarkMath","math","mathFromMarkdown","mathToMarkdown","protocols","uri","url","trim","first","colon","protocol","toLowerCase","findAfter","u","b","Symbol","for","c","d","f","g","h","l","m","n","p","q","t","a","r","$$typeof","ContextConsumer","ContextProvider","Element","ForwardRef","Fragment","Lazy","Memo","Portal","Profiler","StrictMode","Suspense","SuspenseList","isAsyncMode","isConcurrentMode","isContextConsumer","isContextProvider","isElement","isForwardRef","isFragment","isLazy","isMemo","isPortal","isProfiler","isStrictMode","isSuspense","isSuspenseList","isValidElementType","getModuleId","typeOf"],"sourceRoot":""}
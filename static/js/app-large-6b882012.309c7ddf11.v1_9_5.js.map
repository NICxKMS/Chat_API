{"version":3,"file":"static/js/app-large-6b882012.309c7ddf11.v1_9_5.js","mappings":"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","sources":["utils/chunkOptimizer.js","utils/performance.js","reportWebVitals.js","serviceWorkerRegistration.js","utils/messageHelpers.js","utils/formatters.js","utils/network.js"],"sourcesContent":["/**\n * Chunk Optimization Utility\n * Helps with intelligent loading and grouping of small chunks\n */\n\n// Track loaded chunks to avoid duplicate loading\nconst loadedChunks = new Set();\nconst loadingChunks = new Map();\n\n/**\n * Intelligent chunk loader that groups small imports together\n * @param {Object} importMap - Map of import functions\n * @param {Object} options - Loading options\n */\nexport const loadChunkGroup = async (importMap, options = {}) => {\n  const {\n    groupName = 'default',\n    priority = 0,\n    timeout = 5000,\n    retries = 2,\n  } = options;\n\n  // Check if already loaded\n  if (loadedChunks.has(groupName)) {\n    return Promise.resolve();\n  }\n\n  // Check if currently loading\n  if (loadingChunks.has(groupName)) {\n    return loadingChunks.get(groupName);\n  }\n\n  const loadPromise = loadWithRetry(importMap, groupName, retries, timeout);\n  loadingChunks.set(groupName, loadPromise);\n\n  try {\n    await loadPromise;\n    loadedChunks.add(groupName);\n    loadingChunks.delete(groupName);\n  } catch (error) {\n    loadingChunks.delete(groupName);\n    throw error;\n  }\n\n  return loadPromise;\n};\n\n/**\n * Load chunks with retry logic\n */\nconst loadWithRetry = async (importMap, groupName, retries, timeout) => {\n  let lastError;\n\n  for (let attempt = 0; attempt <= retries; attempt++) {\n    try {\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(`Timeout loading ${groupName}`)), timeout);\n      });\n\n      const loadPromise = Promise.all(\n        Object.entries(importMap).map(async ([key, importFn]) => {\n          try {\n            const module = await importFn();\n            console.log(`âœ“ Loaded ${groupName}.${key}`);\n            return { key, module };\n          } catch (error) {\n            console.warn(`âœ— Failed to load ${groupName}.${key}:`, error);\n            throw error;\n          }\n        })\n      );\n\n      await Promise.race([loadPromise, timeoutPromise]);\n      console.log(`âœ“ Chunk group '${groupName}' loaded successfully`);\n      return;\n    } catch (error) {\n      lastError = error;\n      if (attempt < retries) {\n        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff\n        console.warn(`Retry ${attempt + 1}/${retries} for ${groupName} in ${delay}ms`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError;\n};\n\n/**\n * Preload chunks during idle time with intelligent scheduling\n */\nexport const idlePreloadChunks = (chunkGroups, options = {}) => {\n  const {\n    maxConcurrent = 2,\n    priorityDelay = 100,\n    idleTimeout = 5000,\n  } = options;\n\n  let currentlyLoading = 0;\n  const queue = Object.entries(chunkGroups)\n    .sort(([, a], [, b]) => (a.priority || 0) - (b.priority || 0));\n\n  const processQueue = () => {\n    if (currentlyLoading >= maxConcurrent || queue.length === 0) {\n      return;\n    }\n\n    const [groupName, config] = queue.shift();\n    currentlyLoading++;\n\n    const delay = (config.priority || 0) * priorityDelay;\n\n    setTimeout(() => {\n      requestIdleCallback(async () => {\n        try {\n          await loadChunkGroup(config.imports, {\n            groupName,\n            timeout: idleTimeout,\n            ...config.options,\n          });\n        } catch (error) {\n          console.warn(`Idle preload failed for ${groupName}:`, error);\n        } finally {\n          currentlyLoading--;\n          processQueue(); // Process next in queue\n        }\n      }, { timeout: idleTimeout });\n    }, delay);\n  };\n\n  // Start processing\n  processQueue();\n  processQueue(); // Start with max concurrent if possible\n};\n\n/**\n * Smart chunk bundler that groups small modules together\n */\nexport const createSmallChunkBundle = (modules, bundleName = 'small-bundle') => {\n  const bundleImport = () => Promise.all(\n    modules.map(async (moduleImport) => {\n      try {\n        return await moduleImport();\n      } catch (error) {\n        console.warn(`Failed to load module in ${bundleName}:`, error);\n        return null;\n      }\n    })\n  ).then(results => results.filter(Boolean));\n\n  return {\n    [bundleName]: bundleImport,\n  };\n};\n\n/**\n * Monitor chunk loading performance\n */\nexport const createChunkMonitor = () => {\n  const metrics = {\n    loadTimes: new Map(),\n    failures: new Map(),\n    totalLoaded: 0,\n    totalFailed: 0,\n  };\n\n  return {\n    startLoad: (chunkName) => {\n      metrics.loadTimes.set(chunkName, performance.now());\n    },\n\n    endLoad: (chunkName, success = true) => {\n      const startTime = metrics.loadTimes.get(chunkName);\n      if (startTime) {\n        const duration = performance.now() - startTime;\n        if (success) {\n          metrics.totalLoaded++;\n          console.log(`ðŸ“Š Chunk '${chunkName}' loaded in ${duration.toFixed(2)}ms`);\n        } else {\n          metrics.totalFailed++;\n          metrics.failures.set(chunkName, (metrics.failures.get(chunkName) || 0) + 1);\n          console.warn(`ðŸ“Š Chunk '${chunkName}' failed after ${duration.toFixed(2)}ms`);\n        }\n        metrics.loadTimes.delete(chunkName);\n      }\n    },\n\n    getMetrics: () => ({\n      ...metrics,\n      loadTimes: Object.fromEntries(metrics.loadTimes),\n      failures: Object.fromEntries(metrics.failures),\n    }),\n\n    reset: () => {\n      metrics.loadTimes.clear();\n      metrics.failures.clear();\n      metrics.totalLoaded = 0;\n      metrics.totalFailed = 0;\n    },\n  };\n};\n\n/**\n * Adaptive loading strategy based on network conditions\n */\nexport const createAdaptiveLoader = () => {\n  const getNetworkInfo = () => {\n    if ('connection' in navigator) {\n      const conn = navigator.connection;\n      return {\n        effectiveType: conn.effectiveType,\n        downlink: conn.downlink,\n        rtt: conn.rtt,\n        saveData: conn.saveData,\n      };\n    }\n    return { effectiveType: '4g', downlink: 10, rtt: 100, saveData: false };\n  };\n\n  const getLoadingStrategy = () => {\n    const network = getNetworkInfo();\n    \n    if (network.saveData || network.effectiveType === 'slow-2g' || network.effectiveType === '2g') {\n      return {\n        maxConcurrent: 4,\n        priorityDelay: 500,\n        timeout: 10000,\n        skipNonEssential: true,\n      };\n    }\n    \n    if (network.effectiveType === '3g') {\n      return {\n        maxConcurrent: 8,\n        priorityDelay: 200,\n        timeout: 8000,\n        skipNonEssential: false,\n      };\n    }\n    \n    // 4g or better\n    return {\n      maxConcurrent: 16,\n      priorityDelay: 100,\n      timeout: 5000,\n      skipNonEssential: false,\n    };\n  };\n\n  return {\n    getStrategy: getLoadingStrategy,\n    getNetworkInfo,\n  };\n};\n\n// Export utilities\nexport default {\n  loadChunkGroup,\n  idlePreloadChunks,\n  createSmallChunkBundle,\n  createChunkMonitor,\n  createAdaptiveLoader,\n}; ","/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  POST_INTERACTIVE_PRELOAD_START: 'post-interactive-preload-start',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  // eslint-disable-next-line no-useless-escape\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","export async function fetchWithRetry(input, init = {}, retries = 3, backoff = 500) {\n  let attempt = 0;\n  while (true) {\n    try {\n      const response = await fetch(input, init);\n      if (!response.ok) {\n        throw new Error(`Network error: ${response.status}`);\n      }\n      return response;\n    } catch (error) {\n      if (attempt >= retries) {\n        throw error;\n      }\n      // Exponential backoff with jitter\n      const delay = backoff * Math.pow(2, attempt) + Math.random() * 100;\n      await new Promise(res => setTimeout(res, delay));\n      attempt++;\n    }\n  }\n} "],"names":["loadedChunks","Set","loadingChunks","Map","loadChunkGroup","async","importMap","options","arguments","length","undefined","groupName","priority","timeout","retries","has","Promise","resolve","get","loadPromise","loadWithRetry","set","add","delete","error","lastError","attempt","timeoutPromise","_","reject","setTimeout","Error","all","Object","entries","map","key","importFn","_ref","module","race","delay","Math","pow","idlePreloadChunks","chunkGroups","maxConcurrent","priorityDelay","idleTimeout","currentlyLoading","queue","sort","_ref2","_ref3","a","b","processQueue","config","shift","requestIdleCallback","imports","createSmallChunkBundle","modules","bundleName","bundleImport","moduleImport","then","results","filter","Boolean","createChunkMonitor","metrics","loadTimes","failures","totalLoaded","totalFailed","startLoad","chunkName","performance","now","endLoad","success","getMetrics","fromEntries","reset","clear","createAdaptiveLoader","getNetworkInfo","navigator","conn","connection","effectiveType","downlink","rtt","saveData","getStrategy","getLoadingStrategy","network","skipNonEssential","PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","POST_INTERACTIVE_PRELOAD_START","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","measures","window","trackPaintMetrics","PerformanceObserver","getEntries","forEach","entry","markName","name","mark","measureName","measure","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clearMarks","clearMeasures","logMetrics","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","isLocalhost","location","hostname","match","register","URL","process","href","origin","addEventListener","swUrl","fetch","headers","response","contentType","status","indexOf","serviceWorker","ready","registration","unregister","reload","registerValidSW","catch","checkValidServiceWorker","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","processMessageContent","content","images","text","Array","isArray","texts","reduce","acc","part","type","push","url","image_url","alt","join","formatTime","ms","toFixed","convertTeXToMathDollars","combinedRegex","RegExp","result","replace","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","trim","fetchWithRetry","input","init","backoff","ok","random","res"],"sourceRoot":""}
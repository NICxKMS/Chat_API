{"version":3,"file":"static/js/7007.5f04b8d350.chunk.v1_7.js","mappings":"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","sources":["../node_modules/mdast-util-from-markdown/lib/index.js","../node_modules/mdast-util-definitions/lib/index.js","../node_modules/markdown-table/index.js","../node_modules/is-plain-obj/index.js","../node_modules/longest-streak/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    let tail = node.children[node.children.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: we’ll add `end` later.\n      tail.position = {\n        start: point(token.start)\n      }\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    setData('inReference', true)\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesn’t place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its “visible” size;\n *   note that what is and isn’t visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['中文', 'Charlie'],\n *     ['👩‍❤️‍👩', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | 中文 | Charlie |\n *   | 👩‍❤️‍👩 | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['中文', 'Charlie'],\n *       ['👩‍❤️‍👩', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | 中文  | Charlie |\n *   | 👩‍❤️‍👩    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n"],"names":["own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","label","listItem","listItemValue","onenterlistitemvalue","listOrdered","list","onenterlistordered","listUnordered","paragraph","reference","onenterreference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","characterEscapeValue","onexitdata","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","onexitcharacterreferencevalue","onexitcodefenced","codeFencedFence","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","labelText","onexitlabeltext","lineEnding","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","resource","onexitresource","onexitsetextheading","setextHeadingLineSequence","onexitsetextheadinglinesequence","setextHeadingText","onexitsetextheadingtext","configure","mdastExtensions","compile","events","tree","type","children","context","stack","tokenStack","resume","setData","getData","listStack","index","length","push","prepareList","pop","handler","call","Object","assign","sliceSerialize","tail","defaultOnError","position","start","point","line","column","offset","end","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","_spread","splice","key","create","and","open","token","this","node","errorHandler","close","onExitError","Error","stringifyPosition","toString","Number","parseInt","lang","meta","replace","identifier","normalizeIdentifier","toLowerCase","title","url","depth","charCodeAt","text","includes","referenceType","string","ancestor","decodeString","fragment","alt","decodeNumericCharacterReference","decodeNamedCharacterReference","ordered","spread","checked","compiler","postprocess","parse","document","write","preprocess","d","combined","extensions","Array","isArray","extension","right","left","definitions","cache","visit","id","clean","String","toUpperCase","defaultStringLength","markdownTable","table","settings","align","concat","stringLength","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","row","sizes","columnIndex","cell","alignDelimiters","size","toAlignment","code","before","after","Math","max","repeat","lines","delimiterStart","padding","delimiterEnd","join","codePointAt","isPlainObject","prototype","getPrototypeOf","Symbol","toStringTag","iterator","longestStreak","substring","source","indexOf","expected","count","TypeError"],"sourceRoot":""}
{"version":3,"file":"static/js/vendor-refractor-d0c4690c.09fcaf4e9c.chunk.v1_9_0.js","mappings":"wIAKA,SAASA,EAAIC,IACV,SAAWA,GAGV,IADA,IAAIC,EAAgB,8CAA8CC,OACzDC,EAAI,EAAGA,EAAI,EAAGA,IACrBF,EAAgBA,EAAcG,QAAQ,WAAW,WAC/C,OAAOH,CACT,IAEFA,EAAgBA,EAAcG,QAAQ,UAAW,MACjDJ,EAAMK,UAAUN,IAAM,CACpBO,QAASC,OAAON,GAChBO,OAAQ,CACNC,QAAS,sBACTC,QAAQ,GAEVC,UAAW,CACT,CACEF,QAASF,OACP,6DAA6DL,OAAOE,QAClE,cACA,WACE,OAAOH,CACT,KAGJS,QAAQ,EACRE,MAAO,YACPC,OAAQ,CACNP,QAASC,OAAON,GAChBO,OAAQ,CACNC,QAAS,sBACTC,QAAQ,GAEVI,SAAU,IACVC,YAAa,mBAGjB,CACEN,QACE,wFACFG,MAAO,cAGXI,QACE,0/DACFC,OACE,6GACFC,MAAO,CACLT,QAAS,kBACTG,MAAO,eAETE,SACE,8FACFC,YAAa,8CAEhB,CAvDA,CAuDEf,EACL,CA5DAmB,EAAOC,QAAUrB,EACjBA,EAAIsB,YAAc,MAClBtB,EAAIuB,QAAU,E,kBCHd,IAAIC,EAAaC,EAAQ,OAIzB,SAASC,EAAIzB,GACXA,EAAM0B,SAASH,GACd,SAAWvB,GACV,IAAIgB,EACF,osBACEW,EAAU,uCAAuCzB,OAAOE,QAC1D,cACA,WACE,OAAOY,EAAQd,MACjB,IAEFF,EAAMK,UAAUoB,IAAMzB,EAAMK,UAAUuB,OAAO,IAAK,CAChD,aAAc,CACZ,CACEnB,QAASF,OACP,gEAAgEL,OAAOE,QACrE,cACA,WACE,OAAOY,EAAQd,MACjB,KAGJ2B,YAAY,GAKd,iCAEA,oCAEA,kEAEFb,QAASA,EACTC,OAAQ,CACNR,QACE,iJACFC,QAAQ,GAEVI,SACE,yHACFgB,QAAS,uBAEX9B,EAAMK,UAAU0B,aAAa,MAAO,SAAU,CAC5CZ,OAAQ,CAENV,QAASF,OACP,2BAA2BL,OACzB,MACA,mDAAmDA,OACnD,IACA,kDAAkDA,OAAOE,QACvD,eACA,WACE,OAAOuB,CACT,IAEF,KAEJE,YAAY,EACZnB,QAAQ,EACRG,OAAQ,CACNL,OAAQ,eACRM,SAAU,IACVC,YAAa,OAGjB,aAAc,CACZN,QAAS,oCACTG,MAAO,SACPF,QAAQ,KAGZV,EAAMK,UAAU0B,aAAa,MAAO,UAAW,CAC7C,mBAAoB,CAClBtB,QAAS,8DACTI,OAAQ,CACNmB,SAAU,OACVC,QAAS,CACPxB,QAAS,WACTG,MAAO,aACPC,OAAQb,EAAMK,UAAUoB,SAKhCzB,EAAMK,UAAU0B,aAAa,MAAO,WAAY,CAC9C,eAAgB,CACdtB,QAAS,KACTG,MAAO,iBAGXZ,EAAMK,UAAU0B,aAAa,MAAO,aAAc,CAGhD,cAAe,CACbtB,QACE,6EACFoB,YAAY,EACZnB,QAAQ,EACRG,OAAQb,EAAMK,UAAUuB,OAAO,MAAO,CAAC,MAG3C5B,EAAMK,UAAU0B,aACd,SACA,eACA,CAEE,aAAc,2BAEhB/B,EAAMK,UAAUoB,IAAI,eAEvB,CA9GA,CA8GEzB,EACL,CApHAmB,EAAOC,QAAUK,EACjBA,EAAIJ,YAAc,MAClBI,EAAIH,QAAU,E","sources":["../node_modules/refractor/lang/coq.js","../node_modules/refractor/lang/cpp.js"],"sourcesContent":["'use strict'\n\nmodule.exports = coq\ncoq.displayName = 'coq'\ncoq.aliases = []\nfunction coq(Prism) {\n  ;(function (Prism) {\n    // https://github.com/coq/coq\n    var commentSource = /\\(\\*(?:[^(*]|\\((?!\\*)|\\*(?!\\))|<self>)*\\*\\)/.source\n    for (var i = 0; i < 2; i++) {\n      commentSource = commentSource.replace(/<self>/g, function () {\n        return commentSource\n      })\n    }\n    commentSource = commentSource.replace(/<self>/g, '[]')\n    Prism.languages.coq = {\n      comment: RegExp(commentSource),\n      string: {\n        pattern: /\"(?:[^\"]|\"\")*\"(?!\")/,\n        greedy: true\n      },\n      attribute: [\n        {\n          pattern: RegExp(\n            /#\\[(?:[^\\[\\](\"]|\"(?:[^\"]|\"\")*\"(?!\")|\\((?!\\*)|<comment>)*\\]/.source.replace(\n              /<comment>/g,\n              function () {\n                return commentSource\n              }\n            )\n          ),\n          greedy: true,\n          alias: 'attr-name',\n          inside: {\n            comment: RegExp(commentSource),\n            string: {\n              pattern: /\"(?:[^\"]|\"\")*\"(?!\")/,\n              greedy: true\n            },\n            operator: /=/,\n            punctuation: /^#\\[|\\]$|[,()]/\n          }\n        },\n        {\n          pattern:\n            /\\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\\b/,\n          alias: 'attr-name'\n        }\n      ],\n      keyword:\n        /\\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\\b/,\n      number:\n        /\\b(?:0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]+)?(?:p[+-]?\\d[\\d_]*)?|\\d[\\d_]*(?:\\.[\\d_]+)?(?:e[+-]?\\d[\\d_]*)?)\\b/i,\n      punct: {\n        pattern: /@\\{|\\{\\||\\[=|:>/,\n        alias: 'punctuation'\n      },\n      operator:\n        /\\/\\\\|\\\\\\/|\\.{2,3}|:{1,2}=|\\*\\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\\|[-|]?|[-!%&*+/<=>?@^~']/,\n      punctuation: /\\.\\(|`\\(|@\\{|`\\{|\\{\\||\\[=|:>|[:.,;(){}\\[\\]]/\n    }\n  })(Prism)\n}\n","'use strict'\nvar refractorC = require('./c.js')\nmodule.exports = cpp\ncpp.displayName = 'cpp'\ncpp.aliases = []\nfunction cpp(Prism) {\n  Prism.register(refractorC)\n  ;(function (Prism) {\n    var keyword =\n      /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(\n      /<keyword>/g,\n      function () {\n        return keyword.source\n      }\n    )\n    Prism.languages.cpp = Prism.languages.extend('c', {\n      'class-name': [\n        {\n          pattern: RegExp(\n            /(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(\n              /<keyword>/g,\n              function () {\n                return keyword.source\n              }\n            )\n          ),\n          lookbehind: true\n        }, // This is intended to capture the class name of method implementations like:\n        //   void foo::bar() const {}\n        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n        // it starts with an uppercase letter. This approximation should give decent results.\n        /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n        //   Foo::~Foo() {}\n        /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n        // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n        /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n      ],\n      keyword: keyword,\n      number: {\n        pattern:\n          /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n        greedy: true\n      },\n      operator:\n        />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n      boolean: /\\b(?:false|true)\\b/\n    })\n    Prism.languages.insertBefore('cpp', 'string', {\n      module: {\n        // https://en.cppreference.com/w/cpp/language/modules\n        pattern: RegExp(\n          /(\\b(?:import|module)\\s+)/.source +\n            '(?:' + // header-name\n            /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n            '|' + // module name or partition or both\n            /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(\n              /<mod-name>/g,\n              function () {\n                return modName\n              }\n            ) +\n            ')'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          string: /^[<\"][\\s\\S]+/,\n          operator: /:/,\n          punctuation: /\\./\n        }\n      },\n      'raw-string': {\n        pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n        alias: 'string',\n        greedy: true\n      }\n    })\n    Prism.languages.insertBefore('cpp', 'keyword', {\n      'generic-function': {\n        pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n        inside: {\n          function: /^\\w+/,\n          generic: {\n            pattern: /<[\\s\\S]+/,\n            alias: 'class-name',\n            inside: Prism.languages.cpp\n          }\n        }\n      }\n    })\n    Prism.languages.insertBefore('cpp', 'operator', {\n      'double-colon': {\n        pattern: /::/,\n        alias: 'punctuation'\n      }\n    })\n    Prism.languages.insertBefore('cpp', 'class-name', {\n      // the base clause is an optional list of parent classes\n      // https://en.cppreference.com/w/cpp/language/class\n      'base-clause': {\n        pattern:\n          /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n        lookbehind: true,\n        greedy: true,\n        inside: Prism.languages.extend('cpp', {})\n      }\n    })\n    Prism.languages.insertBefore(\n      'inside',\n      'double-colon',\n      {\n        // All untokenized words that are not namespaces should be class names\n        'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n      },\n      Prism.languages.cpp['base-clause']\n    )\n  })(Prism)\n}\n"],"names":["coq","Prism","commentSource","source","i","replace","languages","comment","RegExp","string","pattern","greedy","attribute","alias","inside","operator","punctuation","keyword","number","punct","module","exports","displayName","aliases","refractorC","require","cpp","register","modName","extend","lookbehind","boolean","insertBefore","function","generic"],"sourceRoot":""}
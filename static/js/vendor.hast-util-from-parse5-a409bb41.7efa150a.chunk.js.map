{"version":3,"file":"static/js/vendor.hast-util-from-parse5-a409bb41.7efa150a.chunk.js","mappings":"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","sources":["../node_modules/hast-util-from-parse5/node_modules/hast-util-parse-selector/lib/index.js","../node_modules/hast-util-from-parse5/node_modules/hastscript/lib/create-h.js","../node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","../node_modules/hast-util-from-parse5/node_modules/hastscript/lib/index.js","../node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n","/**\n * @import {Element, Nodes, RootContent, Root} from 'hast'\n * @import {Info, Schema} from 'property-information'\n */\n\n/**\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n */\n\n/**\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n */\n\n/**\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n */\n\n/**\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\n/**\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n */\n\n/**\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n */\n\n/**\n * @typedef {Record<string, PropertyValue | Style>} Properties\n *   Acceptable value for element properties.\n */\n\n/**\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n */\n\n/**\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n */\n\n/**\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n */\n\nimport {parse as parseCommas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as parseSpaces} from 'space-separated-tokens'\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node\n\n    if (selector === null || selector === undefined) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase()\n      const adjusted = adjust ? adjust.get(lower) : undefined\n      node.tagName = adjusted || lower\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value)\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child)\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; that’s the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = parseSpaces(value)\n    } else if (info.commaSeparated) {\n      result = parseCommas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = parseSpaces(parseCommas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value]\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(\n        /** @type {number | string} */ (\n          parsePrimitive(info, info.property, item)\n        )\n      )\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(\n      /** @type {Array<number | string> | number | string} */ (result)\n    )\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child)\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} styles\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = []\n\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '))\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {ReadonlyArray<string>} values\n *   List of properly cased keys.\n * @returns {Map<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map()\n\n  for (const value of values) {\n    result.set(value.toLowerCase(), value)\n  }\n\n  return result\n}\n","/**\n * List of case-sensitive SVG tag names.\n *\n * @type {ReadonlyArray<string>}\n */\nexport const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n","/**\n * @import {ElementData, Element, Nodes, RootContent, Root} from 'hast'\n * @import {DefaultTreeAdapterMap, Token} from 'parse5'\n * @import {Schema} from 'property-information'\n * @import {Point, Position} from 'unist'\n * @import {VFile} from 'vfile'\n * @import {Options} from 'hast-util-from-parse5'\n */\n\n/**\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport {ok as assert} from 'devlop'\nimport {h, s} from 'hastscript'\nimport {find, html, svg} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {DefaultTreeAdapterMap['node']} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {}\n\n  return one(\n    {\n      file: settings.file || undefined,\n      location: false,\n      schema: settings.space === 'svg' ? svg : html,\n      verbose: settings.verbose || false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {DefaultTreeAdapterMap['commentNode']} */ (\n        node\n      )\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference =\n        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */ (\n          node\n        )\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const document = String(state.file)\n        const loc = location(document)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(document.length)\n        // Always defined as we give valid input.\n        assert(start, 'expected `start`')\n        assert(end, 'expected `end`')\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {DefaultTreeAdapterMap['documentType']} */ (\n        node\n      )\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {DefaultTreeAdapterMap['textNode']} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {DefaultTreeAdapterMap['element']} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<DefaultTreeAdapterMap['node']>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<RootContent>} */\n  const results = []\n\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */ (one(state, nodes[index]))\n    results.push(result)\n  }\n\n  return results\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['element']} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const properties = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      properties[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const x = state.schema.space === 'svg' ? s : h\n  const result = x(node.tagName, properties, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {DefaultTreeAdapterMap['template']} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    // Root in, root out.\n    const content = /** @type {Root} */ (one(state, reference.content))\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {DefaultTreeAdapterMap['node']} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {Token.ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const properties = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            properties[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      assert(location.startTag, 'a start tag should exist')\n      const opening = position(location.startTag)\n      const closing = location.endTag ? position(location.endTag) : undefined\n      /** @type {ElementData['position']} */\n      const data = {opening}\n      if (closing) data.closing = closing\n      data.properties = properties\n\n      node.data = {position: data}\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {Token.Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n"],"names":["search","createH","schema","defaultTagName","caseSensitive","adjust","values","result","Map","value","set","toLowerCase","createAdjustMap","undefined","selector","properties","node","_len","arguments","length","children","Array","_key","type","child","unshift","props","previous","tagName","start","lastIndex","match","exec","subvalue","slice","index","id","isArray","className","push","parseSelector","lower","adjusted","get","record","keys","Object","key","list","item","isChild","entries","addProperty","addChild","content","info","find","Number","isNaN","spaceSeparated","parseSpaces","commaSeparated","parseCommas","commaOrSpaceSeparated","join","parsePrimitive","property","styles","style","String","finalResult","concat","nodes","Error","name","number","boolean","overloadedBoolean","normalize","h","html","s","svg","own","hasOwnProperty","proto","prototype","fromParse5","tree","options","settings","one","file","location","space","verbose","state","nodeName","reference","data","patch","quirksMode","mode","all","childNodes","document","loc","toPoint","end","assert","position","namespaceURI","webNamespaces","attrs","attribute","prefix","call","x","pos","sourceCodeLocation","startTag","endTag","element","results","from","to","createLocation","tail","assign","opening","closing","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sourceRoot":""}
{"version":3,"file":"static/js/markdown-62a6a3d0.cb0297f0.chunk.js","mappings":"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","sources":["../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/html-flow.js","../node_modules/react-markdown/node_modules/micromark-core-commonmark/lib/html-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {\n  tokenize: tokenizeBlankLineBefore,\n  partial: true\n}\nconst nonLazyContinuationStart = {\n  tokenize: tokenizeNonLazyContinuationStart,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      marker = 3\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      marker = 2\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      marker = 5\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = 4\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n      return cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === 47\n      const name = buffer.toLowerCase()\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = 1\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = 6\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      marker = 7\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n        ? completeClosingTagAfter(code)\n        : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 47 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n    if (code === 60 && marker === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n    if (code === 62 && marker === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n    if (code === 63 && marker === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    if (code === 93 && marker === 5) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n    if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {\n      effects.exit('htmlFlowData')\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationStart(code)\n    }\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === 62) {\n      const name = buffer.toLowerCase()\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n      return continuation(code)\n    }\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationAfter(code)\n    }\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit('htmlFlow')\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code> | undefined} */\n  let marker\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n  return start\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      index = 0\n      return cdataOpenInside\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n    return nok(code)\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return nok(code)\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return comment\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return comment(code)\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === 62\n      ? end(code)\n      : code === 45\n      ? commentClose(code)\n      : comment(code)\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === value.length ? cdata : cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return cdata\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return declaration\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return instruction\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return tagCloseBetween(code)\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n    return tagOpenBetween(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      marker = undefined\n      return tagOpenAttributeValueQuotedAfter\n    }\n    if (code === null) {\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n    return nok(code)\n  }\n\n  /**\n   * At eol.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineEndingAfter\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          lineEndingAfterPrefix,\n          'linePrefix',\n          self.parser.constructs.disable.null.includes('codeIndented')\n            ? undefined\n            : 4\n        )(code)\n      : lineEndingAfterPrefix(code)\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n}\n"],"names":["htmlFlow","name","tokenize","effects","ok","nok","self","this","marker","closingTag","buffer","index","markerB","code","enter","consume","open","before","declarationOpen","tagCloseStart","interrupt","continuationDeclarationInside","asciiAlpha","String","fromCharCode","tagName","commentOpenInside","cdataOpenInside","value","charCodeAt","continuation","markdownLineEndingOrSpace","slash","toLowerCase","htmlRawNames","includes","htmlBlockNames","basicSelfClosing","parser","lazy","now","line","completeClosingTagAfter","completeAttributeNameBefore","asciiAlphanumeric","markdownSpace","completeEnd","completeAttributeName","completeAttributeNameAfter","completeAttributeValueBefore","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","markdownLineEnding","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","continuationCdataInside","exit","continuationStart","check","blankLineBefore","continuationAfter","nonLazyContinuationStart","continuationStartNonLazy","continuationBefore","continuationRawEndTag","length","resolveTo","events","type","start","splice","concrete","attempt","blankLine","partial","after","htmlText","returnState","instruction","tagOpen","declaration","commentEnd","comment","commentClose","lineEndingBefore","end","cdata","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","undefined","tagOpenAttributeValueQuotedAfter","lineEndingAfter","factorySpace","lineEndingAfterPrefix","constructs","disable","null"],"sourceRoot":""}
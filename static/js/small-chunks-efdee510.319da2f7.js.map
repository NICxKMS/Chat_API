{"version":3,"file":"static/js/small-chunks-efdee510.319da2f7.js","mappings":"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","sources":["../node_modules/hast-util-parse-selector/index.js","../node_modules/hast-util-whitespace/index.js","../node_modules/html-void-elements/index.js","../node_modules/hast-util-is-element/lib/index.js","../node_modules/hast-util-to-parse5/lib/index.js","../node_modules/idb/build/wrap-idb-value.js","../node_modules/idb/build/index.js","../node_modules/inline-style-parser/index.js","../node_modules/hast-util-from-html-isomorphic/lib/browser.js"],"sourcesContent":["'use strict'\n\nmodule.exports = parse\n\nvar search = /[#.]/g\n\n// Create a hast element from a simple CSS selector.\nfunction parse(selector, defaultTagName) {\n  var value = selector || ''\n  var name = defaultTagName || 'div'\n  var props = {}\n  var start = 0\n  var subvalue\n  var previous\n  var match\n\n  while (start < value.length) {\n    search.lastIndex = start\n    match = search.exec(value)\n    subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        name = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (props.className) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {type: 'element', tagName: name, properties: props, children: []}\n}\n","/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * List of HTML void tag names.\n *\n * @type {Array<string>}\n */\nexport const htmlVoidElements = [\n  'area',\n  'base',\n  'basefont',\n  'bgsound',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'frame',\n  'hr',\n  'image',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parents} Parents\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is an element.\n * @param {unknown} this\n *   Context object (`this`) to call `test` with\n * @param {unknown} [element]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | null | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n *\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary element.\n *\n *   * when `string`, checks that the element has that tag name\n *   * when `function`, see `TestFunction`\n *   * when `Array`, checks if one of the subtests pass\n *\n * @callback TestFunction\n *   Check if an element passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Element} element\n *   An element.\n * @param {number | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean | undefined | void}\n *   Whether this element passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `element` is an `Element` and whether it passes the given test.\n *\n * @param element\n *   Thing to check, typically `element`.\n * @param test\n *   Check for a specific element.\n * @param index\n *   Position of `element` in its parent.\n * @param parent\n *   Parent of `element`.\n * @param context\n *   Context object (`this`) to call `test` with.\n * @returns\n *   Whether `element` is an `Element` and passes a test.\n * @throws\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\n *   thrown when `element` is not a node or not an element.\n */\nexport const isElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((element?: null | undefined) => false) &\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [element]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parents | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (element, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== null &&\n        index !== undefined &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite `index`')\n      }\n\n      if (\n        parent !== null &&\n        parent !== undefined &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected valid `parent`')\n      }\n\n      if (\n        (index === null || index === undefined) !==\n        (parent === null || parent === undefined)\n      ) {\n        throw new Error('Expected both `index` and `parent`')\n      }\n\n      return looksLikeAnElement(element)\n        ? check.call(context, element, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate a check from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * an `element`, `index`, and `parent`.\n *\n * @param test\n *   A test for a specific element.\n * @returns\n *   A check.\n */\nexport const convertElement =\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      // Assume array.\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as `test`')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction tagNameFactory(check) {\n  return castFactory(tagName)\n\n  /**\n   * @param {Element} element\n   * @returns {boolean}\n   */\n  function tagName(element) {\n    return element.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeAnElement(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} element\n * @returns {element is Element}\n */\nfunction element(element) {\n  return Boolean(\n    element &&\n      typeof element === 'object' &&\n      'type' in element &&\n      element.type === 'element' &&\n      'tagName' in element &&\n      typeof element.tagName === 'string'\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Element}\n */\nfunction looksLikeAnElement(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    'tagName' in value\n  )\n}\n","/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap['document']} Parse5Document\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentFragment']} Parse5Fragment\n * @typedef {import('parse5').DefaultTreeAdapterMap['element']} Parse5Element\n * @typedef {import('parse5').DefaultTreeAdapterMap['node']} Parse5Nodes\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentType']} Parse5Doctype\n * @typedef {import('parse5').DefaultTreeAdapterMap['commentNode']} Parse5Comment\n * @typedef {import('parse5').DefaultTreeAdapterMap['textNode']} Parse5Text\n * @typedef {import('parse5').DefaultTreeAdapterMap['parentNode']} Parse5Parent\n * @typedef {import('parse5').Token.Attribute} Parse5Attribute\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n *\n * @typedef {Exclude<Parse5Nodes, Parse5Document | Parse5Fragment>} Parse5Content\n *\n * @typedef {'html' | 'svg'} Space\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {find, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\nconst own = {}.hasOwnProperty\n\nconst one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a hast tree to a `parse5` AST.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Parse5Nodes}\n *   `parse5` node.\n */\nexport function toParse5(tree, options) {\n  const settings = options || emptyOptions\n  const space = settings.space\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Document}\n *   Parse5 node.\n */\nfunction root(node, schema) {\n  /** @type {Parse5Document} */\n  const result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Fragment}\n *   Parse5 node.\n */\nfunction fragment(node, schema) {\n  /** @type {Parse5Fragment} */\n  const result = {nodeName: '#document-fragment', childNodes: []}\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Doctype} node\n *   Node (hast) to transform.\n * @returns {Parse5Doctype}\n *   Parse5 node.\n */\nfunction doctype(node) {\n  /** @type {Parse5Doctype} */\n  const result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: null\n  }\n\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Text} node\n *   Node (hast) to transform.\n * @returns {Parse5Text}\n *   Parse5 node.\n */\nfunction text(node) {\n  /** @type {Parse5Text} */\n  const result = {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: null\n  }\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Comment} node\n *   Node (hast) to transform.\n * @returns {Parse5Comment}\n *   Parse5 node.\n */\nfunction comment(node) {\n  /** @type {Parse5Comment} */\n  const result = {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: null\n  }\n\n  patch(node, result)\n\n  return result\n}\n\n/**\n * @param {Element} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Element}\n *   Parse5 node.\n */\nfunction element(node, schema) {\n  const parentSchema = schema\n  let currentSchema = parentSchema\n\n  if (\n    node.type === 'element' &&\n    node.tagName.toLowerCase() === 'svg' &&\n    parentSchema.space === 'html'\n  ) {\n    currentSchema = svg\n  }\n\n  /** @type {Array<Parse5Attribute>} */\n  const attrs = []\n  /** @type {string} */\n  let prop\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(\n          currentSchema,\n          prop,\n          node.properties[prop]\n        )\n\n        if (result) {\n          attrs.push(result)\n        }\n      }\n    }\n  }\n\n  const space = currentSchema.space\n  // `html` and `svg` both have a space.\n  assert(space)\n\n  /** @type {Parse5Element} */\n  const result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs,\n    // @ts-expect-error: `parse5` types are wrong.\n    namespaceURI: webNamespaces[space],\n    childNodes: [],\n    parentNode: null\n  }\n  result.childNodes = all(node.children, result, currentSchema)\n  patch(node, result)\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema)\n  }\n\n  return result\n}\n\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Parse5Attribute | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(schema, prop, value) {\n  const info = find(schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === false ||\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (!value && info.boolean)\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  /** @type {Parse5Attribute} */\n  const attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  }\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    const index = attribute.name.indexOf(':')\n\n    if (index < 0) {\n      attribute.prefix = ''\n    } else {\n      attribute.name = attribute.name.slice(index + 1)\n      attribute.prefix = info.attribute.slice(0, index)\n    }\n\n    attribute.namespace = webNamespaces[info.space]\n  }\n\n  return attribute\n}\n\n/**\n * Transform all hast nodes.\n *\n * @param {Array<RootContent>} children\n *   List of children.\n * @param {Parse5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<Parse5Content>}\n *   Transformed children.\n */\nfunction all(children, parentNode, schema) {\n  let index = -1\n  /** @type {Array<Parse5Content>} */\n  const results = []\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {Parse5Content} */\n      const child = one(children[index], schema)\n\n      child.parentNode = parentNode\n\n      results.push(child)\n    }\n  }\n\n  return results\n}\n\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Nodes} from\n *   hast node.\n * @param {Parse5Nodes} to\n *   `parse5` node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const position = from.position\n\n  if (position && position.start && position.end) {\n    assert(typeof position.start.offset === 'number')\n    assert(typeof position.end.offset === 'number')\n\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    }\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n","/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\n */\n\nimport {fromDom} from 'hast-util-from-dom'\n\nconst parser = new DOMParser()\n\n/** @type {FromHtmlIsomorphic} */\nexport function fromHtmlIsomorphic(value, options) {\n  const node = options?.fragment\n    ? parseFragment(value)\n    : parser.parseFromString(value, 'text/html')\n\n  return /** @type {Root} */ (fromDom(node))\n}\n\n/**\n * Parse as a fragment.\n *\n * @param {string} value\n * @returns {DocumentFragment}\n */\nfunction parseFragment(value) {\n  const template = document.createElement('template')\n  template.innerHTML = value\n  return template.content\n}\n"],"names":["module","exports","selector","defaultTagName","subvalue","previous","match","value","name","props","start","length","search","lastIndex","exec","slice","index","id","className","push","type","tagName","properties","children","whitespace","thing","replace","htmlVoidElements","convertElement","test","element","check","castFactory","tagNameFactory","tests","checks","any","_len","arguments","parameters","Array","_key","apply","this","anyFactory","Error","testFunction","parent","Boolean","looksLikeAnElement","call","undefined","emptyOptions","own","hasOwnProperty","one","zwitch","handlers","root","node","schema","result","nodeName","mode","data","quirksMode","childNodes","all","patch","parentSchema","currentSchema","toLowerCase","space","svg","attrs","prop","createProperty","assert","namespaceURI","webNamespaces","parentNode","content","fragment","text","comment","doctype","publicId","systemId","toParse5","tree","options","html","info","find","Number","isNaN","boolean","isArray","commaSeparated","commas","spaces","attribute","String","indexOf","prefix","namespace","results","child","from","to","position","end","offset","sourceCodeLocation","startLine","line","startCol","column","startOffset","endLine","endCol","endOffset","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","set","has","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","_len2","args","_key2","unwrap","_len3","_key3","storeNames","tx","sort","transformCachableValue","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","then","catch","promisifyRequest","newValue","openDB","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","method","async","storeName","store","shift","oldTraps","callback","COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","EMPTY_STRING","trim","str","style","TypeError","lineno","updatePosition","lines","i","lastIndexOf","Position","source","errorsList","msg","err","reason","filename","silent","re","m","comments","rules","pos","charAt","declaration","val","ret","property","decl","decls","declarations","parser","DOMParser","fromHtmlIsomorphic","template","document","createElement","innerHTML","parseFragment","parseFromString","fromDom"],"sourceRoot":""}
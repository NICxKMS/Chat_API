{"version":3,"file":"static/js/main-52f0199e.3f4519fa.js","mappings":"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","sources":["contexts/AuthContext.js","contexts/ChatStatusContext.js","contexts/ContextManager.js","contexts/ChatHistoryContext.js","components/common/Spinner/index.js","contexts/ApiContext.js","contexts/ChatControlContext.js","contexts/ChatStateContext.js"],"sourcesContent":["import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n// Firebase is dynamically imported to avoid blocking\n\nconst AuthContext = createContext();\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\nexport const AuthProvider = ({ children }) => {\n  const [currentUser, setCurrentUser] = useState(null);\n  const [idToken, setIdToken] = useState(null);\n  const [loading, setLoading] = useState(false); // Changed to false initially - we're proceeding anonymously\n  const [error, setError] = useState(null);\n  const [isLoggingIn, setIsLoggingIn] = useState(false); // State to trigger login UI\n  const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);\n\n  const login = useCallback(async () => {\n    console.log(\"Login button clicked, setting isLoggingIn to true.\");\n    setIsLoggingIn(true);\n  }, [setIsLoggingIn]);\n\n  const logout = useCallback(async () => {\n    if (!isFirebaseInitialized) {\n      console.log(\"Firebase not initialized yet, cannot logout.\");\n      return;\n    }\n    const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n    const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n    const auth = getFirebaseAuth();\n    if (!auth) {\n      setError(\"Firebase not initialized.\");\n      return;\n    }\n    try {\n      await firebaseSignOut(auth);\n      console.log(\"Sign out successful.\");\n    } catch (err) {\n      console.error(\"Logout failed:\", err);\n      setError(err.message || 'Failed to logout.');\n    }\n  }, [isFirebaseInitialized, setError]);\n\n  // Effect to listen for Firebase auth state changes\n  useEffect(() => {\n    let unsubscribe = null;\n\n    // Listen for the 'firebaseInitialized' event from App.js\n    const handleFirebaseInit = () => {\n      console.log(\"Received Firebase initialized event\");\n      setIsFirebaseInitialized(true);\n      initializeAuthListener();\n    };\n\n    // Function to initialize auth listener\n    const initializeAuthListener = async () => {\n      setLoading(true);\n      // Dynamically import Firebase auth\n      const { getFirebaseAuth } = await import(/* webpackChunkName: \"firebase-config\" */ '../firebaseConfig');\n      const { onAuthStateChanged: firebaseOnAuthStateChanged } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n      \n      const auth = getFirebaseAuth();\n      if (!auth) {\n        console.warn(\"Auth service not available for onAuthStateChanged listener.\");\n        setLoading(false);\n        return;\n      }\n      \n      console.log(\"Setting up Firebase onAuthStateChanged listener.\");\n      unsubscribe = firebaseOnAuthStateChanged(auth, async (user) => {\n        setCurrentUser(user);\n        if (user) {\n          try {\n            // Force refresh is false by default, gets cached token if available\n            const token = await user.getIdToken();\n            setIdToken(token);\n            try { localStorage.setItem('idToken', token); } catch (e) { console.warn('Failed to cache idToken', e); }\n            setError(null); // Clear previous errors on successful login\n            setIsLoggingIn(false); // Ensure login UI closes if open\n            console.log(\"User signed in, token obtained.\");\n          } catch (err) {\n            console.error(\"Failed to get ID token:\", err);\n            setError(\"Failed to get authentication token.\");\n            setIdToken(null);\n            // Optionally sign out the user if token fetch fails critically\n            const { signOut: firebaseSignOut } = await import(/* webpackChunkName: \"firebase-auth\" */ 'firebase/auth');\n            await firebaseSignOut(auth);\n          }\n        } else {\n          // User is signed out\n          setIdToken(null);\n          try { localStorage.removeItem('idToken'); } catch (e) { console.warn('Failed to remove cached idToken', e); }\n          setIsLoggingIn(false); // Ensure login UI closes if open\n          console.log(\"User signed out.\");\n        }\n        setLoading(false); // Auth state determined\n      });\n    };\n\n    // Define a custom event for Firebase initialization\n    window.addEventListener('firebaseInitialized', handleFirebaseInit);\n\n    // Cleanup listener on component unmount\n    return () => {\n      window.removeEventListener('firebaseInitialized', handleFirebaseInit);\n      if (typeof unsubscribe === 'function') {\n      console.log(\"Cleaning up Firebase onAuthStateChanged listener.\");\n        unsubscribe();\n      }\n    };\n  }, []);\n\n  const value = useMemo(() => ({\n    currentUser,\n    idToken,\n    loading,\n    error,\n    login,\n    logout,\n    isAuthenticated: !!currentUser && !!idToken,\n    isLoggingIn,\n    setIsLoggingIn,\n    isFirebaseInitialized\n  }), [currentUser, idToken, loading, error, login, logout, isLoggingIn, setIsLoggingIn, isFirebaseInitialized]);\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}; ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create chat status context\nconst ChatStatusContext = createContext();\n\n// Hook to use chat status context\nexport const useChatStatus = () => {\n  const context = useContext(ChatStatusContext);\n  if (context === undefined) {\n    throw new Error('useChatStatus must be used within a ChatStatusProvider');\n  }\n  return context;\n};\n\n// Provider component for chat status\nexport const ChatStatusProvider = ({ children }) => {\n  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false);\n  const [error, setError] = useState(null);\n\n  const value = useMemo(() => ({\n    isWaitingForResponse,\n    setIsWaitingForResponse,\n    error,\n    setError,\n  }), [isWaitingForResponse, error]);\n\n  return (\n    <ChatStatusContext.Provider value={value}>\n      {children}\n    </ChatStatusContext.Provider>\n  );\n}; ","import { createContext, useContext, useMemo, useEffect } from 'react';\nimport { ThemeProvider } from './ThemeContext';\nimport { ApiProvider } from './ApiContext';\nimport { ModelProvider } from './ModelContext';\nimport { SettingsProvider } from './SettingsContext';\nimport { ChatStatusProvider } from './ChatStatusContext';\nimport { ChatHistoryProvider } from './ChatHistoryContext';\nimport { PerformanceMetricsProvider } from './PerformanceMetricsContext';\nimport { StreamingEventsProvider } from './StreamingEventsContext';\nimport { ChatStateProvider } from './ChatStateContext';\nimport { ChatControlProvider } from './ChatControlContext';\n\n// Create a context for managing initialization state\nconst InitializationContext = createContext(null);\n\nexport const useInitialization = () => {\n  const context = useContext(InitializationContext);\n  if (!context) {\n    throw new Error('useInitialization must be used within an InitializationProvider');\n  }\n  return context;\n};\n\n/**\n * ContextManager component that handles all context providers\n * and their initialization states\n */\nexport const ContextManager = ({ children }) => {\n  // Memoize the initialization state to prevent unnecessary re-renders\n  const initializationState = useMemo(() => ({\n    isInitialized: false,\n    setInitialized: (value) => {\n      initializationState.isInitialized = value;\n    }\n  }), []);\n  // Mark as initialized once on mount\n  useEffect(() => {\n    initializationState.setInitialized(true);\n  }, [initializationState]);\n\n  return (\n    <InitializationContext.Provider value={initializationState}>\n      <ThemeProvider>\n        <ApiProvider>\n          <ModelProvider>\n            <SettingsProvider>\n              <ChatStatusProvider>\n                <ChatHistoryProvider>\n                  <PerformanceMetricsProvider>\n                    <StreamingEventsProvider>\n                      <ChatStateProvider>\n                        <ChatControlProvider>\n                          {children}\n                        </ChatControlProvider>\n                      </ChatStateProvider>\n                    </StreamingEventsProvider>\n                  </PerformanceMetricsProvider>\n                </ChatHistoryProvider>\n              </ChatStatusProvider>\n            </SettingsProvider>\n          </ModelProvider>\n        </ApiProvider>\n      </ThemeProvider>\n    </InitializationContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useRef, useEffect, useCallback, useMemo } from 'react';\n\n// Create chat history context\nconst ChatHistoryContext = createContext();\n\n// Hook to use chat history context\nexport const useChatHistory = () => {\n  const context = useContext(ChatHistoryContext);\n  if (context === undefined) {\n    throw new Error('useChatHistory must be used within a ChatHistoryProvider');\n  }\n  return context;\n};\n\n// Provider component for chat history\nexport const ChatHistoryProvider = ({ children }) => {\n  const [chatHistory, setChatHistory] = useState([]);\n  const chatHistoryRef = useRef([]);\n\n  // Keep ref in sync with state\n  useEffect(() => {\n    chatHistoryRef.current = chatHistory;\n  }, [chatHistory]);\n\n  // Add message, stable callback\n  const addMessageToHistory = useCallback((role, content, metrics) => {\n    const message = { role, content, timestamp: Date.now(), ...(metrics && { metrics }) };\n    setChatHistory(prev => [...prev, message]);\n    return message;\n  }, [setChatHistory]);\n\n  // Function to update content of the most recent assistant message (avoiding user replacements)\n  const updateChatWithContent = useCallback((content) => {\n    setChatHistory(prev => {\n      const lastIndex = prev.length - 1;\n      if (lastIndex < 0) return prev;\n      const lastMsg = prev[lastIndex];\n      // No-op if not assistant or same content\n      if (lastMsg.role !== 'assistant' || lastMsg.content === content) {\n        return prev;\n      }\n      // Otherwise clone and update\n      const newHistory = [...prev];\n      newHistory[lastIndex] = { ...lastMsg, content };\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Memoize context value to avoid re-renders\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    updateChatWithContent\n  }), [chatHistory, chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent]);\n\n  return (\n    <ChatHistoryContext.Provider value={value}>\n      {children}\n    </ChatHistoryContext.Provider>\n  );\n}; ","import React from 'react';\nimport styles from './Spinner.module.css';\n\n/**\n * Loading spinner component with multiple sizes\n * @param {Object} props - Component props\n * @param {string} [props.size='medium'] - Size of spinner (small, medium, large)\n * @param {string} [props.color] - Optional custom color\n * @returns {JSX.Element} - Rendered spinner\n */\nconst Spinner = ({ size = 'medium', color }) => {\n  const sizeClass = styles[size] || styles.medium;\n  \n  const spinnerStyle = color ? { borderTopColor: color } : {};\n  \n  return (\n    <div className={`${styles.spinnerContainer} ${sizeClass}`}>\n      <div \n        className={styles.spinner} \n        style={spinnerStyle}\n        aria-label=\"Loading\"\n        role=\"status\"\n      />\n    </div>\n  );\n};\n\n// Wrap with React.memo to prevent unnecessary re-renders\nexport default React.memo(Spinner); ","import { createContext, useContext, useState, useMemo } from 'react';\n\n// Create API context\nconst ApiContext = createContext();\n\n// Custom hook for using API context\nexport const useApi = () => {\n  const context = useContext(ApiContext);\n  if (context === undefined) {\n    throw new Error('useApi must be used within an ApiProvider');\n  }\n  return context;\n};\n\n// API provider component\nexport const ApiProvider = ({ children }) => {\n  const [apiUrl] = useState(process.env.REACT_APP_API_URL || 'http://localhost:3000/api'); // Base API URL\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    apiUrl,\n  }), [apiUrl]);\n\n  return (\n    <ApiContext.Provider value={value}>\n      {children}\n    </ApiContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo, useCallback, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { useStreamingEvents } from './StreamingEventsContext';\nimport { fetchWithRetry } from '../utils/network';\n\n// Context for chat actions (controls)\nconst ChatControlContext = createContext();\n\n// Hook to consume chat controls\nexport const useChatControl = () => {\n  const context = useContext(ChatControlContext);\n  if (context === undefined) {\n    throw new Error('useChatControl must be used within a ChatControlProvider');\n  }\n  return context;\n};\n\n// Provider component for chat controls\nexport const ChatControlProvider = ({ children }) => {\n  // Ref to track client-generated request ID for non-streaming\n  const currentRequestIdRef = useRef(null);\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { settings, getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistory, chatHistoryRef, setChatHistory, addMessageToHistory } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, setTokenMetricsForLastMessage } = usePerformanceMetrics();\n  const { streamMessageWithFetch, stopStreaming } = useStreamingEvents();\n\n  // Helpers\n  const formatModelIdentifier = useCallback((model) => {\n    if (!model || !model.provider || !model.id) return null;\n    return `${model.provider}/${model.id}`;\n  }, []);\n\n  const extractTokenCount = useCallback((data, content) => {\n    if (data?.usage?.completion_tokens) return data.usage.completion_tokens;\n    if (data?.usage?.completionTokens) return data.usage.completionTokens;\n    if (data?.tokenUsage?.output) return data.tokenUsage.output;\n    if (data?.tokenUsage?.total) return data.tokenUsage.total;\n    if (data?.usage?.total_tokens) return data.usage.total_tokens;\n    if (data?.usage?.totalTokens) return data.usage.totalTokens;\n    if (data?.raw?.usageMetadata?.candidatesTokenCount) return data.raw.usageMetadata.candidatesTokenCount;\n    return Math.ceil((content.split(/\\s+/).length) * 1.3);\n  }, []);\n\n  const processChunkResponse = useCallback((data) => {\n    if (!data || typeof data !== 'object') return null;\n    if (data.id && data.model && data.usage && typeof data.usage === 'object') {\n      return {\n        tokenInfo: {\n          promptTokens: data.usage.promptTokens,\n          completionTokens: data.usage.completionTokens,\n          totalTokens: data.usage.totalTokens\n        },\n        finishReason: data.finishReason,\n        model: data.model,\n        provider: data.provider\n      };\n    }\n    return null;\n  }, []);\n\n  const extractTokenInfo = useCallback((data) => {\n    if (!data) return null;\n    if (data.usage && typeof data.usage === 'object') {\n      if ('promptTokens' in data.usage && 'completionTokens' in data.usage && 'totalTokens' in data.usage) {\n        return {\n          promptTokens: data.usage.promptTokens,\n          completionTokens: data.usage.completionTokens,\n          totalTokens: data.usage.totalTokens\n        };\n      }\n      if ('prompt_tokens' in data.usage && 'completion_tokens' in data.usage && 'total_tokens' in data.usage) {\n        return {\n          promptTokens: data.usage.prompt_tokens,\n          completionTokens: data.usage.completion_tokens,\n          totalTokens: data.usage.total_tokens\n        };\n      }\n    }\n    if (data.tokenUsage) {\n      return {\n        promptTokens: data.tokenUsage.input || data.tokenUsage.prompt,\n        completionTokens: data.tokenUsage.output || data.tokenUsage.completion,\n        totalTokens: data.tokenUsage.total\n      };\n    }\n    if (data.raw?.usageMetadata) {\n      return {\n        promptTokens: data.raw.usageMetadata.promptTokenCount,\n        completionTokens: data.raw.usageMetadata.candidatesTokenCount,\n        totalTokens: data.raw.usageMetadata.totalTokenCount\n      };\n    }\n    return null;\n  }, []);\n\n  // Action: sendMessage\n  const sendMessage = useCallback(async (message, editIndex = null) => {\n    // Generate unique client-side requestId\n    const clientRequestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = clientRequestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (settings.streaming) {\n      return streamMessageWithFetch(message, isEditing ? editIndex : null);\n    }\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = formatModelIdentifier(selectedModel);\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        userMessage = { role: 'user', content: message, timestamp: Date.now() };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    const requestStartTime = Date.now();\n    setIsWaitingForResponse(true);\n    setError(null);\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now()-1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = { \n        requestId: clientRequestId,\n        model: modelId, messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      resetPerformanceMetrics();\n      startPerformanceTimer();\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/completions', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        let errMsg = `API error: ${response.status}`;\n        try { const errData = await response.json(); errMsg = errData?.error?.message || errData?.message || errMsg; } catch {};\n        throw new Error(errMsg);\n      }\n      const data = await response.json();\n      const content = data.content || 'No Response returned';\n      const processed = processChunkResponse(data);\n      const tokenInfo = processed?.tokenInfo || extractTokenInfo(data);\n      const finishReason = processed?.finishReason || data.finishReason;\n      const tokenCount = tokenInfo?.completionTokens || extractTokenCount(data, content);\n      if (!tokenInfo || (!tokenInfo.promptTokens && !tokenInfo.completionTokens)) {\n        const testMetrics = { promptTokens: 0, completionTokens: tokenCount, totalTokens: tokenCount, finishReason };\n        addMessageToHistory('assistant', content, testMetrics);\n      } else {\n        const requestEndTime = Date.now();\n        const elapsed = requestEndTime - requestStartTime;\n        const finalMetrics = {\n          startTime: requestStartTime,\n          endTime: requestEndTime,\n          elapsedTime: elapsed,\n          tokenCount,\n          tokensPerSecond: Math.round((tokenCount/(elapsed/1000))*10)/10,\n          isComplete: true,\n          timeToFirstToken: null,\n          promptTokens: tokenInfo.promptTokens,\n          completionTokens: tokenInfo.completionTokens,\n          totalTokens: tokenInfo.totalTokens,\n          finishReason\n        };\n        addMessageToHistory('assistant', content, finalMetrics);\n      }\n      return content;\n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err.message);\n      addMessageToHistory('error', err.message || 'An error occurred');\n      return null;\n    } finally {\n      // Clear the clientRequestId after completion\n      currentRequestIdRef.current = null;\n      setIsWaitingForResponse(false);\n    }\n  }, [\n    apiUrl,\n    selectedModel,\n    settings.streaming,\n    getModelAdjustedSettings,\n    idToken,\n    chatHistoryRef,\n    setChatHistory,\n    addMessageToHistory,\n    streamMessageWithFetch,\n    formatModelIdentifier,\n    extractTokenInfo,\n    extractTokenCount,\n    processChunkResponse,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    setError,\n    setIsWaitingForResponse,\n  ]);\n\n  // Action: stopGeneration\n  const stopGenerationAction = useCallback(async () => {\n    stopStreaming();\n    return true;\n  }, [stopStreaming]);\n\n  // Action: clearChat\n  const clearChatAction = useCallback(() => {\n    setChatHistory([]);\n    resetPerformanceMetrics();\n  }, [setChatHistory, resetPerformanceMetrics]);\n\n  // Action: downloadChatHistory\n  const downloadChatHistoryAction = useCallback(() => {\n    if (chatHistory.length === 0) return;\n    const formatted = chatHistory.map(msg => {\n      const role = msg.role === 'user' ? 'You' : msg.role === 'assistant' ? selectedModel?.name||'Assistant' : msg.role;\n      const content = typeof msg.content === 'string' ? msg.content : '';\n      return `${role}: ${content}\\n`;\n    }).join('\\n');\n    const blob = new Blob([formatted], { type:'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url; a.download=`chat_${new Date().toISOString()}.txt`;\n    document.body.appendChild(a); a.click();\n    setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); },100);\n  }, [chatHistory, selectedModel]);\n\n  // Action: getOrCreateConversation (stub)\n  const getOrCreateConversation = useCallback((conversationId) => {\n    // implement or delegate\n  }, []);\n\n  // Value\n  const value = useMemo(() => ({\n    sendMessage,\n    stopGeneration: stopGenerationAction,\n    addMessageToHistory,\n    clearChat: clearChatAction,\n    downloadChatHistory: downloadChatHistoryAction,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  }), [\n    sendMessage,\n    stopGenerationAction,\n    addMessageToHistory,\n    clearChatAction,\n    downloadChatHistoryAction,\n    getOrCreateConversation,\n    setTokenMetricsForLastMessage\n  ]);\n\n  return (\n    <ChatControlContext.Provider value={value}>\n      {children}\n    </ChatControlContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useMemo } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\n\n// Context for read-only chat state\nconst ChatStateContext = createContext();\n\n// Hook to consume chat state\nexport const useChatState = () => {\n  const context = useContext(ChatStateContext);\n  if (context === undefined) {\n    throw new Error('useChatState must be used within a ChatStateProvider');\n  }\n  return context;\n};\n\n// Provider component for chat state\nexport const ChatStateProvider = ({ children }) => {\n  const { chatHistory, chatHistoryRef } = useChatHistory();\n  const { isWaitingForResponse, error } = useChatStatus();\n\n  const value = useMemo(() => ({\n    chatHistory,\n    chatHistoryRef,\n    isWaitingForResponse,\n    error\n  }), [\n    chatHistory,\n    chatHistoryRef,\n    isWaitingForResponse,\n    error\n  ]);\n\n  return (\n    <ChatStateContext.Provider value={value}>\n      {children}\n    </ChatStateContext.Provider>\n  );\n}; "],"names":["AuthContext","createContext","useAuth","context","useContext","undefined","Error","AuthProvider","_ref","children","currentUser","setCurrentUser","useState","idToken","setIdToken","loading","setLoading","error","setError","isLoggingIn","setIsLoggingIn","isFirebaseInitialized","setIsFirebaseInitialized","login","useCallback","async","logout","getFirebaseAuth","signOut","firebaseSignOut","auth","err","message","useEffect","unsubscribe","handleFirebaseInit","initializeAuthListener","onAuthStateChanged","firebaseOnAuthStateChanged","user","token","getIdToken","localStorage","setItem","e","removeItem","window","addEventListener","removeEventListener","value","useMemo","isAuthenticated","_jsx","Provider","ChatStatusContext","useChatStatus","ChatStatusProvider","isWaitingForResponse","setIsWaitingForResponse","InitializationContext","ContextManager","initializationState","isInitialized","setInitialized","ThemeProvider","ApiProvider","ModelProvider","SettingsProvider","ChatHistoryProvider","PerformanceMetricsProvider","StreamingEventsProvider","ChatStateProvider","ChatControlProvider","ChatHistoryContext","useChatHistory","chatHistory","setChatHistory","chatHistoryRef","useRef","current","addMessageToHistory","role","content","metrics","timestamp","Date","now","prev","updateChatWithContent","lastIndex","length","lastMsg","newHistory","Spinner","size","color","sizeClass","styles","medium","spinnerStyle","borderTopColor","className","spinnerContainer","spinner","style","React","ApiContext","useApi","apiUrl","process","ChatControlContext","useChatControl","currentRequestIdRef","selectedModel","useModel","settings","getModelAdjustedSettings","useSettings","resetPerformanceMetrics","startPerformanceTimer","setTokenMetricsForLastMessage","usePerformanceMetrics","streamMessageWithFetch","stopStreaming","useStreamingEvents","formatModelIdentifier","model","provider","id","extractTokenCount","data","_data$usage","_data$usage2","_data$tokenUsage","_data$tokenUsage2","_data$usage3","_data$usage4","_data$raw","_data$raw$usageMetada","usage","completion_tokens","completionTokens","tokenUsage","output","total","total_tokens","totalTokens","raw","usageMetadata","candidatesTokenCount","Math","ceil","split","processChunkResponse","tokenInfo","promptTokens","finishReason","extractTokenInfo","_data$raw2","prompt_tokens","input","prompt","completion","promptTokenCount","totalTokenCount","sendMessage","editIndex","arguments","clientRequestId","crypto","randomUUID","random","toString","substring","isEditing","Number","isInteger","streaming","modelId","userMessage","truncated","slice","requestStartTime","adjusted","historyForApi","map","_ref2","m","systemPrompt","unshift","push","payload","requestId","messages","temperature","max_tokens","top_p","frequency_penalty","presence_penalty","headers","response","fetchWithRetry","URL","method","body","JSON","stringify","ok","errMsg","status","_errData$error","errData","json","processed","tokenCount","requestEndTime","elapsed","finalMetrics","startTime","endTime","elapsedTime","tokensPerSecond","round","isComplete","timeToFirstToken","stopGenerationAction","clearChatAction","downloadChatHistoryAction","formatted","msg","name","join","blob","Blob","type","url","createObjectURL","a","document","createElement","href","download","toISOString","appendChild","click","setTimeout","removeChild","revokeObjectURL","getOrCreateConversation","conversationId","stopGeneration","clearChat","downloadChatHistory","ChatStateContext","useChatState"],"sourceRoot":""}
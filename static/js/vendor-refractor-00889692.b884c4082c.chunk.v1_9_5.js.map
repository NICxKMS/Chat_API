{"version":3,"file":"static/js/vendor-refractor-00889692.b884c4082c.chunk.v1_9_5.js","mappings":"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","sources":["../node_modules/refractor/lang/markup.js","../node_modules/refractor/lang/matlab.js","../node_modules/refractor/lang/markup-templating.js","../node_modules/refractor/lang/maxscript.js"],"sourcesContent":["'use strict'\n\nmodule.exports = markup\nmarkup.displayName = 'markup'\nmarkup.aliases = ['html', 'mathml', 'svg', 'xml', 'ssml', 'atom', 'rss']\nfunction markup(Prism) {\n  Prism.languages.markup = {\n    comment: {\n      pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n      greedy: true\n    },\n    prolog: {\n      pattern: /<\\?[\\s\\S]+?\\?>/,\n      greedy: true\n    },\n    doctype: {\n      // https://www.w3.org/TR/xml/#NT-doctypedecl\n      pattern:\n        /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n      greedy: true,\n      inside: {\n        'internal-subset': {\n          pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n          lookbehind: true,\n          greedy: true,\n          inside: null // see below\n        },\n        string: {\n          pattern: /\"[^\"]*\"|'[^']*'/,\n          greedy: true\n        },\n        punctuation: /^<!|>$|[[\\]]/,\n        'doctype-tag': /^DOCTYPE/i,\n        name: /[^\\s<>'\"]+/\n      }\n    },\n    cdata: {\n      pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n      greedy: true\n    },\n    tag: {\n      pattern:\n        /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n      greedy: true,\n      inside: {\n        tag: {\n          pattern: /^<\\/?[^\\s>\\/]+/,\n          inside: {\n            punctuation: /^<\\/?/,\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        },\n        'special-attr': [],\n        'attr-value': {\n          pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n          inside: {\n            punctuation: [\n              {\n                pattern: /^=/,\n                alias: 'attr-equals'\n              },\n              /\"|'/\n            ]\n          }\n        },\n        punctuation: /\\/?>/,\n        'attr-name': {\n          pattern: /[^\\s>\\/]+/,\n          inside: {\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        }\n      }\n    },\n    entity: [\n      {\n        pattern: /&[\\da-z]{1,8};/i,\n        alias: 'named-entity'\n      },\n      /&#x?[\\da-f]{1,8};/i\n    ]\n  }\n  Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n    Prism.languages.markup['entity']\n  Prism.languages.markup['doctype'].inside['internal-subset'].inside =\n    Prism.languages.markup // Plugin to make entity title show the real entity, idea by Roman Komarov\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type === 'entity') {\n      env.attributes['title'] = env.content.value.replace(/&amp;/, '&')\n    }\n  })\n  Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n    /**\n     * Adds an inlined language to markup.\n     *\n     * An example of an inlined language is CSS with `<style>` tags.\n     *\n     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addInlined('style', 'css');\n     */\n    value: function addInlined(tagName, lang) {\n      var includedCdataInside = {}\n      includedCdataInside['language-' + lang] = {\n        pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n        lookbehind: true,\n        inside: Prism.languages[lang]\n      }\n      includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i\n      var inside = {\n        'included-cdata': {\n          pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n          inside: includedCdataInside\n        }\n      }\n      inside['language-' + lang] = {\n        pattern: /[\\s\\S]+/,\n        inside: Prism.languages[lang]\n      }\n      var def = {}\n      def[tagName] = {\n        pattern: RegExp(\n          /(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(\n            /__/g,\n            function () {\n              return tagName\n            }\n          ),\n          'i'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: inside\n      }\n      Prism.languages.insertBefore('markup', 'cdata', def)\n    }\n  })\n  Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n    /**\n     * Adds an pattern to highlight languages embedded in HTML attributes.\n     *\n     * An example of an inlined language is CSS with `style` attributes.\n     *\n     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addAttribute('style', 'css');\n     */\n    value: function (attrName, lang) {\n      Prism.languages.markup.tag.inside['special-attr'].push({\n        pattern: RegExp(\n          /(^|[\"'\\s])/.source +\n            '(?:' +\n            attrName +\n            ')' +\n            /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n          'i'\n        ),\n        lookbehind: true,\n        inside: {\n          'attr-name': /^[^\\s=]+/,\n          'attr-value': {\n            pattern: /=[\\s\\S]+/,\n            inside: {\n              value: {\n                pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                lookbehind: true,\n                alias: [lang, 'language-' + lang],\n                inside: Prism.languages[lang]\n              },\n              punctuation: [\n                {\n                  pattern: /^=/,\n                  alias: 'attr-equals'\n                },\n                /\"|'/\n              ]\n            }\n          }\n        }\n      })\n    }\n  })\n  Prism.languages.html = Prism.languages.markup\n  Prism.languages.mathml = Prism.languages.markup\n  Prism.languages.svg = Prism.languages.markup\n  Prism.languages.xml = Prism.languages.extend('markup', {})\n  Prism.languages.ssml = Prism.languages.xml\n  Prism.languages.atom = Prism.languages.xml\n  Prism.languages.rss = Prism.languages.xml\n}\n","'use strict'\n\nmodule.exports = matlab\nmatlab.displayName = 'matlab'\nmatlab.aliases = []\nfunction matlab(Prism) {\n  Prism.languages.matlab = {\n    comment: [/%\\{[\\s\\S]*?\\}%/, /%.+/],\n    string: {\n      pattern: /\\B'(?:''|[^'\\r\\n])*'/,\n      greedy: true\n    },\n    // FIXME We could handle imaginary numbers as a whole\n    number: /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?(?:[ij])?|\\b[ij]\\b/,\n    keyword:\n      /\\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\\b/,\n    function: /\\b(?!\\d)\\w+(?=\\s*\\()/,\n    operator: /\\.?[*^\\/\\\\']|[+\\-:@]|[<>=~]=?|&&?|\\|\\|?/,\n    punctuation: /\\.{3}|[.,;\\[\\](){}!]/\n  }\n}\n","'use strict'\n\nmodule.exports = markupTemplating\nmarkupTemplating.displayName = 'markupTemplating'\nmarkupTemplating.aliases = []\nfunction markupTemplating(Prism) {\n  ;(function (Prism) {\n    /**\n     * Returns the placeholder for the given language id and index.\n     *\n     * @param {string} language\n     * @param {string|number} index\n     * @returns {string}\n     */\n    function getPlaceholder(language, index) {\n      return '___' + language.toUpperCase() + index + '___'\n    }\n    Object.defineProperties((Prism.languages['markup-templating'] = {}), {\n      buildPlaceholders: {\n        /**\n         * Tokenize all inline templating expressions matching `placeholderPattern`.\n         *\n         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n         * `true` will be replaced.\n         *\n         * @param {object} env The environment of the `before-tokenize` hook.\n         * @param {string} language The language id.\n         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n         * @param {(match: string) => boolean} [replaceFilter]\n         */\n        value: function (env, language, placeholderPattern, replaceFilter) {\n          if (env.language !== language) {\n            return\n          }\n          var tokenStack = (env.tokenStack = [])\n          env.code = env.code.replace(placeholderPattern, function (match) {\n            if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n              return match\n            }\n            var i = tokenStack.length\n            var placeholder // Check for existing strings\n            while (\n              env.code.indexOf((placeholder = getPlaceholder(language, i))) !==\n              -1\n            ) {\n              ++i\n            } // Create a sparse array\n            tokenStack[i] = match\n            return placeholder\n          }) // Switch the grammar to markup\n          env.grammar = Prism.languages.markup\n        }\n      },\n      tokenizePlaceholders: {\n        /**\n         * Replace placeholders with proper tokens after tokenizing.\n         *\n         * @param {object} env The environment of the `after-tokenize` hook.\n         * @param {string} language The language id.\n         */\n        value: function (env, language) {\n          if (env.language !== language || !env.tokenStack) {\n            return\n          } // Switch the grammar back\n          env.grammar = Prism.languages[language]\n          var j = 0\n          var keys = Object.keys(env.tokenStack)\n          function walkTokens(tokens) {\n            for (var i = 0; i < tokens.length; i++) {\n              // all placeholders are replaced already\n              if (j >= keys.length) {\n                break\n              }\n              var token = tokens[i]\n              if (\n                typeof token === 'string' ||\n                (token.content && typeof token.content === 'string')\n              ) {\n                var k = keys[j]\n                var t = env.tokenStack[k]\n                var s = typeof token === 'string' ? token : token.content\n                var placeholder = getPlaceholder(language, k)\n                var index = s.indexOf(placeholder)\n                if (index > -1) {\n                  ++j\n                  var before = s.substring(0, index)\n                  var middle = new Prism.Token(\n                    language,\n                    Prism.tokenize(t, env.grammar),\n                    'language-' + language,\n                    t\n                  )\n                  var after = s.substring(index + placeholder.length)\n                  var replacement = []\n                  if (before) {\n                    replacement.push.apply(replacement, walkTokens([before]))\n                  }\n                  replacement.push(middle)\n                  if (after) {\n                    replacement.push.apply(replacement, walkTokens([after]))\n                  }\n                  if (typeof token === 'string') {\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement))\n                  } else {\n                    token.content = replacement\n                  }\n                }\n              } else if (\n                token.content\n                /* && typeof token.content !== 'string' */\n              ) {\n                walkTokens(token.content)\n              }\n            }\n            return tokens\n          }\n          walkTokens(env.tokens)\n        }\n      }\n    })\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = maxscript\nmaxscript.displayName = 'maxscript'\nmaxscript.aliases = []\nfunction maxscript(Prism) {\n  ;(function (Prism) {\n    var keywords =\n      /\\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\\b/i\n    Prism.languages.maxscript = {\n      comment: {\n        pattern: /\\/\\*[\\s\\S]*?(?:\\*\\/|$)|--.*/,\n        greedy: true\n      },\n      string: {\n        pattern: /(^|[^\"\\\\@])(?:\"(?:[^\"\\\\]|\\\\[\\s\\S])*\"|@\"[^\"]*\")/,\n        lookbehind: true,\n        greedy: true\n      },\n      path: {\n        pattern: /\\$(?:[\\w/\\\\.*?]|'[^']*')*/,\n        greedy: true,\n        alias: 'string'\n      },\n      'function-call': {\n        pattern: RegExp(\n          '((?:' + // start of line\n            (/^/.source +\n              '|' + // operators and other language constructs\n              /[;=<>+\\-*/^({\\[]/.source +\n              '|' + // keywords as part of statements\n              /\\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\\b/\n                .source) +\n            ')[ \\t]*)' +\n            '(?!' +\n            keywords.source +\n            ')' +\n            /[a-z_]\\w*\\b/.source +\n            '(?=[ \\t]*(?:' + // variable\n            ('(?!' +\n              keywords.source +\n              ')' +\n              /[a-z_]/.source +\n              '|' + // number\n              /\\d|-\\.?\\d/.source +\n              '|' + // other expressions or literals\n              /[({'\"$@#?]/.source) +\n            '))',\n          'im'\n        ),\n        lookbehind: true,\n        greedy: true,\n        alias: 'function'\n      },\n      'function-definition': {\n        pattern: /(\\b(?:fn|function)\\s+)\\w+\\b/i,\n        lookbehind: true,\n        alias: 'function'\n      },\n      argument: {\n        pattern: /\\b[a-z_]\\w*(?=:)/i,\n        alias: 'attr-name'\n      },\n      keyword: keywords,\n      boolean: /\\b(?:false|true)\\b/,\n      time: {\n        pattern:\n          /(^|[^\\w.])(?:(?:(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eEdD][+-]\\d+|[LP])?[msft])+|\\d+:\\d+(?:\\.\\d*)?)(?![\\w.:])/,\n        lookbehind: true,\n        alias: 'number'\n      },\n      number: [\n        {\n          pattern:\n            /(^|[^\\w.])(?:(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eEdD][+-]\\d+|[LP])?|0x[a-fA-F0-9]+)(?![\\w.:])/,\n          lookbehind: true\n        },\n        /\\b(?:e|pi)\\b/\n      ],\n      constant: /\\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\\b/,\n      color: {\n        pattern: /\\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\\b/i,\n        alias: 'constant'\n      },\n      operator: /[-+*/<>=!]=?|[&^?]|#(?!\\()/,\n      punctuation: /[()\\[\\]{}.:,;]|#(?=\\()|\\\\$/m\n    }\n  })(Prism)\n}\n"],"names":["markup","Prism","languages","comment","pattern","greedy","prolog","doctype","inside","lookbehind","string","punctuation","name","cdata","tag","namespace","alias","entity","hooks","add","env","type","attributes","content","value","replace","Object","defineProperty","tagName","lang","includedCdataInside","def","RegExp","source","insertBefore","attrName","push","html","mathml","svg","xml","extend","ssml","atom","rss","module","exports","displayName","aliases","matlab","number","keyword","function","operator","markupTemplating","getPlaceholder","language","index","toUpperCase","defineProperties","buildPlaceholders","placeholderPattern","replaceFilter","tokenStack","code","match","placeholder","i","length","indexOf","grammar","tokenizePlaceholders","j","keys","walkTokens","tokens","token","k","t","s","before","substring","middle","Token","tokenize","after","replacement","apply","splice","concat","maxscript","keywords","path","argument","boolean","time","constant","color"],"sourceRoot":""}
{"version":3,"file":"static/js/vendors-node_modules_extend_index_js-node_modules_inline-style-parser_index_js-node_modules_b-bb45d9.a16fd45f45.chunk.v1_9_0.js","mappings":"wNAYO,SAASA,EAAWC,GAEzB,MAAMC,EAEJD,GAA0B,iBAAVA,GAAqC,SAAfA,EAAME,KAExCF,EAAMC,OAAS,GACfD,EAIN,MAAwB,iBAAVC,GAA4D,KAAtCA,EAAME,QAAQ,eAAgB,GACpE,C,gECD0BC,EAAW,YAcJA,EAAW,cAuBlBA,EAAW,uBAa9B,SAASC,EAAaC,GAC3B,OAGW,OAATA,IAAkBA,EAAO,IAAe,MAATA,EAEnC,CAa0BF,EAAW,MAoBRA,EAAW,cAeRA,EAAW,kBA0ETA,EC9LhC,wwCDoN+BA,EAAW,MAQ5C,SAASA,EAAWG,GAClB,OAUA,SAAeD,GACb,OAAgB,OAATA,GAAiBC,EAAMC,KAAKC,OAAOC,aAAaJ,GACzD,CACF,CErMO,SAASK,EACdC,EACAC,EACAC,EACAZ,EACAa,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAQD,GAAOE,OAAOC,kBAC5B,IAAIC,EAAU,EACd,OAcA,SAAejB,GACb,GAAa,KAATA,EAMF,OALAM,EAAQY,MAAMtB,GACdU,EAAQY,MAAMT,GACdH,EAAQY,MAAMR,GACdJ,EAAQa,QAAQnB,GAChBM,EAAQc,KAAKV,GACNW,EAIT,GAAa,OAATrB,GAA0B,KAATA,GAAwB,KAATA,GAAeD,EAAaC,GAC9D,OAAOQ,EAAIR,GAQb,OANAM,EAAQY,MAAMtB,GACdU,EAAQY,MAAMP,GACdL,EAAQY,MAAMN,GACdN,EAAQY,MAAM,cAAe,CAC3BI,YAAa,WAERC,EAAIvB,EACb,EAYA,SAASqB,EAAerB,GACtB,OAAa,KAATA,GACFM,EAAQY,MAAMR,GACdJ,EAAQa,QAAQnB,GAChBM,EAAQc,KAAKV,GACbJ,EAAQc,KAAKX,GACbH,EAAQc,KAAKxB,GACNW,IAETD,EAAQY,MAAMN,GACdN,EAAQY,MAAM,cAAe,CAC3BI,YAAa,WAERE,EAASxB,GAClB,CAYA,SAASwB,EAASxB,GAChB,OAAa,KAATA,GACFM,EAAQc,KAAK,eACbd,EAAQc,KAAKR,GACNS,EAAerB,IAEX,OAATA,GAA0B,KAATA,GFIlB,SAA4BA,GACjC,OAAgB,OAATA,GAAiBA,GAAQ,CAClC,CENwCyB,CAAmBzB,GAC9CQ,EAAIR,IAEbM,EAAQa,QAAQnB,GACA,KAATA,EAAc0B,EAAiBF,EACxC,CAYA,SAASE,EAAe1B,GACtB,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GAChCM,EAAQa,QAAQnB,GACTwB,GAEFA,EAASxB,EAClB,CAYA,SAASuB,EAAIvB,GACX,OACGiB,GACS,OAATjB,GAA0B,KAATA,IFrBjB,SAAmCA,GACxC,OAAgB,OAATA,IAAkBA,EAAO,GAAc,KAATA,EACvC,CEmBuC2B,CAA0B3B,GAQzDiB,EAAUH,GAAkB,KAATd,GACrBM,EAAQa,QAAQnB,GAChBiB,IACOM,GAEI,KAATvB,GACFM,EAAQa,QAAQnB,GAChBiB,IACOM,GAMI,OAATvB,GAA0B,KAATA,GAAwB,KAATA,GAAeD,EAAaC,GACvDQ,EAAIR,IAEbM,EAAQa,QAAQnB,GACA,KAATA,EAAc4B,EAAYL,IAxB/BjB,EAAQc,KAAK,eACbd,EAAQc,KAAKR,GACbN,EAAQc,KAAKT,GACbL,EAAQc,KAAKxB,GACNW,EAAGP,GAqBd,CAYA,SAAS4B,EAAU5B,GACjB,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GAChCM,EAAQa,QAAQnB,GACTuB,GAEFA,EAAIvB,EACb,CACF,C,+BC1MO,SAAS6B,EAAMlC,GAEpB,MAAMmC,EAAS,GACTC,EAAQ5B,OAAOR,GAAS,IAC9B,IAAIqC,EAAQD,EAAME,QAAQ,KACtBC,EAAQ,EAERC,GAAM,EAEV,MAAQA,GAAK,EACI,IAAXH,IACFA,EAAQD,EAAMK,OACdD,GAAM,GAGR,MAAME,EAAQN,EAAMO,MAAMJ,EAAOF,GAAOO,QAEpCF,GAAUF,GACZL,EAAOU,KAAKH,GAGdH,EAAQF,EAAQ,EAChBA,EAAQD,EAAME,QAAQ,IAAKC,EAC7B,CAEA,OAAOJ,CACT,CAYO,SAASW,EAAUC,EAAQC,GAChC,MAAMC,EAAWD,GAAW,CAAC,EAK7B,OAF4C,KAA9BD,EAAOA,EAAON,OAAS,GAAY,IAAIM,EAAQ,IAAMA,GAGhEG,MACED,EAASE,SAAW,IAAM,IACzB,MACsB,IAArBF,EAASG,QAAoB,GAAK,MAEtCR,MACL,C,iDCvEA,IAAIS,EAASC,OAAOC,UAAUC,eAC1BC,EAAQH,OAAOC,UAAUG,SACzBC,EAAiBL,OAAOK,eACxBC,EAAON,OAAOO,yBAEdC,EAAU,SAAiBC,GAC9B,MAA6B,mBAAlBC,MAAMF,QACTE,MAAMF,QAAQC,GAGK,mBAApBN,EAAMQ,KAAKF,EACnB,EAEIG,EAAgB,SAAuBC,GAC1C,IAAKA,GAA2B,oBAApBV,EAAMQ,KAAKE,GACtB,OAAO,EAGR,IASIC,EATAC,EAAoBhB,EAAOY,KAAKE,EAAK,eACrCG,EAAmBH,EAAII,aAAeJ,EAAII,YAAYhB,WAAaF,EAAOY,KAAKE,EAAII,YAAYhB,UAAW,iBAE9G,GAAIY,EAAII,cAAgBF,IAAsBC,EAC7C,OAAO,EAMR,IAAKF,KAAOD,GAEZ,YAAsB,IAARC,GAAuBf,EAAOY,KAAKE,EAAKC,EACvD,EAGII,EAAc,SAAqBC,EAAQzB,GAC1CW,GAAmC,cAAjBX,EAAQ0B,KAC7Bf,EAAec,EAAQzB,EAAQ0B,KAAM,CACpCC,YAAY,EACZC,cAAc,EACd5E,MAAOgD,EAAQ6B,SACfC,UAAU,IAGXL,EAAOzB,EAAQ0B,MAAQ1B,EAAQ6B,QAEjC,EAGIE,EAAc,SAAqBZ,EAAKO,GAC3C,GAAa,cAATA,EAAsB,CACzB,IAAKrB,EAAOY,KAAKE,EAAKO,GACrB,OACM,GAAId,EAGV,OAAOA,EAAKO,EAAKO,GAAM1E,KAEzB,CAEA,OAAOmE,EAAIO,EACZ,EAEAM,EAAOC,QAAU,SAASC,IACzB,IAAIlC,EAAS0B,EAAMS,EAAKC,EAAMC,EAAaC,EACvCb,EAASc,UAAU,GACnBC,EAAI,EACJ/C,EAAS8C,UAAU9C,OACnBgD,GAAO,EAaX,IAVsB,kBAAXhB,IACVgB,EAAOhB,EACPA,EAASc,UAAU,IAAM,CAAC,EAE1BC,EAAI,IAES,MAAVf,GAAqC,iBAAXA,GAAyC,mBAAXA,KAC3DA,EAAS,CAAC,GAGJe,EAAI/C,IAAU+C,EAGpB,GAAe,OAFfxC,EAAUuC,UAAUC,IAInB,IAAKd,KAAQ1B,EACZmC,EAAMJ,EAAYN,EAAQC,GAItBD,KAHJW,EAAOL,EAAY/B,EAAS0B,MAKvBe,GAAQL,IAASlB,EAAckB,KAAUC,EAAcvB,EAAQsB,MAC9DC,GACHA,GAAc,EACdC,EAAQH,GAAOrB,EAAQqB,GAAOA,EAAM,IAEpCG,EAAQH,GAAOjB,EAAciB,GAAOA,EAAM,CAAC,EAI5CX,EAAYC,EAAQ,CAAEC,KAAMA,EAAMG,SAAUK,EAAOO,EAAMH,EAAOF,WAGtC,IAATA,GACjBZ,EAAYC,EAAQ,CAAEC,KAAMA,EAAMG,SAAUO,KAQjD,OAAOX,CACR,C,+DCjGA,MAAMiB,EAAM,CAAC,EAAElC,eAaR,SAASmC,EAAYC,GAE1B,MAAMC,EAAQvC,OAAOwC,OAAO,MAE5B,IAAKF,IAASA,EAAK3F,KACjB,MAAM,IAAI8F,MAAM,wCAUlB,OAPAC,EAAAA,EAAAA,IAAMJ,EAAM,cAAeK,IACzB,MAAMC,EAAKC,EAAMF,EAAWG,YACxBF,IAAOR,EAAIzB,KAAK4B,EAAOK,KACzBL,EAAMK,GAAMD,EACd,IAMF,SAAoBG,GAClB,MAAMF,EAAKC,EAAMC,GAEjB,OAAOF,GAAMR,EAAIzB,KAAK4B,EAAOK,GAAML,EAAMK,GAAM,IACjD,CACF,CAMA,SAASC,EAAMnG,GACb,OAAOQ,OAAOR,GAAS,IAAIqG,aAC7B,C,gDC3DA,MAAMC,EAAUC,SAASC,cAAc,KAMhC,SAASC,EAA8BzG,GAC5C,MAAM0G,EAAqB,IAAM1G,EAAQ,IACzCsG,EAAQK,UAAYD,EACpB,MAAME,EAAYN,EAAQO,YAQ1B,OAGiD,KAA/CD,EAAUE,WAAWF,EAAUnE,OAAS,IAC9B,SAAVzC,KASK4G,IAAcF,GAA6BE,EACpD,C,+BCnCe,SAAS1C,EAAclE,GACrC,GAAqB,iBAAVA,GAAgC,OAAVA,EAChC,OAAO,EAGR,MAAMuD,EAAYD,OAAOyD,eAAe/G,GACxC,QAAsB,OAAduD,GAAsBA,IAAcD,OAAOC,WAAkD,OAArCD,OAAOyD,eAAexD,IAA0ByD,OAAOC,eAAejH,GAAYgH,OAAOE,YAAYlH,EACtK,C,gECKA,MAAMmH,EAAe,CAAC,EAef,SAASzD,EAAS1D,EAAOgD,GAC9B,MAAMC,EAAWD,GAAWmE,EAQ5B,OAAOC,EAAIpH,EAN2B,kBAA7BiD,EAASoE,iBACZpE,EAASoE,gBAGmB,kBAAzBpE,EAASqE,aAA4BrE,EAASqE,YAGzD,CAcA,SAASF,EAAIpH,EAAOqH,EAAiBC,GACnC,GAqDF,SAActH,GACZ,OAAOuH,QAAQvH,GAA0B,iBAAVA,EACjC,CAvDMwH,CAAKxH,GAAQ,CACf,GAAI,UAAWA,EACb,MAAsB,SAAfA,EAAMC,MAAoBqH,EAAmBtH,EAAMA,MAAX,GAGjD,GAAIqH,GAAmB,QAASrH,GAASA,EAAMyH,IAC7C,OAAOzH,EAAMyH,IAGf,GAAI,aAAczH,EAChB,OAAO0H,EAAI1H,EAAM2H,SAAUN,EAAiBC,EAEhD,CAEA,OAAItD,MAAMF,QAAQ9D,GACT0H,EAAI1H,EAAOqH,EAAiBC,GAG9B,EACT,CAcA,SAASI,EAAI3E,EAAQsE,EAAiBC,GAEpC,MAAMM,EAAS,GACf,IAAIvF,GAAS,EAEb,OAASA,EAAQU,EAAON,QACtBmF,EAAOvF,GAAS+E,EAAIrE,EAAOV,GAAQgF,EAAiBC,GAGtD,OAAOM,EAAO1E,KAAK,GACrB,C,+BCxFO,SAAS2E,EAAKC,GACnB,GAAIA,EACF,MAAMA,CAEV,C,4BCTA,IAAIC,EAAgB,kCAEhBC,EAAgB,MAChBC,EAAmB,OAGnBC,EAAiB,yCACjBC,EAAc,QACdC,EAAc,uDACdC,EAAkB,UAGlBC,EAAa,aAMbC,EAAe,GA8OnB,SAAS3F,EAAK4F,GACZ,OAAOA,EAAMA,EAAItI,QAAQoI,EAAYC,GAAgBA,CACvD,CAnOAvD,EAAOC,QAAU,SAASwD,EAAOzF,GAC/B,GAAqB,iBAAVyF,EACT,MAAM,IAAIC,UAAU,mCAGtB,IAAKD,EAAO,MAAO,GAEnBzF,EAAUA,GAAW,CAAC,EAKtB,IAAI2F,EAAS,EACTC,EAAS,EAOb,SAASC,EAAeL,GACtB,IAAIM,EAAQN,EAAIO,MAAMf,GAClBc,IAAOH,GAAUG,EAAMrG,QAC3B,IAAI+C,EAAIgD,EAAIQ,YAvCF,MAwCVJ,GAAUpD,EAAIgD,EAAI/F,OAAS+C,EAAIoD,EAASJ,EAAI/F,MAC9C,CAOA,SAASwG,IACP,IAAI1G,EAAQ,CAAE2G,KAAMP,EAAQC,OAAQA,GACpC,OAAO,SAASpB,GAGd,OAFAA,EAAKyB,SAAW,IAAIE,EAAS5G,GAC7BzC,IACO0H,CACT,CACF,CAUA,SAAS2B,EAAS5G,GAChB6G,KAAK7G,MAAQA,EACb6G,KAAK5G,IAAM,CAAE0G,KAAMP,EAAQC,OAAQA,GACnCQ,KAAKC,OAASrG,EAAQqG,MACxB,CAKAF,EAAS5F,UAAU+F,QAAUb,EAE7B,IAAIc,EAAa,GAQjB,SAASzB,EAAM0B,GACb,IAAIC,EAAM,IAAI1D,MACZ/C,EAAQqG,OAAS,IAAMV,EAAS,IAAMC,EAAS,KAAOY,GAQxD,GANAC,EAAIC,OAASF,EACbC,EAAIE,SAAW3G,EAAQqG,OACvBI,EAAIP,KAAOP,EACXc,EAAIb,OAASA,EACba,EAAIJ,OAASZ,GAETzF,EAAQ4G,OAGV,MAAMH,EAFNF,EAAW1G,KAAK4G,EAIpB,CAQA,SAASV,EAAMc,GACb,IAAIC,EAAID,EAAGE,KAAKtB,GAChB,GAAKqB,EAAL,CACA,IAAItB,EAAMsB,EAAE,GAGZ,OAFAjB,EAAeL,GACfC,EAAQA,EAAM9F,MAAM6F,EAAI/F,QACjBqH,CAJO,CAKhB,CAKA,SAAShK,IACPiJ,EAAMd,EACR,CAQA,SAAS+B,EAASC,GAChB,IAAIC,EAEJ,IADAD,EAAQA,GAAS,GACTC,EAAIC,MACA,IAAND,GACFD,EAAMpH,KAAKqH,GAGf,OAAOD,CACT,CAQA,SAASE,IACP,IAAIC,EAAMnB,IACV,GAnJgB,KAmJKR,EAAM4B,OAAO,IAlJvB,KAkJyC5B,EAAM4B,OAAO,GAAjE,CAGA,IADA,IAAI7E,EAAI,EAEN+C,GAAgBE,EAAM4B,OAAO7E,KAtJpB,KAuJIiD,EAAM4B,OAAO7E,IAxJZ,KAwJmCiD,EAAM4B,OAAO7E,EAAI,OAEhEA,EAIJ,GAFAA,GAAK,EAED+C,IAAiBE,EAAM4B,OAAO7E,EAAI,GACpC,OAAOsC,EAAM,0BAGf,IAAIU,EAAMC,EAAM9F,MAAM,EAAG6C,EAAI,GAM7B,OALAoD,GAAU,EACVC,EAAeL,GACfC,EAAQA,EAAM9F,MAAM6C,GACpBoD,GAAU,EAEHwB,EAAI,CACTnK,KApKa,UAqKbkK,QAAS3B,GAvBgE,CAyB7E,CAQA,SAAS8B,IACP,IAAIF,EAAMnB,IAGNsB,EAAOxB,EAAMb,GACjB,GAAKqC,EAAL,CAIA,GAHAJ,KAGKpB,EAAMZ,GAAc,OAAOL,EAAM,wBAGtC,IAAI0C,EAAMzB,EAAMX,GAEZqC,EAAML,EAAI,CACZnK,KA7LiB,cA8LjByK,SAAU9H,EAAK2H,EAAK,GAAGrK,QAAQ6H,EAAeQ,IAC9CvI,MAAOwK,EACH5H,EAAK4H,EAAI,GAAGtK,QAAQ6H,EAAeQ,IACnCA,IAMN,OAFAQ,EAAMV,GAECoC,CApBU,CAqBnB,CAyBA,OADA3K,IAjBA,WACE,IAKI6K,EALAC,EAAQ,GAMZ,IAJAZ,EAASY,GAIDD,EAAOL,MACA,IAATK,IACFC,EAAM/H,KAAK8H,GACXX,EAASY,IAIb,OAAOA,CACT,CAGOC,EACT,C","sources":["../node_modules/hast-util-whitespace/index.js","../node_modules/micromark-factory-destination/node_modules/micromark-util-character/index.js","../node_modules/micromark-factory-destination/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-factory-destination/index.js","../node_modules/comma-separated-tokens/index.js","../node_modules/extend/index.js","../node_modules/mdast-util-definitions/lib/index.js","../node_modules/decode-named-character-reference/index.dom.js","../node_modules/is-plain-obj/index.js","../node_modules/mdast-util-to-string/lib/index.js","../node_modules/bail/index.js","../node_modules/inline-style-parser/index.js"],"sourcesContent":["/**\n * Check if the given value is *inter-element whitespace*.\n *\n * @param {unknown} thing\n *   Thing to check (typically `Node` or `string`).\n * @returns {boolean}\n *   Whether the `value` is inter-element whitespace (`boolean`): consisting of\n *   zero or more of space, tab (`\\t`), line feed (`\\n`), carriage return\n *   (`\\r`), or form feed (`\\f`).\n *   If a node is passed it must be a `Text` node, whose `value` field is\n *   checked.\n */\nexport function whitespace(thing) {\n  /** @type {string} */\n  const value =\n    // @ts-expect-error looks like a node.\n    thing && typeof thing === 'object' && thing.type === 'text'\n      ? // @ts-expect-error looks like a text.\n        thing.value || ''\n      : thing\n\n  // HTML whitespace expression.\n  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.\n  return typeof value === 'string' && value.replace(/[ \\t\\n\\f\\r]/g, '') === ''\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n/**\n * Parse destinations.\n *\n * ###### Examples\n *\n * ```markdown\n * <a>\n * <a\\>b>\n * <a b>\n * <a)>\n * a\n * a\\)b\n * a(b)c\n * a(b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type for whole (`<a>` or `b`).\n * @param {TokenType} literalType\n *   Type when enclosed (`<a>`).\n * @param {TokenType} literalMarkerType\n *   Type for enclosing (`<` and `>`).\n * @param {TokenType} rawType\n *   Type when not enclosed (`b`).\n * @param {TokenType} stringType\n *   Type for the value (`a` or `b`).\n * @param {number | undefined} [max=Infinity]\n *   Depth of nested parens (inclusive).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n\n  /**\n   * Start of destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *     ^\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return enclosedBefore\n    }\n\n    // ASCII control, space, closing paren.\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return raw(code)\n  }\n\n  /**\n   * After `<`, at an enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return enclosed(code)\n  }\n\n  /**\n   * In enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return enclosedBefore(code)\n    }\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? enclosedEscape : enclosed\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | <a\\*a>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return enclosed\n    }\n    return enclosed(code)\n  }\n\n  /**\n   * In raw destination.\n   *\n   * ```markdown\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function raw(code) {\n    if (\n      !balance &&\n      (code === null || code === 41 || markdownLineEndingOrSpace(code))\n    ) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n    if (balance < limit && code === 40) {\n      effects.consume(code)\n      balance++\n      return raw\n    }\n    if (code === 41) {\n      effects.consume(code)\n      balance--\n      return raw\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesn’t.\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? rawEscape : raw\n  }\n\n  /**\n   * After `\\`, at special character.\n   *\n   * ```markdown\n   * > | a\\*a\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function rawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return raw\n    }\n    return raw(code)\n  }\n}\n","/**\n * @typedef Options\n *   Configuration for `stringify`.\n * @property {boolean} [padLeft=true]\n *   Whether to pad a space before a token.\n * @property {boolean} [padRight=false]\n *   Whether to pad a space after a token.\n */\n\n/**\n * @typedef {Options} StringifyOptions\n *   Please use `StringifyOptions` instead.\n */\n\n/**\n * Parse comma-separated tokens to an array.\n *\n * @param {string} value\n *   Comma-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  /** @type {Array<string>} */\n  const tokens = []\n  const input = String(value || '')\n  let index = input.indexOf(',')\n  let start = 0\n  /** @type {boolean} */\n  let end = false\n\n  while (!end) {\n    if (index === -1) {\n      index = input.length\n      end = true\n    }\n\n    const token = input.slice(start, index).trim()\n\n    if (token || !end) {\n      tokens.push(token)\n    }\n\n    start = index + 1\n    index = input.indexOf(',', start)\n  }\n\n  return tokens\n}\n\n/**\n * Serialize an array of strings or numbers to comma-separated tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @param {Options} [options]\n *   Configuration for `stringify` (optional).\n * @returns {string}\n *   Comma-separated tokens.\n */\nexport function stringify(values, options) {\n  const settings = options || {}\n\n  // Ensure the last empty entry is seen.\n  const input = values[values.length - 1] === '' ? [...values, ''] : values\n\n  return input\n    .join(\n      (settings.padRight ? ' ' : '') +\n        ',' +\n        (settings.padLeft === false ? '' : ' ')\n    )\n    .trim()\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string | false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const character = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 /* `;` */ &&\n    value !== 'semi'\n  ) {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return character === characterReference ? false : character\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nmodule.exports = function(style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function(node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n};\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n"],"names":["whitespace","thing","value","type","replace","regexCheck","asciiControl","code","regex","test","String","fromCharCode","factoryDestination","effects","ok","nok","literalType","literalMarkerType","rawType","stringType","max","limit","Number","POSITIVE_INFINITY","balance","enter","consume","exit","enclosedBefore","contentType","raw","enclosed","markdownLineEnding","enclosedEscape","markdownLineEndingOrSpace","rawEscape","parse","tokens","input","index","indexOf","start","end","length","token","slice","trim","push","stringify","values","options","settings","join","padRight","padLeft","hasOwn","Object","prototype","hasOwnProperty","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","isArray","arr","Array","call","isPlainObject","obj","key","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","name","enumerable","configurable","newValue","writable","getProperty","module","exports","extend","src","copy","copyIsArray","clone","arguments","i","deep","own","definitions","tree","cache","create","Error","visit","definition","id","clean","identifier","toUpperCase","element","document","createElement","decodeNamedCharacterReference","characterReference","innerHTML","character","textContent","charCodeAt","getPrototypeOf","Symbol","toStringTag","iterator","emptyOptions","one","includeImageAlt","includeHtml","Boolean","node","alt","all","children","result","bail","error","COMMENT_REGEX","NEWLINE_REGEX","WHITESPACE_REGEX","PROPERTY_REGEX","COLON_REGEX","VALUE_REGEX","SEMICOLON_REGEX","TRIM_REGEX","EMPTY_STRING","str","style","TypeError","lineno","column","updatePosition","lines","match","lastIndexOf","position","line","Position","this","source","content","errorsList","msg","err","reason","filename","silent","re","m","exec","comments","rules","c","comment","pos","charAt","declaration","prop","val","ret","property","decl","decls","declarations"],"sourceRoot":""}
{"version":3,"file":"static/js/small-chunks-6b882012.f499920b.js","mappings":"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","sources":["utils/preloadFormatting.js","utils/formatters.js","utils/performance.js","workers/streamProcessor.js","serviceWorkerRegistration.js","workers/modelProcessor.js","reportWebVitals.js"],"sourcesContent":["/**\n * Utility functions for preloading formatting-related components\n */\nimport {  PERFORMANCE_MARKS, PERFORMANCE_MEASURES } from './performance';\n\n// Phase 2: Basic Formatting Components - essential for initial rendering\nexport const basicFormattingImports = [\n  () => import(/* webpackChunkName: \"react-markdown\" */ 'react-markdown'),\n  () => import(/* webpackChunkName: \"remark-gfm\" */ 'remark-gfm'),\n];\n\n// Advanced Formatting Components - includes StreamingMessage and all its dependencies\nexport const advancedFormattingImports = [\n  // StreamingMessage and its dependencies\n  () => import(/* webpackChunkName: \"streaming-message\" */ '../components/chat/ChatMessage/StreamingMessage'),\n  () => import(/* webpackChunkName: \"syntax-highlighter-prism\" */ 'react-syntax-highlighter/dist/esm/prism'),\n  () => import(/* webpackChunkName: \"prism-atom-dark\" */ 'react-syntax-highlighter/dist/esm/styles/prism/atom-dark'),\n  () => import(/* webpackChunkName: \"prism-style\" */ 'react-syntax-highlighter/dist/esm/styles/prism/prism'),\n  () => import(/* webpackChunkName: \"rehype-katex\" */ 'rehype-katex'), \n  () => import(/* webpackChunkName: \"katex-css\" */ 'katex/dist/katex.min.css'), \n  () => import(/* webpackChunkName: \"remark-emoji\" */ 'remark-emoji'),\n  () => import(/* webpackChunkName: \"rehype-raw\" */ 'rehype-raw'),\n  () => import(/* webpackChunkName: \"remark-math\" */ 'remark-math'),\n];\n\n// Phase 2: Model Selector Components\nexport const modelSelectorImports = [\n  () => import(/* webpackChunkName: \"model-dropdown\" */ '../components/models/ModelDropdown'),\n  () => import(/* webpackChunkName: \"model-item\" */ '../components/models/ModelItem'),\n  () => import(/* webpackChunkName: \"model-search\" */ '../components/models/ModelSearch'),\n  () => import(/* webpackChunkName: \"model-selector-button\" */ '../components/models/ModelSelectorButton')\n];\n\n// Removed preloadFormattingComponents and preloadFormattingComponentsIdle functions\n// Loading logic will be handled directly in App.js\n\n// Keep performance monitoring utilities if they are used elsewhere,\n// but the specific measurement logic tied to the removed functions is gone.\n// Export constants if needed elsewhere\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES };\n\n// Example of how you might export all imports if needed elsewhere,\n// but individual phase arrays are likely more useful now.\nconst formattingUtils = {\n  basicFormattingImports,\n  advancedFormattingImports,\n  modelSelectorImports\n};\n\nexport default formattingUtils; ","/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX formatting from \\( ... \\) to $...$ format for remark-math,\n * and \\[ ... \\] to $$ ... $$ for block math. Leaves existing $$ untouched.\n * @param {string} text - Text with LaTeX expressions in \\(...\\) or \\[...\\] format\n * @returns {string} - Text with LaTeX expressions converted to math delimiters\n */\nexport const convertTeXToMathDollars = (text) => {\n  if (!text) return '';\n  // Avoid converting inside code fences\n  const codeBlockRegex = /(```[\\s\\S]*?```)/g;\n  const parts = text.split(codeBlockRegex);\n  return parts.map((part, index) => {\n    // Skip code blocks\n    if (index % 2 === 1 && part.startsWith('```')) {\n      return part;\n    }\n    let result = part;\n    // Inline math: \\( ... \\) → $...$\n    result = result.replace(/\\\\\\(\\s*(.*?)\\s*\\\\\\)/g, (_, content) => `$${content}$`);\n    // Block math: \\[ ... \\] → $$ ... $$ (on its own lines)\n    result = result.replace(/\\\\\\[\\s*([\\s\\S]*?)\\s*\\\\\\]/g, (_, content) => `$$\n${content.trim()}\n$$`);\n    return result;\n  }).join('');\n};\n\n","/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","/* eslint-disable no-restricted-globals */\n\n// streamProcessor.js\n// Web Worker to parse SSE streaming chunks into content + tokenCount\n\nself.onmessage = ({ data: chunk }) => {\n  // data is the raw chunk string from fetch streams\n  const messages = [];\n  const parts = chunk.split('\\n\\n');\n\n  for (const part of parts) {\n    if (!part.trim()) continue;\n    if (part.startsWith(':heartbeat')) continue;\n    if (part.startsWith('data:')) {\n      const payload = part.slice(5).trim();\n      if (payload === '[DONE]') {\n        messages.push({ isDone: true });\n      } else {\n        try {\n          const parsed = JSON.parse(payload);\n          \n          // Check if this is the final chunk with complete metadata\n          // Look for the specific format from the example\n          const isFinalChunk = parsed.id && parsed.model && parsed.usage;\n          \n          const content = parsed.content || '';\n          \n          // Extract token details if available\n          let tokenInfo = null;\n          \n          if (parsed.usage) {\n            // Direct match to the provided example\n            tokenInfo = {\n              promptTokens: parsed.usage.promptTokens,\n              completionTokens: parsed.usage.completionTokens,\n              totalTokens: parsed.usage.totalTokens\n            };\n            console.log(\"[WORKER] Found usage data:\", tokenInfo);\n          } else if (parsed.raw?.usageMetadata) {\n            tokenInfo = {\n              promptTokens: parsed.raw.usageMetadata.promptTokenCount,\n              completionTokens: parsed.raw.usageMetadata.candidatesTokenCount,\n              totalTokens: parsed.raw.usageMetadata.totalTokenCount\n            };\n            console.log(\"[WORKER] Found raw.usageMetadata:\", tokenInfo);\n          }\n          \n          // Fallback token count calculation if no detailed info\n          const tokenCount = content.split(/\\s+/).filter(Boolean).length;\n          \n          messages.push({ \n            content, \n            tokenCount,\n            tokenInfo,\n            finishReason: parsed.finishReason,\n            model: parsed.model,\n            provider: parsed.provider,\n            isFinalChunk,\n            rawChunk: parsed\n          });\n        } catch (e) {\n          // ignore parse errors\n          console.error(\"[WORKER] Parse error:\", e);\n        }\n      }\n    }\n  }\n\n  // Send parsed messages back to main thread\n  self.postMessage(messages);\n}; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","/* eslint-disable no-restricted-globals */\n// modelProcessor.js\n// Web Worker for processing model list data in the background\n\n/**\n * processModels replicates the logic from ModelContext to transform\n * hierarchical_groups into flat arrays and nested maps.\n */\nfunction processModels(data) {\n  const allModels = [];\n  const experimentalModels = [];\n  const processedModels = {};\n\n  // Helper to normalize a model name\n  const normalizeModelName = (model) => {\n    const name = model.id || '';\n    return name.split('/').pop() || name;\n  };\n\n  data.hierarchical_groups.forEach(providerGroup => {\n    const provider = providerGroup.group_value;\n    if (!providerGroup.children) return;\n\n    providerGroup.children.forEach(typeGroup => {\n      const type = typeGroup.group_value;\n      if (!typeGroup.children) return;\n\n      typeGroup.children.forEach(versionGroup => {\n        const version = versionGroup.group_value;\n        if (!Array.isArray(versionGroup.models)) return;\n\n        versionGroup.models.forEach(model => {\n          let category = 'Chat';\n          const t = (model.type || type || '').toLowerCase();\n          if (t.includes('image')) category = 'Image';\n          else if (t.includes('embedding')) category = 'Embedding';\n\n          const processedModel = {\n            id: model.id,\n            name: model.name || model.display_name || normalizeModelName(model),\n            provider,\n            type: model.type || type,\n            version: model.version || version,\n            category,\n            is_experimental: model.is_experimental,\n            is_multimodal: model.is_multimodal,\n            capabilities: model.capabilities,\n            family: model.family || type,\n            series: model.series || version\n          };\n\n          allModels.push(processedModel);\n          if (model.is_experimental) experimentalModels.push(processedModel);\n\n          // Build nested map: processedModels[category][provider][type]\n          processedModels[category] = processedModels[category] || {};\n          processedModels[category][provider] = processedModels[category][provider] || {};\n          processedModels[category][provider][type] = processedModels[category][provider][type] || [];\n          processedModels[category][provider][type].push(processedModel);\n        });\n      });\n    });\n  });\n\n  return { allModels, processedModels, experimentalModels };\n}\n\n// Listen for messages from main thread\nself.onmessage = ({ data }) => {\n  try {\n    const result = processModels(data);\n    self.postMessage({ ...result });\n  } catch (err) {\n    self.postMessage({ error: err.message });\n  }\n}; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; "],"names":["basicFormattingImports","advancedFormattingImports","modelSelectorImports","convertTeXToMathDollars","text","split","map","part","index","startsWith","result","replace","_","content","trim","join","PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","Set","measures","window","trackPaintMetrics","PerformanceObserver","entries","getEntries","forEach","entry","markName","name","performance","mark","add","measureName","measure","error","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clear","clearMarks","clearMeasures","logMetrics","self","onmessage","_ref","data","chunk","messages","parts","payload","slice","push","isDone","_parsed$raw","parsed","JSON","parse","isFinalChunk","id","model","usage","tokenInfo","promptTokens","completionTokens","totalTokens","raw","usageMetadata","promptTokenCount","candidatesTokenCount","totalTokenCount","tokenCount","filter","Boolean","length","finishReason","provider","rawChunk","e","postMessage","isLocalhost","location","hostname","match","register","config","navigator","URL","process","href","origin","addEventListener","swUrl","fetch","headers","then","response","contentType","get","status","indexOf","serviceWorker","ready","registration","unregister","reload","registerValidSW","catch","checkValidServiceWorker","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","allModels","experimentalModels","processedModels","normalizeModelName","pop","hierarchical_groups","providerGroup","group_value","children","typeGroup","type","versionGroup","version","Array","isArray","models","category","t","toLowerCase","includes","processedModel","display_name","is_experimental","is_multimodal","capabilities","family","series","processModels","err","message","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB"],"sourceRoot":""}
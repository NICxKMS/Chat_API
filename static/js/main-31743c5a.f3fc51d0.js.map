{"version":3,"file":"static/js/main-31743c5a.f3fc51d0.js","mappings":"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","sources":["contexts/ThemeContext.js","contexts/PerformanceMetricsContext.js","contexts/SettingsContext.js","utils/performance.js","reportWebVitals.js","serviceWorkerRegistration.js","index.js","contexts/StreamingEventsContext.js","hooks/useCacheToggle.js","utils/network.js","hooks/useLocalStorage.js","contexts/ModelContext.js","../webpack/runtime/startup prefetch"],"sourcesContent":["import { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\n\n// Create theme context\nconst ThemeContext = createContext();\n\n// Custom hook for using theme\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n\n// Theme provider component\nexport const ThemeProvider = ({ children }) => {\n  // Initialize theme from localStorage or default to 'dark'\n  const [theme, setTheme] = useState(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return savedTheme || 'dark';\n  });\n\n  // Toggle between light and dark themes\n  const toggleTheme = useCallback(() => {\n    setTheme(prevTheme => {\n      const newTheme = prevTheme === 'dark' ? 'light' : 'dark';\n      localStorage.setItem('theme', newTheme);\n      return newTheme;\n    });\n  }, []);\n\n  // Apply theme class to body element\n  useEffect(() => {\n    document.body.classList.remove('light-mode', 'dark-mode');\n    document.body.classList.add(`${theme}-mode`);\n  }, [theme]);\n\n  // Context value - memoized to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    theme,\n    toggleTheme,\n    isDark: theme === 'dark'\n  }), [theme, toggleTheme]);\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}; ","import React, { createContext, useContext, useState, useCallback, useMemo, useEffect } from 'react';\nimport { useChatHistory } from './ChatHistoryContext';\n\n// Create performance metrics context\nconst PerformanceMetricsContext = createContext();\n\n// Hook to use performance metrics context\nexport const usePerformanceMetrics = () => {\n  const context = useContext(PerformanceMetricsContext);\n  if (context === undefined) {\n    throw new Error('usePerformanceMetrics must be used within a PerformanceMetricsProvider');\n  }\n  return context;\n};\n\n// Provider component for performance metrics\nexport const PerformanceMetricsProvider = ({ children }) => {\n  const { setChatHistory } = useChatHistory();\n  const [currentMessageMetrics, setCurrentMessageMetrics] = useState({\n    startTime: null,\n    endTime: null,\n    elapsedTime: null,\n    tokenCount: null,\n    tokensPerSecond: null,\n    isComplete: false,\n    timeToFirstToken: null,\n    promptTokens: null,\n    completionTokens: null,\n    totalTokens: null,\n    finishReason: null\n  });\n\n  const resetPerformanceMetrics = useCallback(() => {\n    setCurrentMessageMetrics({\n      startTime: null,\n      endTime: null,\n      elapsedTime: null,\n      tokenCount: null,\n      tokensPerSecond: null,\n      isComplete: false,\n      timeToFirstToken: null,\n      promptTokens: null,\n      completionTokens: null,\n      totalTokens: null,\n      finishReason: null\n    });\n  }, []);\n\n  const startPerformanceTimer = useCallback(() => {\n    setCurrentMessageMetrics(prev => ({\n      ...prev,\n      startTime: Date.now(),\n      isComplete: false\n    }));\n  }, []);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const updatePerformanceMetrics = useCallback((newTokenCount, isComplete = false, tokenInfo = null, finishReason = null) => {\n    setCurrentMessageMetrics(prev => {\n      const endTime = Date.now();\n      const elapsedTime = prev.startTime ? endTime - prev.startTime : 0;\n      const tokensPerSecond = newTokenCount && elapsedTime ?\n        Math.round((newTokenCount / (elapsedTime / 1000)) * 10) / 10 :\n        prev.tokensPerSecond;\n      const timeToFirstToken = prev.timeToFirstToken ||\n        (newTokenCount > 0 ? elapsedTime : null);\n\n      const newMetrics = {\n        startTime: prev.startTime,\n        endTime,\n        elapsedTime,\n        tokenCount: newTokenCount,\n        tokensPerSecond,\n        isComplete,\n        timeToFirstToken,\n        promptTokens: tokenInfo?.promptTokens || prev.promptTokens,\n        completionTokens: tokenInfo?.completionTokens || prev.completionTokens,\n        totalTokens: tokenInfo?.totalTokens || prev.totalTokens,\n        finishReason: finishReason || prev.finishReason\n      };\n\n      return newMetrics;\n    });\n  }, []);\n\n  // Sync performance metrics into chat history after a metrics update\n  useEffect(() => {\n    if (currentMessageMetrics.endTime != null) {\n      setChatHistory(prevHistory => {\n        const newHistory = [...prevHistory];\n        const lastMsg = newHistory[newHistory.length - 1];\n        if (lastMsg && lastMsg.role === 'assistant') {\n          lastMsg.metrics = { ...currentMessageMetrics };\n        }\n        return newHistory;\n      });\n    }\n  }, [currentMessageMetrics, setChatHistory]);\n\n  // Direct function to set token metrics for the last message - for debugging/testing\n  const setTokenMetricsForLastMessage = useCallback((metrics) => {\n    setChatHistory(prevHistory => {\n      const newHistory = [...prevHistory];\n      const lastMsg = newHistory[newHistory.length - 1];\n      if (lastMsg && lastMsg.role === 'assistant') {\n        lastMsg.metrics = {\n          ...(lastMsg.metrics || {}),\n          ...metrics,\n          isComplete: true\n        };\n      }\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  const value = useMemo(() => ({\n    currentMessageMetrics,\n    resetPerformanceMetrics,\n    startPerformanceTimer,\n    updatePerformanceMetrics,\n    setTokenMetricsForLastMessage\n  }), [currentMessageMetrics, resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics, setTokenMetricsForLastMessage]);\n\n  return (\n    <PerformanceMetricsContext.Provider value={value}>\n      {children}\n    </PerformanceMetricsContext.Provider>\n  );\n}; ","import { createContext, useContext, useCallback, useMemo } from 'react';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\n\n// Default settings values\nconst DEFAULT_SETTINGS = {\n  temperature: 0.7,\n  top_p: 1.0,\n  max_tokens: 8191,\n  frequency_penalty: 0,\n  presence_penalty: 0,\n  streaming: true,\n  systemPrompt: \"You are ChatGPT, a helpful and knowledgeable AI assistant. Your primary role is to assist Nikhil, a university engineering student, by providing clear, concise, and technically accurate information. Adopt a friendly and approachable tone, akin to a knowledgeable peer or mentor. Enhance your responses with relevant emojis to convey tone and emotion, making interactions more engaging. Structure your answers logically, using bullet points or numbered lists where appropriate to enhance clarity. When applicable, incorporate interactive elements such as code snippets or diagrams to facilitate deeper understanding. Encourage curiosity by suggesting related topics or questions that Nikhil might explore further. Always tailor your assistance to support Nikhil's academic and personal growth in the field of engineering\"\n};\n\n// Create settings context\nconst SettingsContext = createContext();\n\n// Custom hook for using settings\nexport const useSettings = () => {\n  const context = useContext(SettingsContext);\n  if (context === undefined) {\n    throw new Error('useSettings must be used within a SettingsProvider');\n  }\n  return context;\n};\n\n// Settings provider component\nexport const SettingsProvider = ({ children }) => {\n  // Initialize settings state with defaults, persisted to localStorage\n  const [settings, setSettings] = useLocalStorage('appSettings', DEFAULT_SETTINGS);\n  \n  // Handle individual setting updates\n  const updateSetting = useCallback((key, value) => {\n    // Ensure the key is a valid setting we manage\n    if (key in DEFAULT_SETTINGS) {\n      // console.log(`[SettingsContext] Updating '${key}' from ${settings[key]} to ${value}`);\n      setSettings(prev => ({\n        ...prev,\n        [key]: value\n      }));\n    }\n  }, [setSettings]);\n  \n  // Reset settings to defaults\n  const resetSettings = useCallback(() => {\n    // console.log(\"[SettingsContext] Resetting settings to default\");\n    setSettings(DEFAULT_SETTINGS);\n  }, [setSettings]);\n  \n  // Check if temperature should be restricted based on model name/series\n  const shouldRestrictTemperature = useCallback((model) => {\n    if (!model) return false;\n    \n    // More explicit flag checking for temperature restriction\n    // Check for specific model properties that indicate temperature restriction\n    return (\n      model.requiresFixedTemperature === true || \n      (model.properties && model.properties.includes('fixed_temperature')) ||\n      (model.id && model.id.toLowerCase().startsWith('o')) ||\n      (model.series && model.series.toLowerCase() === 'o-series')\n    );\n  }, []);\n  \n  // Get current settings with potential model-specific overrides\n  const getModelAdjustedSettings = useCallback((model) => {\n    if (shouldRestrictTemperature(model)) {\n      return {\n        ...settings,\n        temperature: 1.0\n      };\n    }\n    return settings;\n  }, [settings, shouldRestrictTemperature]);\n  \n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(() => ({\n    settings,\n    updateSetting,\n    resetSettings,\n    shouldRestrictTemperature,\n    getModelAdjustedSettings\n  }), [\n    settings,\n    updateSetting, \n    resetSettings, \n    shouldRestrictTemperature, \n    getModelAdjustedSettings\n  ]);\n  \n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n}; ","/**\n * Performance monitoring utility\n * Tracks various performance metrics and provides methods for optimization\n */\n\n// Performance marks for tracking different stages of app initialization\nconst PERFORMANCE_MARKS = {\n  APP_START: 'app-start',\n  CONTEXT_INIT: 'context-init',\n  COMPONENT_LOAD: 'component-load',\n  IMPORTANT_COMPONENTS_LOADED: 'important-components-loaded',\n  FORMATTING_COMPONENTS_LOADED: 'formatting-components-loaded',\n  MODEL_SELECTOR_COMPONENTS_LOADED: 'model-selector-components-loaded',\n  FIRST_PAINT: 'first-paint',\n  FIRST_CONTENTFUL_PAINT: 'first-contentful-paint',\n  APP_INTERACTIVE: 'app-interactive',\n  APP_READY: 'app-ready'\n};\n\n// Performance measures for tracking durations\nconst PERFORMANCE_MEASURES = {\n  TOTAL_LOAD: 'total-load-time',\n  CONTEXT_INIT: 'context-init-time',\n  COMPONENT_LOAD: 'component-load-time',\n  TIME_TO_INTERACTIVE: 'time-to-interactive',\n  IMPORTANT_LOAD_TIME: 'important-load-time',\n  FORMATTING_LOAD_TIME: 'formatting-load-time',\n  MODEL_SELECTOR_LOAD_TIME: 'model-selector-load-time'\n};\n\nclass PerformanceMonitor {\n  constructor() {\n    this.marks = new Set();\n    this.measures = new Set();\n    \n    // Automatically track paint metrics if browser supports it\n    if (typeof window !== 'undefined' && 'performance' in window && 'PerformanceObserver' in window) {\n      this.trackPaintMetrics();\n    }\n  }\n\n  /**\n   * Track browser paint metrics (FP, FCP)\n   */\n  trackPaintMetrics() {\n    try {\n      // Create a performance observer to track paint events\n      const paintObserver = new PerformanceObserver((entries) => {\n        entries.getEntries().forEach(entry => {\n          const markName = entry.name === 'first-paint' \n            ? PERFORMANCE_MARKS.FIRST_PAINT \n            : PERFORMANCE_MARKS.FIRST_CONTENTFUL_PAINT;\n          \n          // Add our own performance mark based on the browser's timing\n          performance.mark(markName);\n          this.marks.add(markName);\n          \n          // Measure time from app start to this paint event\n          const measureName = entry.name === 'first-paint' \n            ? 'time-to-first-paint' \n            : 'time-to-first-contentful-paint';\n          \n          try {\n            performance.measure(measureName, PERFORMANCE_MARKS.APP_START, markName);\n            this.measures.add(measureName);\n          } catch (error) {\n            // Handle case where APP_START mark may not exist yet\n            console.warn(`Failed to measure ${measureName}:`, error);\n          }\n        });\n      });\n      \n      // Start observing paint events\n      paintObserver.observe({ entryTypes: ['paint'] });\n    } catch (error) {\n      console.warn('Failed to track paint metrics:', error);\n    }\n  }\n\n  /**\n   * Mark a specific point in time\n   * @param {string} markName - Name of the performance mark\n   */\n  mark(markName) {\n    if (performance && performance.mark) {\n      performance.mark(markName);\n      this.marks.add(markName);\n    }\n  }\n\n  /**\n   * Measure duration between two marks\n   * @param {string} measureName - Name of the performance measure\n   * @param {string} startMark - Name of the start mark\n   * @param {string} endMark - Name of the end mark\n   */\n  measure(measureName, startMark, endMark) {\n    if (performance && performance.measure) {\n      try {\n        performance.measure(measureName, startMark, endMark);\n        this.measures.add(measureName);\n      } catch (error) {\n        console.warn(`Failed to measure ${measureName}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Get all performance measures\n   * @returns {Array} Array of performance measure entries\n   */\n  getMeasures() {\n    if (performance && performance.getEntriesByType) {\n      return performance.getEntriesByType('measure');\n    }\n    return [];\n  }\n\n  /**\n   * Clear all performance marks and measures\n   */\n  clear() {\n    if (performance) {\n      performance.clearMarks();\n      performance.clearMeasures();\n      this.marks.clear();\n      this.measures.clear();\n    }\n  }\n\n  /**\n   * Log performance metrics to console\n   */\n  logMetrics() {\n    const measures = this.getMeasures();\n    console.group('Performance Metrics');\n    measures.forEach(measure => {\n      console.log(`${measure.name}: ${measure.duration.toFixed(2)}ms`);\n    });\n    \n    // Log Web Vitals if available\n    if ('web-vitals' in window) {\n      console.log('Web Vitals will be reported separately');\n    }\n    \n    console.groupEnd();\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Export constants\nexport { PERFORMANCE_MARKS, PERFORMANCE_MEASURES }; ","const reportWebVitals = (onPerfEntry) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(/* webpackChunkName: \"web-vitals\" */ 'web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals; ","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'service-worker' in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log('New content is available and will be used when all tabs for this page are closed.');\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n} ","import './utils/polyfills';\nimport React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\n// Create root and render app with Suspense\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Suspense fallback={\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: '100vh' \n      }}>\n        Loading...\n      </div>\n    }>\n      <App />\n    </Suspense>\n  </React.StrictMode>\n);\n\n// Report web vitals for performance monitoring\nreportWebVitals(console.log);\n\n// Register service worker for PWA support\nserviceWorkerRegistration.register({\n  onUpdate: registration => {\n    // When new content is available, show a notification\n    const waitingServiceWorker = registration.waiting;\n    if (waitingServiceWorker) {\n      waitingServiceWorker.addEventListener(\"statechange\", event => {\n        if (event.target.state === \"activated\") {\n          window.location.reload();\n        }\n      });\n      waitingServiceWorker.postMessage({ type: \"SKIP_WAITING\" });\n    }\n  }\n}); ","import React, { createContext, useContext, useRef, useCallback,  useMemo } from 'react';\nimport { useApi } from './ApiContext';\nimport { useModel } from './ModelContext';\nimport { useSettings } from './SettingsContext';\nimport { useAuth } from './AuthContext';\nimport { useChatHistory } from './ChatHistoryContext';\nimport { useChatStatus } from './ChatStatusContext';\nimport { usePerformanceMetrics } from './PerformanceMetricsContext';\nimport { fetchWithRetry } from '../utils/network';\nimport debounce from 'lodash.debounce';\n\n// Create a context for streaming events and logic\nconst StreamingEventsContext = createContext();\n\nexport const useStreamingEvents = () => {\n  const context = useContext(StreamingEventsContext);\n  if (context === undefined) {\n    throw new Error('useStreamingEvents must be used within a StreamingEventsProvider');\n  }\n  return context;\n};\n\nexport const StreamingEventsProvider = ({ children }) => {\n  const { apiUrl } = useApi();\n  const { selectedModel } = useModel();\n  const { getModelAdjustedSettings } = useSettings();\n  const { idToken } = useAuth();\n  const { chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent } = useChatHistory();\n  const { setIsWaitingForResponse, setError } = useChatStatus();\n  const { resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics } = usePerformanceMetrics();\n\n  // Refs for streaming\n  const streamingTextRef = useRef('');\n  const currentRequestIdRef = useRef(null);\n  const abortControllerRef = useRef(null);\n  const isStreamingRef = useRef(false);\n\n  // Debounced content updater\n  const debouncedUpdateChat = useMemo(\n    () => debounce((content) => updateChatWithContent(content), 20),\n    [updateChatWithContent]\n  );\n\n  // SSE parsing worker setup\n  const streamWorkerUrlRef = useRef(null);\n  const streamWorkerRef = useRef(null);\n  const getOrCreateStreamWorker = useCallback(() => {\n    if (!streamWorkerRef.current) {\n      if (!streamWorkerUrlRef.current) {\n        streamWorkerUrlRef.current = new URL('../workers/streamProcessor.js', import.meta.url);\n      }\n      streamWorkerRef.current = new Worker(streamWorkerUrlRef.current, { type: 'module' });\n    }\n    return streamWorkerRef.current;\n  }, []);\n\n  const parseStreamChunk = useCallback((chunk) => new Promise((resolve, reject) => {\n    const worker = getOrCreateStreamWorker();\n    worker.onmessage = (e) => resolve(e.data);\n    worker.onerror = reject;\n    worker.postMessage(chunk);\n  }), [getOrCreateStreamWorker]);\n\n  // Helper to update placeholder on error\n  const _updatePlaceholderOnError = useCallback(() => {\n    setChatHistory(prev => {\n      const newHistory = [...prev];\n      const lastMessage = newHistory[newHistory.length - 1];\n      if (lastMessage && lastMessage.role === 'assistant') {\n        const existingContent = lastMessage.content;\n        const errorSuffix = ' [Error occurred during generation]';\n        if (!existingContent.includes(errorSuffix)) {\n          lastMessage.content = existingContent\n            ? `${existingContent}${errorSuffix}`\n            : 'Error occurred during generation';\n          if (lastMessage.metrics) {\n            lastMessage.metrics.isComplete = true;\n            lastMessage.metrics.error = true;\n          }\n        }\n      }\n      return newHistory;\n    });\n  }, [setChatHistory]);\n\n  // Stream a message using fetch SSE\n  const streamMessageWithFetch = useCallback(async (message, editIndex = null) => {\n    // Generate and store a client-side requestId for this stream\n    const requestId = (typeof crypto !== 'undefined' && crypto.randomUUID)\n      ? crypto.randomUUID()\n      : Math.random().toString(36).substring(2) + Date.now().toString(36);\n    currentRequestIdRef.current = requestId;\n    const isEditing = editIndex !== null && Number.isInteger(editIndex) && editIndex >= 0;\n    if (!message || !selectedModel) {\n      setError('Please enter a message and select a model');\n      return null;\n    }\n    const modelId = `${selectedModel.provider}/${selectedModel.id}`;\n    if (!modelId) {\n      setError('Invalid model selection');\n      return null;\n    }\n    let userMessage;\n    if (isEditing) {\n      setChatHistory(prev => {\n        const truncated = prev.slice(0, editIndex);\n        userMessage = { role: 'user', content: message, timestamp: Date.now() };\n        return [...truncated, userMessage];\n      });\n    } else {\n      userMessage = addMessageToHistory('user', message);\n    }\n    resetPerformanceMetrics();\n    startPerformanceTimer();\n    setIsWaitingForResponse(true);\n    setError(null);\n    streamingTextRef.current = '';\n    isStreamingRef.current = true;\n    addMessageToHistory('assistant', '');\n    let timeoutId = setTimeout(() => {\n      abortControllerRef.current?.abort('timeout');\n      setError('Connection timed out');\n      setIsWaitingForResponse(false);\n    }, 60000);\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n    try {\n      const adjusted = getModelAdjustedSettings(selectedModel);\n      const historyForApi = chatHistoryRef.current.map(({ metrics, ...m }) => m);\n      if (adjusted.systemPrompt && (!historyForApi.length || historyForApi[0].role !== 'system')) {\n        historyForApi.unshift({ role: 'system', content: adjusted.systemPrompt, timestamp: Date.now() - 1 });\n      }\n      historyForApi.push(userMessage);\n      const payload = {\n        requestId,\n        model: modelId,\n        messages: historyForApi,\n        temperature: adjusted.temperature,\n        max_tokens: adjusted.max_tokens,\n        top_p: adjusted.top_p,\n        frequency_penalty: adjusted.frequency_penalty,\n        presence_penalty: adjusted.presence_penalty\n      };\n      const headers = { 'Content-Type': 'application/json', 'Accept': 'text/event-stream', 'Cache-Control': 'no-cache' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      const response = await fetchWithRetry(new URL('/api/chat/stream', apiUrl).toString(), {\n        method: 'POST', headers, body: JSON.stringify(payload), signal: abortController.signal, cache: 'no-store'\n      });\n      if (!response.ok) throw new Error(`API error: ${response.status}`);\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder('utf-8');\n      let accumulatedContent = '';\n      let accumulatedTokens = 0;\n      while (true) {\n        const { done, value } = await reader.read();\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => {\n          abortControllerRef.current?.abort();\n          setError('Connection timed out');\n          setIsWaitingForResponse(false);\n        }, 60000);\n        if (done) {\n          // handle leftover buffer\n          break;\n        }\n        const chunk = decoder.decode(value, { stream: true });\n        try {\n          const msgs = await parseStreamChunk(chunk);\n          for (const msg of msgs) {\n            if (msg.isDone) updatePerformanceMetrics(accumulatedTokens, true);\n            else if (msg.content) {\n              accumulatedContent += msg.content;\n              accumulatedTokens += msg.tokenCount || 0;\n              streamingTextRef.current = accumulatedContent;\n              debouncedUpdateChat(accumulatedContent);\n              updatePerformanceMetrics(accumulatedTokens, false, msg.tokenInfo, msg.finishReason);\n            }\n          }\n        } catch {}\n      }\n      debouncedUpdateChat.flush();\n      updateChatWithContent(streamingTextRef.current);\n      updatePerformanceMetrics(accumulatedTokens, true);\n      return streamingTextRef.current;\n    } catch (error) {\n      _updatePlaceholderOnError();\n      return null;\n    } finally {\n      clearTimeout(timeoutId);\n      isStreamingRef.current = false;\n      setIsWaitingForResponse(false);\n      // Do not auto-call stop endpoint here; only explicit stop should trigger it\n      currentRequestIdRef.current = null;\n    }\n  }, [\n    apiUrl, selectedModel, getModelAdjustedSettings, idToken,\n    chatHistoryRef, setChatHistory, addMessageToHistory, updateChatWithContent,\n    debouncedUpdateChat, setError, setIsWaitingForResponse,\n    resetPerformanceMetrics, startPerformanceTimer, updatePerformanceMetrics,\n    parseStreamChunk, _updatePlaceholderOnError\n  ]);\n\n  const stopStreaming = useCallback(async () => {\n    if (abortControllerRef.current) abortControllerRef.current.abort('user_stopped');\n    const reqId = currentRequestIdRef.current;\n    if (reqId) {\n      const headers = { 'Content-Type': 'application/json' };\n      if (idToken) headers['Authorization'] = `Bearer ${idToken}`;\n      try {\n        await fetchWithRetry(new URL('/api/chat/stop', apiUrl).toString(), {\n          method: 'POST', headers, body: JSON.stringify({ requestId: reqId })\n        });\n      } catch {} finally {\n        currentRequestIdRef.current = null;\n        abortControllerRef.current = null;\n      }\n    }\n    isStreamingRef.current = false;\n    setIsWaitingForResponse(false);\n    return true;\n  }, [apiUrl, idToken, setIsWaitingForResponse]);\n\n  const value = useMemo(() => ({\n    streamMessageWithFetch,\n    stopStreaming,\n    parseStreamChunk,\n    streamingTextRef,\n    isStreaming: () => isStreamingRef.current\n  }), [streamMessageWithFetch, stopStreaming, parseStreamChunk]);\n\n  return (\n    <StreamingEventsContext.Provider value={value}>\n      {children}\n    </StreamingEventsContext.Provider>\n  );\n}; ","import { useEffect, useCallback } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n/**\n * Custom hook for controlling model caching\n * @returns {Object} Cache toggle state and methods\n */\nexport const useCacheToggle = () => {\n  // Store cache enabled setting in localStorage with default value of true\n  const [cacheEnabled, setCacheEnabled] = useLocalStorage('modelCacheEnabled', true);\n  \n  // Clear model cache\n  const clearModelCache = useCallback(() => {\n    try {\n      localStorage.removeItem('modelDropdownCache');\n      console.log('Model cache cleared');\n    } catch (error) {\n      console.error('Error clearing model cache:', error);\n    }\n  }, []);\n\n  // Toggle cache enabled state and clear cache if disabling\n  const toggleCache = useCallback((enabled) => {\n    const newValue = typeof enabled === 'boolean' ? enabled : !cacheEnabled;\n    \n    // If turning off caching, clear the existing cache\n    if (!newValue) {\n      clearModelCache();\n    }\n    \n    setCacheEnabled(newValue);\n    return newValue;\n  }, [cacheEnabled, setCacheEnabled, clearModelCache]);\n\n  // Forcibly refresh models by clearing cache\n  const refreshModels = useCallback(() => {\n    clearModelCache();\n    // Cache will be regenerated on next data fetch\n  }, [clearModelCache]);\n\n  // Patch the original isCacheValid function\n  useEffect(() => {\n    // Skip this effect during server-side rendering\n    if (typeof window === 'undefined') return;\n\n    // Store the original isCacheValid function\n    const originalFunc = window.isCacheValid;\n\n    // Define our patched function\n    window.isCacheValid = function patchedIsCacheValid(cache) {\n      // First check if caching is enabled at all\n      const enabled = localStorage.getItem('modelCacheEnabled');\n      if (enabled === 'false') return false;\n      \n      // If enabled, use original validation logic\n      if (typeof originalFunc === 'function') {\n        return originalFunc(cache);\n      }\n      \n      // Fallback implementation if original not available\n      return (\n        cache &&\n        cache.timestamp &&\n        Date.now() - cache.timestamp < 5 * 60 * 1000 &&\n        cache.allModels &&\n        cache.processedModels &&\n        cache.experimentalModels\n      );\n    };\n\n    // Cleanup function to restore original\n    return () => {\n      window.isCacheValid = originalFunc;\n    };\n  }, []);\n\n  // Return state and functions\n  return {\n    cacheEnabled,\n    toggleCache,\n    clearModelCache,\n    refreshModels\n  };\n}; ","export async function fetchWithRetry(input, init = {}, retries = 3, backoff = 500) {\n  let attempt = 0;\n  while (true) {\n    try {\n      const response = await fetch(input, init);\n      if (!response.ok) {\n        throw new Error(`Network error: ${response.status}`);\n      }\n      return response;\n    } catch (error) {\n      if (attempt >= retries) {\n        throw error;\n      }\n      // Exponential backoff with jitter\n      const delay = backoff * Math.pow(2, attempt) + Math.random() * 100;\n      await new Promise(res => setTimeout(res, delay));\n      attempt++;\n    }\n  }\n} ","import { useState, useEffect, useRef, useCallback } from 'react';\n\n/**\n * Custom hook for using localStorage with React state\n * @param {string} key - The localStorage key\n * @param {any} initialValue - The initial value if key doesn't exist\n * @returns {[any, Function]} - State value and setter function\n */\nexport const useLocalStorage = (key, initialValue) => {\n  // Use a ref to hold the initial value to avoid unnecessary state updates\n  const initialValueRef = useRef(initialValue);\n  \n  // Initialize state from localStorage or use initialValue\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from localStorage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or return initialValue\n      return item ? JSON.parse(item) : initialValueRef.current;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValueRef.current;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that\n  // persists the new value to localStorage\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      \n      // Save state\n      setStoredValue(valueToStore);\n      \n      // Save to localStorage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n\n  // Update stored value if key changes\n  useEffect(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      setStoredValue(item ? JSON.parse(item) : initialValueRef.current);\n    } catch (error) {\n      console.error(`Error updating from localStorage key \"${key}\":`, error);\n      setStoredValue(initialValueRef.current);\n    }\n  }, [key]); // Remove initialValue from dependencies\n\n  return [storedValue, setValue];\n};\n\n/**\n * Custom hook for writing to localStorage without React state\n * @param {string} key - The localStorage key\n * @returns {Object} - Methods for accessing localStorage\n */\nexport const useLocalStorageWrite = (key) => {\n  const writeValue = (value) => {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error(`Error writing to localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  const readValue = () => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error(`Error reading from localStorage key \"${key}\":`, error);\n      return null;\n    }\n  };\n\n  const removeValue = () => {\n    try {\n      window.localStorage.removeItem(key);\n      return true;\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n      return false;\n    }\n  };\n\n  return { writeValue, readValue, removeValue };\n}; ","import { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useApi } from './ApiContext';\nimport { useLocalStorage } from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport { useCacheToggle } from '../hooks/useCacheToggle';\n\n// Cache expiry time in milliseconds (5 days)\nconst CACHE_EXPIRY_TIME = 5 * 24 * 60 * 60 * 1000;\n\n// Create separate contexts for models and filtering\nconst ModelContext = createContext();\nconst ModelFilterContext = createContext();\n\n// Custom hook for using model context\nexport const useModel = () => {\n  const context = useContext(ModelContext);\n  if (context === undefined) {\n    throw new Error('useModel must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Custom hook for using model filter context\nexport const useModelFilter = () => {\n  const context = useContext(ModelFilterContext);\n  if (context === undefined) {\n    throw new Error('useModelFilter must be used within a ModelProvider');\n  }\n  return context;\n};\n\n// Model provider component\nexport const ModelProvider = ({ children }) => {\n  const { cacheEnabled } = useCacheToggle();\n  const { apiUrl } = useApi();\n  const { idToken } = useAuth();\n  \n  // State for model data\n  const [allModels, setAllModels] = useState([]);\n  const [processedModels, setProcessedModels] = useState({});\n  const [experimentalModels, setExperimentalModels] = useState([]);\n  const [selectedModel, setSelectedModel] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Filter state - moved to separate context\n  const [showExperimental, setShowExperimental] = useLocalStorage('showExperimental', false);\n  const [modelFilter, setModelFilter] = useState({\n    search: '',\n    categories: {\n      'Chat': true,\n      'Image': true,\n      'Embedding': true\n    }\n  });\n  \n  // Check if cache is valid\n  const isCacheValid = useCallback((cache) => {\n    return (\n      cache &&\n      cache.timestamp &&\n      Date.now() - cache.timestamp < CACHE_EXPIRY_TIME &&\n      cache.allModels &&\n      cache.processedModels &&\n      cache.experimentalModels\n    );\n  }, []);\n  \n  // Expose isCacheValid function for external access\n  useEffect(() => {\n    // Skip during server-side rendering\n    if (typeof window === 'undefined') return;\n    window.isCacheValid = isCacheValid;\n    \n    return () => {\n      delete window.isCacheValid;\n    };\n  }, [isCacheValid]);\n  \n  // Cache models to localStorage\n  const cacheModels = useCallback((data) => {\n    try {\n      const cache = {\n        allModels: data.allModels,\n        processedModels: data.processedModels,\n        experimentalModels: data.experimentalModels,\n        timestamp: Date.now()\n      };\n      \n      localStorage.setItem('modelDropdownCache', JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error caching models:', error);\n    }\n  }, []);\n  \n  // Update category filter\n  const updateCategoryFilter = useCallback((category, isChecked) => {\n    setModelFilter(prev => ({\n      ...prev,\n      categories: {\n        ...prev.categories,\n        [category]: isChecked\n      }\n    }));\n  }, []);\n  \n  // Update search filter\n  const updateSearchFilter = useCallback((searchText) => {\n    setModelFilter(prev => ({\n      ...prev,\n      search: searchText\n    }));\n  }, []);\n  \n  // Select a model\n  const selectModel = useCallback((model) => {\n    // Check if the model is actually different to prevent unnecessary updates\n    if (selectedModel?.id !== model?.id) { \n      setSelectedModel(model);\n    }\n  }, [selectedModel, setSelectedModel]);\n  \n  // Fetch models from API, optionally using auth token or override token\n  const fetchModels = useCallback(async (authRequired = false, overrideToken = null) => {\n    setIsLoading(true);\n    setError(null);\n    \n    console.log(`Fetching models from API (auth: ${authRequired})...`);\n    try {\n      const headers = { 'Accept': 'application/json' };\n      if (authRequired) {\n        // Prefer overrideToken (cached) over current idToken\n        const tokenToUse = overrideToken || idToken;\n        if (tokenToUse) {\n          headers['Authorization'] = `Bearer ${tokenToUse}`;\n        }\n      }\n      const modelsUrl = new URL('/api/models/classified', apiUrl).toString();\n      const response = await fetch(modelsUrl, { headers });\n      console.log('Models response:', response);\n      \n      if (!response.ok) {\n        let errorMsg = `Error fetching models: ${response.status}`;\n        console.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n      \n      const rawData = await response.json();\n      console.log(\"[ModelContext] Spawning worker for model processing...\");\n      // Offload model processing to Web Worker\n      const worker = new Worker(new URL('../workers/modelProcessor.js', import.meta.url), { type: 'module' });\n      worker.postMessage(rawData);\n      worker.onmessage = ({ data: msg }) => {\n        if (msg.error) {\n          console.error('[ModelContext] Worker error:', msg.error);\n          setError(msg.error);\n        } else {\n          const {\n            allModels: fetchedAllModels,\n            processedModels: fetchedProcessedModels,\n            experimentalModels: fetchedExperimentalModels\n          } = msg;\n          if (cacheEnabled) {\n            const rawPrev = localStorage.getItem('modelDropdownCache');\n            let prevCache;\n            try { prevCache = JSON.parse(rawPrev); } catch { prevCache = null; }\n            const changed = !prevCache ||\n              JSON.stringify(prevCache.allModels) !== JSON.stringify(fetchedAllModels) ||\n              JSON.stringify(prevCache.processedModels) !== JSON.stringify(fetchedProcessedModels) ||\n              JSON.stringify(prevCache.experimentalModels) !== JSON.stringify(fetchedExperimentalModels);\n            if (changed) {\n              setAllModels(fetchedAllModels);\n              setProcessedModels(fetchedProcessedModels);\n              setExperimentalModels(fetchedExperimentalModels);\n              cacheModels({ allModels: fetchedAllModels, processedModels: fetchedProcessedModels, experimentalModels: fetchedExperimentalModels });\n            }\n          } else {\n            setAllModels(fetchedAllModels);\n            setProcessedModels(fetchedProcessedModels);\n            setExperimentalModels(fetchedExperimentalModels);\n          }\n          // Initial model selection moved to a separate useEffect\n        }\n        setIsLoading(false);\n        worker.terminate();\n      };\n      worker.onerror = (err) => {\n        console.error('[ModelContext] Worker unexpected error:', err);\n        setError(err.message);\n        setIsLoading(false);\n        worker.terminate();\n      };\n    } catch (err) {\n      console.error('Failed to fetch or process models:', err);\n      setError(err.message || 'Failed to load model data');\n      // Attempt to load from potentially expired cache as a last resort?\n    }\n  }, [apiUrl, cacheModels, idToken, cacheEnabled]);\n  \n  // Initial and auth-triggered model fetching (non-blocking)\n  const initialFetchDoneRef = useRef(false);\n\n  useEffect(() => {\n    if (!initialFetchDoneRef.current) {\n      // Load from cache if enabled\n      if (cacheEnabled) {\n        const rawCache = localStorage.getItem('modelDropdownCache');\n        let parsedCache;\n        try { parsedCache = JSON.parse(rawCache); } catch { parsedCache = null; }\n        if (parsedCache && window.isCacheValid(parsedCache)) {\n          setAllModels(parsedCache.allModels);\n          setProcessedModels(parsedCache.processedModels);\n          setExperimentalModels(parsedCache.experimentalModels);\n          setIsLoading(false);\n        }\n      }\n      // First-time load: check cached token in localStorage\n      let cachedToken = null;\n      try { cachedToken = localStorage.getItem('idToken'); }\n      catch (e) { console.warn('Failed to read cached idToken', e); }\n\n      if (cachedToken) {\n        // Immediate fetch with auth using cached token override\n        fetchModels(true, cachedToken);\n      } else {\n        // Initial fetch without auth\n        fetchModels(false);\n      }\n      initialFetchDoneRef.current = true;\n    } else if (idToken) {\n      // After actual sign-in: fetch fresh models with real auth token\n      fetchModels(true);\n    }\n  }, [idToken, fetchModels, cacheEnabled]);\n  \n  // Set initial model after models are loaded\n  useEffect(() => {\n    // Select first model if none selected and models are loaded\n    if (!selectedModel && allModels.length > 0) {\n      setSelectedModel(allModels[0]);\n    }\n  }, [allModels, selectedModel]);\n  \n  // Create toggleExperimentalModels callback at the top level\n  const toggleExperimentalModels = useCallback(() => {\n    setShowExperimental(prev => !prev);\n  }, [setShowExperimental]);\n  \n  // Main model context value - no filter state\n  const modelValue = useMemo(() => ({\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    isExperimentalModelsEnabled: showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    refreshModels: fetchModels\n  }), [\n    allModels,\n    processedModels,\n    experimentalModels,\n    selectedModel,\n    isLoading,\n    error,\n    showExperimental,\n    toggleExperimentalModels,\n    setShowExperimental,\n    selectModel,\n    fetchModels\n  ]);\n  \n  // Filter context value - only filter-related state\n  const filterValue = useMemo(() => ({\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  }), [\n    modelFilter,\n    updateCategoryFilter,\n    updateSearchFilter\n  ]);\n  \n  return (\n    <ModelContext.Provider value={modelValue}>\n      <ModelFilterContext.Provider value={filterValue}>\n        {children}\n      </ModelFilterContext.Provider>\n    </ModelContext.Provider>\n  );\n}; ","__webpack_require__.O(0, [3428], () => {\n\t[4314,208,2179,3215,304,8457,7112,1569,1141,7187,5114,8398,648,8451,268,6060,610,6716,8990,3542,4644,8467,5419,9937,5174,6572,2360,5433,1327,3189,2500,5932,5444,2412,6017,399,4917,7777,7316,3294,4734,6755,4182,4582,8162,6760,1217,822,4335,6814,2489,9734,5522,5080,1927,9283,8476,5816,4120,7295,237,9104,2993,9889,392,7514,8482,5418,1506,9267,6604,9579].map(__webpack_require__.E);\n}, 5);"],"names":["ThemeContext","createContext","useTheme","context","useContext","undefined","Error","ThemeProvider","_ref","children","theme","setTheme","useState","localStorage","getItem","toggleTheme","useCallback","prevTheme","newTheme","setItem","useEffect","document","body","classList","remove","add","value","useMemo","isDark","_jsx","Provider","PerformanceMetricsContext","usePerformanceMetrics","PerformanceMetricsProvider","setChatHistory","useChatHistory","currentMessageMetrics","setCurrentMessageMetrics","startTime","endTime","elapsedTime","tokenCount","tokensPerSecond","isComplete","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","resetPerformanceMetrics","startPerformanceTimer","prev","Date","now","updatePerformanceMetrics","newTokenCount","arguments","length","tokenInfo","Math","round","prevHistory","newHistory","lastMsg","role","metrics","setTokenMetricsForLastMessage","DEFAULT_SETTINGS","temperature","top_p","max_tokens","frequency_penalty","presence_penalty","streaming","systemPrompt","SettingsContext","useSettings","SettingsProvider","settings","setSettings","useLocalStorage","updateSetting","key","resetSettings","shouldRestrictTemperature","model","requiresFixedTemperature","properties","includes","id","toLowerCase","startsWith","series","getModelAdjustedSettings","PERFORMANCE_MARKS","APP_START","CONTEXT_INIT","COMPONENT_LOAD","IMPORTANT_COMPONENTS_LOADED","FORMATTING_COMPONENTS_LOADED","MODEL_SELECTOR_COMPONENTS_LOADED","FIRST_PAINT","FIRST_CONTENTFUL_PAINT","APP_INTERACTIVE","APP_READY","PERFORMANCE_MEASURES","TOTAL_LOAD","TIME_TO_INTERACTIVE","IMPORTANT_LOAD_TIME","FORMATTING_LOAD_TIME","MODEL_SELECTOR_LOAD_TIME","performanceMonitor","constructor","this","marks","Set","measures","window","trackPaintMetrics","PerformanceObserver","entries","getEntries","forEach","entry","markName","name","performance","mark","measureName","measure","error","observe","entryTypes","startMark","endMark","getMeasures","getEntriesByType","clear","clearMarks","clearMeasures","logMetrics","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","ReactDOM","getElementById","render","React","Suspense","fallback","style","display","justifyContent","alignItems","height","App","reportWebVitals","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","waitingServiceWorker","waiting","event","target","postMessage","type","StreamingEventsContext","useStreamingEvents","StreamingEventsProvider","apiUrl","useApi","selectedModel","useModel","idToken","useAuth","chatHistoryRef","addMessageToHistory","updateChatWithContent","setIsWaitingForResponse","setError","useChatStatus","streamingTextRef","useRef","currentRequestIdRef","abortControllerRef","isStreamingRef","debouncedUpdateChat","debounce","content","streamWorkerUrlRef","streamWorkerRef","getOrCreateStreamWorker","current","Worker","parseStreamChunk","chunk","Promise","resolve","reject","worker","onmessage","e","data","onerror","_updatePlaceholderOnError","lastMessage","existingContent","errorSuffix","streamMessageWithFetch","async","message","editIndex","requestId","crypto","randomUUID","random","toString","substring","isEditing","Number","isInteger","modelId","provider","userMessage","truncated","slice","timestamp","timeoutId","setTimeout","_abortControllerRef$c","abort","abortController","AbortController","adjusted","historyForApi","map","_ref2","m","unshift","push","payload","messages","fetchWithRetry","method","JSON","stringify","signal","cache","ok","reader","getReader","decoder","TextDecoder","accumulatedContent","accumulatedTokens","done","read","clearTimeout","_abortControllerRef$c2","decode","stream","msgs","msg","isDone","flush","stopStreaming","reqId","isStreaming","useCacheToggle","cacheEnabled","setCacheEnabled","clearModelCache","removeItem","toggleCache","enabled","newValue","refreshModels","originalFunc","isCacheValid","allModels","processedModels","experimentalModels","input","init","retries","backoff","attempt","delay","pow","res","initialValue","initialValueRef","storedValue","setStoredValue","item","parse","setValue","valueToStore","ModelContext","ModelFilterContext","useModelFilter","ModelProvider","setAllModels","setProcessedModels","setExperimentalModels","setSelectedModel","isLoading","setIsLoading","showExperimental","setShowExperimental","modelFilter","setModelFilter","search","categories","cacheModels","updateCategoryFilter","category","isChecked","updateSearchFilter","searchText","selectModel","fetchModels","authRequired","overrideToken","tokenToUse","modelsUrl","errorMsg","rawData","json","fetchedAllModels","fetchedProcessedModels","fetchedExperimentalModels","rawPrev","prevCache","terminate","err","initialFetchDoneRef","rawCache","parsedCache","cachedToken","toggleExperimentalModels","modelValue","isExperimentalModelsEnabled","filterValue","__webpack_require__","O","E"],"sourceRoot":""}
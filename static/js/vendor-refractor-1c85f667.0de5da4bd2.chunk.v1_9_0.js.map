{"version":3,"file":"static/js/vendor-refractor-1c85f667.0de5da4bd2.chunk.v1_9_0.js","mappings":"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","sources":["../node_modules/refractor/lang/xquery.js","../node_modules/refractor/lang/wren.js","../node_modules/refractor/lang/xojo.js","../node_modules/refractor/lang/xml-doc.js","../node_modules/refractor/lang/xeora.js"],"sourcesContent":["'use strict'\n\nmodule.exports = xquery\nxquery.displayName = 'xquery'\nxquery.aliases = []\nfunction xquery(Prism) {\n  ;(function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[-\\w:]+/,\n      axis: {\n        pattern:\n          /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern:\n          /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern:\n          /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern:\n          /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n        {\n          pattern: /(\\s)-(?=\\s)/,\n          lookbehind: true\n        }\n      ],\n      punctuation: /[[\\](){},;:/]/\n    })\n    Prism.languages.xquery.tag.pattern =\n      /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern =\n      /=(?:(\"|')(?:\\\\[\\s\\S]|\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] =\n      /^=\"|\"$/\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /\\{(?!\\{)(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}/,\n      inside: Prism.languages.xquery,\n      alias: 'language-xquery'\n    } // The following will handle plain text inside tags\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function (tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{' && // Ignore `{{`\n            (!tokens[i + 1] ||\n              tokens[i + 1].type !== 'punctuation' ||\n              tokens[i + 1].content !== '{') &&\n            (!tokens[i - 1] ||\n              tokens[i - 1].type !== 'plain-text' ||\n              tokens[i - 1].content !== '{')\n          ) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText\n            } else {\n              tokens[i] = new Prism.Token(\n                'plain-text',\n                plainText,\n                null,\n                plainText\n              )\n            }\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = wren\nwren.displayName = 'wren'\nwren.aliases = []\nfunction wren(Prism) {\n  // https://wren.io/\n  Prism.languages.wren = {\n    // Multiline comments in Wren can have nested multiline comments\n    // Comments: // and /* */\n    comment: [\n      {\n        // support 3 levels of nesting\n        // regex: \\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\/\n        pattern:\n          /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*))*\\*\\/)*\\*\\/)*\\*\\//,\n        greedy: true\n      },\n      {\n        pattern: /(^|[^\\\\:])\\/\\/.*/,\n        lookbehind: true,\n        greedy: true\n      }\n    ],\n    // Triple quoted strings are multiline but cannot have interpolation (raw strings)\n    // Based on prism-python.js\n    'triple-quoted-string': {\n      pattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n      greedy: true,\n      alias: 'string'\n    },\n    // see below\n    'string-literal': null,\n    // #!/usr/bin/env wren on the first line\n    hashbang: {\n      pattern: /^#!\\/.+/,\n      greedy: true,\n      alias: 'comment'\n    },\n    // Attributes are special keywords to add meta data to classes\n    attribute: {\n      // #! attributes are stored in class properties\n      // #!myvar = true\n      // #attributes are not stored and dismissed at compilation\n      pattern: /#!?[ \\t\\u3000]*\\w+/,\n      alias: 'keyword'\n    },\n    'class-name': [\n      {\n        // class definition\n        // class Meta {}\n        pattern: /(\\bclass\\s+)\\w+/,\n        lookbehind: true\n      }, // A class must always start with an uppercase.\n      // File.read\n      /\\b[A-Z][a-z\\d_]*\\b/\n    ],\n    // A constant can be a variable, class, property or method. Just named in all uppercase letters\n    constant: /\\b[A-Z][A-Z\\d_]*\\b/,\n    null: {\n      pattern: /\\bnull\\b/,\n      alias: 'keyword'\n    },\n    keyword:\n      /\\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    number: /\\b(?:0x[\\da-f]+|\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?)\\b/i,\n    // Functions can be Class.method()\n    function: /\\b[a-z_]\\w*(?=\\s*[({])/i,\n    operator: /<<|>>|[=!<>]=?|&&|\\|\\||[-+*/%~^&|?:]|\\.{2,3}/,\n    punctuation: /[\\[\\](){}.,;]/\n  }\n  Prism.languages.wren['string-literal'] = {\n    // A single quote string is multiline and can have interpolation (similar to JS backticks ``)\n    pattern:\n      /(^|[^\\\\\"])\"(?:[^\\\\\"%]|\\\\[\\s\\S]|%(?!\\()|%\\((?:[^()]|\\((?:[^()]|\\([^)]*\\))*\\))*\\))*\"/,\n    lookbehind: true,\n    greedy: true,\n    inside: {\n      interpolation: {\n        // \"%(interpolation)\"\n        pattern:\n          /((?:^|[^\\\\])(?:\\\\{2})*)%\\((?:[^()]|\\((?:[^()]|\\([^)]*\\))*\\))*\\)/,\n        lookbehind: true,\n        inside: {\n          expression: {\n            pattern: /^(%\\()[\\s\\S]+(?=\\)$)/,\n            lookbehind: true,\n            inside: Prism.languages.wren\n          },\n          'interpolation-punctuation': {\n            pattern: /^%\\(|\\)$/,\n            alias: 'punctuation'\n          }\n        }\n      },\n      string: /[\\s\\S]+/\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = xojo\nxojo.displayName = 'xojo'\nxojo.aliases = []\nfunction xojo(Prism) {\n  Prism.languages.xojo = {\n    comment: {\n      pattern: /(?:'|\\/\\/|Rem\\b).+/i,\n      greedy: true\n    },\n    string: {\n      pattern: /\"(?:\"\"|[^\"])*\"/,\n      greedy: true\n    },\n    number: [/(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:E[+-]?\\d+)?/i, /&[bchou][a-z\\d]+/i],\n    directive: {\n      pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\\b/i,\n      alias: 'property'\n    },\n    keyword:\n      /\\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\\b/i,\n    operator:\n      /<[=>]?|>=?|[+\\-*\\/\\\\^=]|\\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\\b/i,\n    punctuation: /[.,;:()]/\n  }\n}\n","'use strict'\n\nmodule.exports = xmlDoc\nxmlDoc.displayName = 'xmlDoc'\nxmlDoc.aliases = []\nfunction xmlDoc(Prism) {\n  ;(function (Prism) {\n    /**\n     * If the given language is present, it will insert the given doc comment grammar token into it.\n     *\n     * @param {string} lang\n     * @param {any} docComment\n     */\n    function insertDocComment(lang, docComment) {\n      if (Prism.languages[lang]) {\n        Prism.languages.insertBefore(lang, 'comment', {\n          'doc-comment': docComment\n        })\n      }\n    }\n    var tag = Prism.languages.markup.tag\n    var slashDocComment = {\n      pattern: /\\/\\/\\/.*/,\n      greedy: true,\n      alias: 'comment',\n      inside: {\n        tag: tag\n      }\n    }\n    var tickDocComment = {\n      pattern: /'''.*/,\n      greedy: true,\n      alias: 'comment',\n      inside: {\n        tag: tag\n      }\n    }\n    insertDocComment('csharp', slashDocComment)\n    insertDocComment('fsharp', slashDocComment)\n    insertDocComment('vbnet', tickDocComment)\n  })(Prism)\n}\n","'use strict'\n\nmodule.exports = xeora\nxeora.displayName = 'xeora'\nxeora.aliases = ['xeoracube']\nfunction xeora(Prism) {\n  ;(function (Prism) {\n    Prism.languages.xeora = Prism.languages.extend('markup', {\n      constant: {\n        pattern: /\\$(?:DomainContents|PageRenderDuration)\\$/,\n        inside: {\n          punctuation: {\n            pattern: /\\$/\n          }\n        }\n      },\n      variable: {\n        pattern: /\\$@?(?:#+|[-+*~=^])?[\\w.]+\\$/,\n        inside: {\n          punctuation: {\n            pattern: /[$.]/\n          },\n          operator: {\n            pattern: /#+|[-+*~=^@]/\n          }\n        }\n      },\n      'function-inline': {\n        pattern:\n          /\\$F:[-\\w.]+\\?[-\\w.]+(?:,(?:(?:@[-#]*\\w+\\.[\\w+.]\\.*)*\\|)*(?:(?:[\\w+]|[-#*.~^]+[\\w+]|=\\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\\w+\\.[\\w+.]\\.*)+(?:(?:[\\w+]|[-#*~^][-#*.~^]*[\\w+]|=\\S)(?:[^$=]|=+[^=])*=*)?)?)?\\$/,\n        inside: {\n          variable: {\n            pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\\w.]+/,\n            inside: {\n              punctuation: {\n                pattern: /[,.|]/\n              },\n              operator: {\n                pattern: /#+|[-+*~=^@]/\n              }\n            }\n          },\n          punctuation: {\n            pattern: /\\$\\w:|[$:?.,|]/\n          }\n        },\n        alias: 'function'\n      },\n      'function-block': {\n        pattern:\n          /\\$XF:\\{[-\\w.]+\\?[-\\w.]+(?:,(?:(?:@[-#]*\\w+\\.[\\w+.]\\.*)*\\|)*(?:(?:[\\w+]|[-#*.~^]+[\\w+]|=\\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\\w+\\.[\\w+.]\\.*)+(?:(?:[\\w+]|[-#*~^][-#*.~^]*[\\w+]|=\\S)(?:[^$=]|=+[^=])*=*)?)?)?\\}:XF\\$/,\n        inside: {\n          punctuation: {\n            pattern: /[$:{}?.,|]/\n          }\n        },\n        alias: 'function'\n      },\n      'directive-inline': {\n        pattern: /\\$\\w(?:#\\d+\\+?)?(?:\\[[-\\w.]+\\])?:[-\\/\\w.]+\\$/,\n        inside: {\n          punctuation: {\n            pattern: /\\$(?:\\w:|C(?:\\[|#\\d))?|[:{[\\]]/,\n            inside: {\n              tag: {\n                pattern: /#\\d/\n              }\n            }\n          }\n        },\n        alias: 'function'\n      },\n      'directive-block-open': {\n        pattern:\n          /\\$\\w+:\\{|\\$\\w(?:#\\d+\\+?)?(?:\\[[-\\w.]+\\])?:[-\\w.]+:\\{(?:![A-Z]+)?/,\n        inside: {\n          punctuation: {\n            pattern: /\\$(?:\\w:|C(?:\\[|#\\d))?|[:{[\\]]/,\n            inside: {\n              tag: {\n                pattern: /#\\d/\n              }\n            }\n          },\n          attribute: {\n            pattern: /![A-Z]+$/,\n            inside: {\n              punctuation: {\n                pattern: /!/\n              }\n            },\n            alias: 'keyword'\n          }\n        },\n        alias: 'function'\n      },\n      'directive-block-separator': {\n        pattern: /\\}:[-\\w.]+:\\{/,\n        inside: {\n          punctuation: {\n            pattern: /[:{}]/\n          }\n        },\n        alias: 'function'\n      },\n      'directive-block-close': {\n        pattern: /\\}:[-\\w.]+\\$/,\n        inside: {\n          punctuation: {\n            pattern: /[:{}$]/\n          }\n        },\n        alias: 'function'\n      }\n    })\n    Prism.languages.insertBefore(\n      'inside',\n      'punctuation',\n      {\n        variable: Prism.languages.xeora['function-inline'].inside['variable']\n      },\n      Prism.languages.xeora['function-block']\n    )\n    Prism.languages.xeoracube = Prism.languages.xeora\n  })(Prism)\n}\n"],"names":["xquery","Prism","languages","extend","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language","module","exports","displayName","aliases","wren","comment","hashbang","attribute","constant","null","boolean","interpolation","expression","xojo","directive","xmlDoc","insertDocComment","lang","docComment","insertBefore","markup","slashDocComment","tickDocComment","xeora","xeoracube"],"sourceRoot":""}
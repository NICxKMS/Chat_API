{"version":3,"file":"static/js/chat-messagelist.0899c13687.chunk.v1_8_5.js","mappings":"iKAIA,MAOaA,EAAqBC,IAChC,MAAMC,EAAW,kBAAkBD,KAE5BE,EAAaC,IAAkBC,EAAAA,EAAAA,GAAgBH,EAAU,OACzDI,EAAgBC,IAAqBC,EAAAA,EAAAA,UAAS,OAC9CC,EAASC,IAAcF,EAAAA,EAAAA,WAAS,IAChCG,EAAOC,IAAYJ,EAAAA,EAAAA,UAAS,MAuEnC,OArEAK,EAAAA,EAAAA,YAAU,KACR,IAAIC,GAAY,EAChB,IAAKb,EAIH,OAFAM,EAAkB,WAClBG,GAAW,GAKb,IAAIK,EAAQZ,EACZ,GAAIY,EAAO,CAET,GAAqB,iBAAVA,EAAoB,CAC7B,MAAMC,EAAU,CAAEC,KAAMF,EAAOG,UAAWC,KAAKC,OAC/ChB,EAAeY,GACfD,EAAQC,CACV,CAEA,GACED,EAAMG,WACNC,KAAKC,MAAQL,EAAMG,UApCf,OAqCJH,EAAME,KAIN,OAFAV,EAAkBQ,EAAME,WACxBP,GAAW,GAIbN,EAAe,KACjB,CAkCA,OA/BAM,GAAW,GACXW,MAAMpB,GACHqB,MAAMC,IACL,IAAKA,EAASC,GAAI,MAAM,IAAIC,MAAM,0BAA0BF,EAASG,UACrE,OAAOH,EAASI,MAAM,IAEvBL,MACEK,GACC,IAAIC,SAAQ,CAACC,EAASC,KACpB,MAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,IAAMJ,EAAQE,EAAOG,QACxCH,EAAOI,QAAUL,EACjBC,EAAOK,cAAcT,EAAK,MAG/BL,MAAMe,IACL,IAAKvB,EAAW,OAChB,MAAMwB,EAAe,CAAErB,KAAMoB,EAASnB,UAAWC,KAAKC,OACtDhB,EAAekC,GACf/B,EAAkB8B,EAAQ,IAE3BE,OAAOC,IACD1B,GAELF,EAAS4B,EAAI,IAEdC,SAAQ,KACF3B,GACLJ,GAAW,EAAM,IAGd,KACLI,GAAY,CAAK,CAClB,GACA,CAACb,EAAUE,EAAaC,IAEpB,CAAEE,iBAAgBG,UAASE,QAAO,C,oCCnFpC,MAwTM+B,EAA2BC,IAEtC,GAAoB,iBAATA,GAA8B,KAATA,EAC9B,MAAO,GAOT,MAcMC,EAAgB,IAAIC,OACxB,6HACA,MAIF,IAAIX,EAASS,EAAKG,QAAQF,GAAe,CACvCG,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,SAGgBC,IAAZR,EACKA,OAIaQ,IAAlBP,EAEK,GAAGA,MAAkBC,WAIPM,IAAnBJ,EAEK,GAAGA,MAAmBC,WAING,IAArBD,EAEK,IAAIA,EAAiBE,UAIvBV,IAWT,OAHAb,EAASA,EAAOY,QAAQ,UAAW,QACnCZ,EAASA,EAAOY,QAAQ,UAAW,QAE5BZ,CAAM,C,2GCpXR,SAASwB,EAAWC,GACzB,OAAKA,EACDA,EAAK,IAAa,GAAGA,MAClB,IAAIA,EAAK,KAAMC,QAAQ,MAFd,MAGlB,C,0BCtBA,MAAMC,GAAmBC,EAAAA,EAAAA,OAAK,IAAM,kWAErB,SAASC,EAAoBC,GAAgB,IAAf,SAAEC,GAAUD,EACvD,OACEE,EAAAA,EAAAA,KAACC,EAAAA,SAAQ,CAACC,UAAUF,EAAAA,EAAAA,KAAA,OAAAD,SAAMA,IAAgBA,UACxCC,EAAAA,EAAAA,KAACL,EAAgB,CAAAI,SAAEA,KAGzB,CCFA,MAAMI,GAAmBP,EAAAA,EAAAA,OAAK,IAAM,4uBAGpC,IAAIQ,EACJ,MAiBMC,EAAcP,IAAuG,IAAtG,QAAEQ,EAAO,YAAEC,GAAc,EAAK,cAAEC,EAAgB,KAAI,gBAAEC,EAAkB,KAAI,UAAEC,EAAY,MAAMZ,EAEnH,MAAMa,EAA6B,MAAnBF,EAA0BA,EAAkBH,EAAQK,SAE7DC,EAAeC,IAAoBvE,EAAAA,EAAAA,WAAS,GAC7CwE,GAA0BC,EAAAA,EAAAA,UAAQ,IACrB,cAAjBT,EAAQU,KACJL,GACAnC,EAAAA,EAAAA,IAAwBmC,IAC3B,CAACA,EAASL,EAAQU,QACdC,EAAkBC,IAAuB5E,EAAAA,EAAAA,UAASwE,IAGzDnE,EAAAA,EAAAA,YAAU,KACRuE,EAAoBJ,EAAwB,GAC3C,CAACA,KAEJnE,EAAAA,EAAAA,YAAU,KACR,GAAqB,cAAjB2D,EAAQU,MAA2C,iBAAZL,GAA0C,oBAAXQ,OACxE,OAEF,MAAMC,EAAKd,EAAQtD,UACbqE,GAtCc,oBAAXF,QAA2Bf,IACpCA,EAAY,IAAIe,OAAO,IAAIG,IAAI,mBAAsD,CAAEC,UAAM,KAExFnB,GAoCCoB,EAAiBC,IACjBA,EAAE1E,KAAKqE,KAAOA,IACdK,EAAE1E,KAAK2E,QAASR,EAAoBO,EAAE1E,KAAKA,MAC1CmE,EAAoBP,GAAQ,EAInC,OAFAU,EAAOM,iBAAiB,UAAWH,GACnCH,EAAOO,YAAY,CAAER,KAAIT,YAClB,KACLU,EAAOQ,oBAAoB,UAAWL,EAAc,CACrD,GACA,CAACb,EAASL,EAAQU,KAAMV,EAAQtD,YAGnC,MAAM8E,GAAOf,EAAAA,EAAAA,UAAQ,KACnB,OAAQT,EAAQU,MACd,IAAK,OACH,OAAON,GACHV,EAAAA,EAAAA,KAAA,OAAK+B,IAAKrB,EAAWsB,IAAI,cAAcC,UAAWC,EAAAA,EAAOC,yBACzD,KACN,IAAK,YACH,OAAOnC,EAAAA,EAAAA,KAACoC,EAAAA,IAAW,CAACC,KAAM,GAAIJ,UAAWC,EAAAA,EAAOI,oBAClD,IAAK,SACH,OAAOtC,EAAAA,EAAAA,KAACuC,EAAAA,IAAQ,CAACF,KAAM,GAAIJ,UAAWC,EAAAA,EAAOI,oBAC/C,IAAK,QACH,OAAOtC,EAAAA,EAAAA,KAACwC,EAAAA,IAAS,CAACH,KAAM,GAAIJ,UAAWC,EAAAA,EAAOI,oBAChD,QACE,OAAO,KACX,GACC,CAAChC,EAAQU,KAAMN,IAGZ+B,GAAe1B,EAAAA,EAAAA,UAAQ,KAC3B,OAAQT,EAAQU,MACd,IAAK,OACH,OAAOkB,EAAAA,EAAO,qBAChB,IAAK,YACH,OAAOA,EAAAA,EAAO,0BAChB,IAAK,SACH,OAAOA,EAAAA,EAAO,uBAChB,IAAK,QACH,OAAOA,EAAAA,EAAO,sBAChB,QACE,MAAO,GACX,GACC,CAAC5B,EAAQU,OAGN0B,GAAoB3B,EAAAA,EAAAA,UAAQ,MAEX,cAAjBT,EAAQU,OAAyBV,EAAQqC,UAE5C,CAACrC,EAAQU,KAAMV,EAAQqC,UAGpBC,GAAoBC,EAAAA,EAAAA,cAAY,KACpC,MAAMlC,EAAqC,iBAApBL,EAAQK,QAC3BL,EAAQK,QACRmC,MAAMC,QAAQzC,EAAQK,SACpBL,EAAQK,QACLqC,QAAOC,GAAsB,SAAdA,EAAK1B,OACpB2B,KAAID,GAAQA,EAAKxE,OACjB0E,KAAK,MACR,GACNC,UAAUC,UAAUC,UAAU3C,GAASvD,MAAK,KAC1CyD,GAAiB,GACjB0C,YAAW,IAAM1C,GAAiB,IAAQ,IAAK,GAC/C,GACD,CAACP,EAAQK,UAGN6C,GAAgBzC,EAAAA,EAAAA,UAAQ,KAC5Bf,EAAAA,EAAAA,KAAA,UACEiC,UAAW,GAAGC,EAAAA,EAAOuB,kCACD,cAAjBnD,EAAQU,MAAwB0B,EAAqBR,EAAAA,EAAOwB,wCAA0CxB,EAAAA,EAAOyB,4CAEhHC,QAAShB,EACT,aAAW,eACXiB,MAAM,eAAc9D,SAEnBa,GAAgBZ,EAAAA,EAAAA,KAAC8D,EAAAA,IAAS,CAACzB,KAAM,MAASrC,EAAAA,EAAAA,KAAC+D,EAAAA,IAAQ,CAAC1B,KAAM,QAE5D,CAACO,EAAmBtC,EAAQU,KAAM0B,EAAmB9B,IAGlDoD,GAAkBnB,EAAAA,EAAAA,cAAY,KAC9BrC,GAAeA,EAAcF,EAAQ,GACxC,CAACE,EAAeF,IACb2D,GAAgBlD,EAAAA,EAAAA,UAAQ,IAAuB,SAAjBT,EAAQU,MAC1ChB,EAAAA,EAAAA,KAAA,UACEiC,UAAWC,EAAAA,EAAOgC,+BAClBN,QAASI,EACT,aAAW,eACXH,MAAM,eAAc9D,UAEpBC,EAAAA,EAAAA,KAACmE,EAAAA,IAAU,CAAC9B,KAAM,OAElB,MAAM,CAAC/B,EAAQU,KAAMgD,IAyGzB,OACEI,EAAAA,EAAAA,MAAA,OAAKnC,UAAWC,EAAAA,EAAO7B,YAAc,IAAMoC,EAAa1C,SAAA,EACtDqE,EAAAA,EAAAA,MAAA,OAAKnC,UAAWC,EAAAA,EAAOmC,kBAAkBtE,SAAA,CAEtC+B,IACC9B,EAAAA,EAAAA,KAAA,OAAKiC,UAAWC,EAAAA,EAAOoC,oBAAoBvE,SAAE+B,KAI/CsC,EAAAA,EAAAA,MAAA,OAAKnC,UAAWC,EAAAA,EAAOqC,4BAA4BxE,SAAA,EACjDC,EAAAA,EAAAA,KAACC,EAAAA,SAAQ,CAACC,SAAU,KAAKH,UACvBC,EAAAA,EAAAA,KAAA,OAAKiC,UAAWC,EAAAA,EAAOsC,qBAAqBzE,SACxB,cAAjBO,EAAQU,MACPhB,EAAAA,EAAAA,KAACG,EAAgB,CACfQ,QAASM,EACTV,YAAaA,KAIfP,EAAAA,EAAAA,KAACH,EAAoB,CAAAE,SAClBkB,QAOS,cAAjBX,EAAQU,MAhIKyD,MACpB,IAAK/B,IAAsBpC,EAAQqC,QAAS,OAAO,KAGnD,MAAM+B,EAAenE,GACf,YACJoE,EAAW,WACXC,EAAU,gBACVC,EAAe,iBACfC,EAAgB,aAChBC,EAAY,iBACZC,EAAgB,YAChBC,EAAW,aACXC,GACE5E,EAAQqC,QAcZ,OAViB,MAAfgC,GACc,MAAdC,GACmB,MAAnBC,GACoB,MAApBC,GACgB,MAAhBC,GACoB,MAApBC,GACe,MAAfC,GACgB,MAAhBC,GAMAd,EAAAA,EAAAA,MAAA,OAAKnC,UAAWC,EAAAA,EAAOiD,8BAA8BpF,SAAA,CAE9B,MAApB+E,GAAiD,IAArBA,IAC3BV,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACqF,EAAAA,GAAS,CAAChD,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,gBACpD9F,EAAWsF,MAGb,MAAfH,GAAuC,IAAhBA,IACtBP,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACqF,EAAAA,GAAS,CAAChD,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,eACrD9F,EAAWmF,MAKb,MAAdC,GAAqC,IAAfA,IACrBR,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACoC,EAAAA,IAAW,CAACC,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,WAC3DV,KAGI,MAAhBG,GAAyC,IAAjBA,IACvBX,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACoC,EAAAA,IAAW,CAACC,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,WAC3DP,KAGQ,MAApBC,GAAiD,IAArBA,IAC3BZ,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACoC,EAAAA,IAAW,CAACC,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,eACvDN,KAGD,MAAfC,GAAuC,IAAhBA,IACtBb,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACoC,EAAAA,IAAW,CAACC,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,UAC5DL,KAKQ,MAAnBJ,GAA+C,IAApBA,IAC1BT,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACuF,EAAAA,IAAS,CAAClD,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BAA2B,UAC1DT,EAAgB,UAKX,MAAhBK,GAAyC,KAAjBA,GAAsD,SAA/BA,EAAaM,eAA2D,YAA/BN,EAAaM,gBACpGpB,EAAAA,EAAAA,MAAA,QAAMnC,UAAWC,EAAAA,EAAOkD,oBAAoBrF,SAAA,EAC1CC,EAAAA,EAAAA,KAACwC,EAAAA,IAAS,CAACH,KAAM,GAAIJ,UAAWC,EAAAA,EAAOoD,0BACtCJ,KAGJR,IACCN,EAAAA,EAAAA,MAAA,QAAMnC,UAAW,GAAGC,EAAAA,EAAOkD,uBAAuBlD,EAAAA,EAAOuD,mCAAmC1F,SAAA,EAC1FC,EAAAA,EAAAA,KAAA,QAAMiC,UAAWC,EAAAA,EAAOwD,6BAAmC,mBAM9DlC,KAnEwB,IAoErB,EAgC+BiB,GAGf,SAAjBnE,EAAQU,OAAqC,cAAjBV,EAAQU,OAAyB0B,IAAsBc,QAItE,SAAjBlD,EAAQU,OACPoD,EAAAA,EAAAA,MAAA,OAAKnC,UAAWC,EAAAA,EAAOyD,qBAAqB5F,SAAA,CACzCkE,EACAT,OAGD,EAKVnD,EAAYuF,YAAc,cAmC1B,SAAeC,EAAAA,EAAAA,MAAKxF,G,0BCvUpB,MAqCA,EArCqBP,IAA4B,IAA3B,IAAEiC,EAAG,IAAEC,EAAG,QAAE8D,GAAShG,EACzC,IAAKiC,EAAK,OAAO,KAGjB,MAMMgE,GACJ/F,EAAAA,EAAAA,KAAA,OAAKiC,UAAWC,EAAAA,EAAO8D,aAAcpC,QAASkC,EAAS9E,KAAK,SAAS,aAAW,OAAO6C,MAAM,uBAAsB9D,UACjHC,EAAAA,EAAAA,KAAA,OACE+B,IAAKA,EACLC,IAAKA,EACLC,UAAWC,EAAAA,EAAO+D,oBAClBrC,QAZoBnC,IACxBA,EAAEyE,iBAAiB,MAiBrB,OAAOC,EAAAA,aACLJ,EACAK,SAASC,KACV,E,cChBH,MAAMC,GAAcC,EAAAA,EAAAA,aAAW,CAAAzG,EAAqC0G,KAAS,IAA7C,SAAEC,EAAQ,MAAEhK,EAAK,cAAE+D,GAAeV,EAChE,MAAM,qBAAE4G,IAAyBC,EAAAA,EAAAA,MAE1BjG,EAAWkG,IAAgBtK,EAAAA,EAAAA,UAAS,OAEnCF,eAAgByK,IAAiB/K,EAAAA,EAAAA,GAAkB4E,IACpDoG,EAASC,IAAczK,EAAAA,EAAAA,WAAS,IAAM0K,aAAaC,QAAQ,cAE3DC,EAAiBC,IAAsB7K,EAAAA,EAAAA,UAAS,OAGvDK,EAAAA,EAAAA,YAAU,KACR,IAAKmK,EAAS,OACd,IAAIM,EAqBJ,MApBA,WACE,MAAM,gBAAEC,SAA0B,4GAC5B,mBAAEC,SAA6B,2GAC/BC,EAAOF,IACRE,IACLH,EAAcE,EAAmBC,GAAMC,UACrC,GAAIC,EAAM,CACRb,EAAaa,EAAKC,UAAY,MAC9B,IACE,MAAMC,QAAcF,EAAKG,aACzBb,EAAWY,EACb,CAAE,MACAZ,EAAW,KACb,CACF,MACEH,EAAa,MACbG,EAAW,KACb,IAEH,EAnBD,GAoBO,KAAYK,GAAaA,GAAa,CAAG,GAC/C,CAACN,IAGJ,MAAMe,GAAgB9G,EAAAA,EAAAA,UAAQ,KAC5B,MAAM/C,EAAS,IAAIyI,GAGnB,GAAIhK,EAAO,CACT,MAAMqL,EAAiB7K,KAAKC,MAC5Bc,EAAO+J,KAAK,CACV3G,GAAI0G,EACJ9G,KAAM,QACNL,QAASlE,EACTO,UAAW8K,GAEf,CAEA,OAAO9J,CAAM,GACZ,CAACyI,EAAUhK,IAWd,OACE2H,EAAAA,EAAAA,MAAA4D,EAAAA,SAAA,CAAAjI,SAAA,EACEC,EAAAA,EAAAA,KAAA,OACEiC,UAAWC,EAAAA,EAAOoE,YAClBE,IAAKA,EACL,YAAU,SACV,gBAAc,iBAAgBzG,SAE7B8H,EAAc3E,KAAI,CAAC5C,EAAS2H,KAAW,IAADC,EAErC,MAAMC,EAAgBF,IAAUJ,EAAcO,OAAS,EACjD7H,EAA+B,cAAjBD,EAAQU,MACRmH,GACAzB,KACgB,QAAhBwB,EAAC5H,EAAQqC,eAAO,IAAAuF,GAAfA,EAAiBG,aAGhC,OAAEC,EAAM,KAAE7J,GJlGnB,SAA+BkC,GACpC,IAAKA,EAAS,MAAO,CAAE2H,OAAQ,GAAI7J,KAAMkC,GACzC,GAAImC,MAAMC,QAAQpC,GAAU,CAC1B,MAAM,OAAE2H,EAAM,MAAEC,GAAU5H,EAAQ6H,QAChC,CAACC,EAAKxF,KACc,cAAdA,EAAK1B,KACPkH,EAAIH,OAAOP,KAAK,CACdW,IAAKzF,EAAK0F,UAAUD,IACpB1G,IAAKiB,EAAK0F,UAAU3G,KAAOiB,EAAKjB,KAAO,OAElB,SAAdiB,EAAK1B,MACdkH,EAAIF,MAAMR,KAAK9E,EAAKxE,MAEfgK,IAET,CAAEH,OAAQ,GAAIC,MAAO,KAEvB,MAAO,CAAED,SAAQ7J,KAAM8J,EAAMpF,KAAK,KACpC,CACA,MAAO,CAAEmF,OAAQ,GAAI7J,KAAMkC,EAC7B,CI8EmCiI,CAAsBtI,EAAQK,SAGjDkI,EAAavI,EAAQtD,UACvB,GAAGsD,EAAQU,QAAQV,EAAQtD,aAAaiL,IACxC,GAAG3H,EAAQU,QAAQiH,IAEvB,OACE7D,EAAAA,EAAAA,MAAA,OAAsBnC,UAAWC,EAAAA,EAAO4G,wBAAwB/I,SAAA,CAE5C,SAAjBO,EAAQU,MAAmBsH,EAAOF,OAAS,IAC1CpI,EAAAA,EAAAA,KAAA,OAAKiC,UAAWC,EAAAA,EAAO6G,4BAA4BhJ,SAChDuI,EAAOpF,KAAI,CAAC8F,EAAOC,KAClBjJ,EAAAA,EAAAA,KAAA,OAEE+B,IAAKiH,EAAMN,IACX1G,IAAKgH,EAAMhH,KAAO,kBAAkBiH,EAAW,IAC/ChH,UAAW,GAAGC,EAAAA,EAAOgH,6BAA6BhH,EAAAA,EAAOiH,8BACzDvF,QAASA,KAAMwF,OA3CTrH,EA2C0BiH,EAAMN,SA1CxDvB,EAAmBpF,GADKA,KA2CqC,GAJtC,GAAG8G,SAAkBI,UAUhCxK,GAAyB,SAAjB6B,EAAQU,QAChBhB,EAAAA,EAAAA,KAACK,EAAW,CACVC,QAASA,EACTG,gBAAiBhC,QAAQa,EACzBiB,YAAaA,EACbC,cAAgC,SAAjBF,EAAQU,KAAkBR,OAAgBlB,EACzDoB,UAA4B,SAAjBJ,EAAQU,MAAmB8F,EAAWD,GAAgBnG,OAAapB,MAtB1EuJ,EAyBJ,MAMX3B,IACClH,EAAAA,EAAAA,KAACgG,EAAY,CACXjE,IAAKmF,EACLlF,IAAI,gBACJ8D,QAhEmBuD,KACzBlC,EAAmB,KAAK,MAkErB,IAIPb,EAAYV,YAAc,cAQ1B,SAAeC,EAAAA,EAAAA,MAAKS,E","sources":["hooks/useProfilePicture.js","utils/formatters.js","utils/messageHelpers.js","components/common/LazyMarkdownRenderer/index.js","components/chat/ChatMessage/index.js","components/common/ImageOverlay/index.js","components/chat/MessageList/index.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { useLocalStorage } from './useLocalStorage';\n\n// Time-to-live for cache entries (1 day in milliseconds)\nconst TTL = 24 * 60 * 60 * 1000;\n\n/**\n * Custom hook to fetch and cache user profile picture with a 1-day TTL.\n * @param {string} imageUrl - The URL to fetch the profile picture from.\n * @returns {{ profilePicture: string | null, loading: boolean, error: any }}\n */\nexport const useProfilePicture = (imageUrl) => {\n  const cacheKey = `profilePicture_${imageUrl}`;\n  // cachedEntry is either null, a string (legacy), or { data, timestamp }\n  const [cachedEntry, setCachedEntry] = useLocalStorage(cacheKey, null);\n  const [profilePicture, setProfilePicture] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (!imageUrl) {\n      // No URL: clear state\n      setProfilePicture(null);\n      setLoading(false);\n      return;\n    }\n\n    // Validate cache entry\n    let entry = cachedEntry;\n    if (entry) {\n      // Legacy format: string\n      if (typeof entry === 'string') {\n        const wrapped = { data: entry, timestamp: Date.now() };\n        setCachedEntry(wrapped);\n        entry = wrapped;\n      }\n      // TTL check\n      if (\n        entry.timestamp &&\n        Date.now() - entry.timestamp < TTL &&\n        entry.data\n      ) {\n        setProfilePicture(entry.data);\n        setLoading(false);\n        return;\n      }\n      // Expired cache\n      setCachedEntry(null);\n    }\n\n    // Fetch and cache new image\n    setLoading(true);\n    fetch(imageUrl)\n      .then((response) => {\n        if (!response.ok) throw new Error(`Failed to fetch image: ${response.status}`);\n        return response.blob();\n      })\n      .then(\n        (blob) =>\n          new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n          })\n      )\n      .then((dataUrl) => {\n        if (!isMounted) return;\n        const entryToCache = { data: dataUrl, timestamp: Date.now() };\n        setCachedEntry(entryToCache);\n        setProfilePicture(dataUrl);\n      })\n      .catch((err) => {\n        if (!isMounted) return;\n        console.error('Error fetching and caching profile image:', err);\n        setError(err);\n      })\n      .finally(() => {\n        if (!isMounted) return;\n        setLoading(false);\n      });\n\n    return () => {\n      isMounted = false;\n    };\n  }, [imageUrl, cachedEntry, setCachedEntry]);\n\n  return { profilePicture, loading, error };\n}; ","/**\n * Formats URLs in text into clickable links\n * @param {string} text - Input text that may contain URLs\n * @returns {string} - Text with URLs wrapped in <a> tags\n */\nexport const formatUrls = (text) => {\n  if (!text) return '';\n  \n  // URL regex pattern - improved to handle more URL formats\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  \n  // Replace URLs with anchor tags\n  return text.replace(urlPattern, (url) => {\n    const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n    return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n  });\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} text - Input text that may contain HTML characters\n * @returns {string} - Text with HTML characters escaped\n */\nexport const escapeHtml = (text) => {\n  if (!text) return '';\n  \n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  return text.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n};\n\n/**\n * Processes a string of text to identify and format code blocks\n * with improved language detection and formatting\n * @param {string} content - Input text which may contain code blocks delimited by ```\n * @returns {string} - Formatted HTML with code blocks properly wrapped\n */\nexport const processCodeBlocks = (content) => {\n  if (!content) return '';\n  \n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Add text before code block\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      parts.push(wrapTextInParagraphs(textBefore));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Add remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    parts.push(wrapTextInParagraphs(textAfter));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Normalizes language identifiers for syntax highlighting\n * @param {string} lang - Raw language identifier from markdown\n * @returns {string} - Normalized language identifier\n */\nexport const normalizeLanguageId = (lang) => {\n  // Handle common aliases and normalize language IDs\n  const languageMap = {\n    'js': 'javascript',\n    'ts': 'typescript',\n    'jsx': 'jsx',\n    'tsx': 'tsx',\n    'py': 'python',\n    'rb': 'ruby',\n    'sh': 'bash',\n    'bash': 'bash',\n    'shell': 'bash',\n    'zsh': 'bash',\n    'c': 'c',\n    'cpp': 'cpp',\n    'cs': 'csharp',\n    'java': 'java',\n    'go': 'go',\n    'rust': 'rust',\n    'php': 'php',\n    'html': 'html',\n    'css': 'css',\n    'scss': 'scss',\n    'sql': 'sql',\n    'json': 'json',\n    'yaml': 'yaml',\n    'yml': 'yaml',\n    'md': 'markdown',\n    'tex': 'latex',\n    'kotlin': 'kotlin',\n    'swift': 'swift',\n    'plaintext': 'plaintext',\n    'txt': 'plaintext',\n    '': 'plaintext'\n  };\n  \n  return languageMap[lang.toLowerCase()] || lang.toLowerCase() || 'plaintext';\n};\n\n/**\n * Wraps text in paragraph tags, respecting existing paragraph breaks\n * with support for markdown formatting\n * @param {string} text - Input text to be wrapped in paragraphs\n * @returns {string} - Text wrapped in paragraph tags\n */\nexport const wrapTextInParagraphs = (text) => {\n  if (!text) return '';\n  \n  // Use a single-pass approach with string concatenation\n  let result = '';\n  let currentParagraph = '';\n  let consecutiveBreaks = 0;\n  \n  // Process each character to identify paragraph breaks\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '\\n') {\n      consecutiveBreaks++;\n      \n      // Add <br> for single breaks\n      if (consecutiveBreaks === 1) {\n        currentParagraph += '<br>';\n      }\n      // Start a new paragraph for double breaks\n      else if (consecutiveBreaks === 2) {\n        // Close the current paragraph if not empty\n        if (currentParagraph) {\n          result += `<p>${currentParagraph}</p>`;\n          currentParagraph = '';\n        }\n        consecutiveBreaks = 0;\n      }\n    } else {\n      // Reset consecutive breaks counter for non-newline characters\n      consecutiveBreaks = 0;\n      currentParagraph += text[i];\n    }\n  }\n  \n  // Add the last paragraph if there's any content left\n  if (currentParagraph) {\n    result += `<p>${currentParagraph}</p>`;\n  }\n  \n  // If no paragraphs were created, wrap the entire text\n  if (!result && text) {\n    result = `<p>${text}</p>`;\n  }\n  \n  return result;\n};\n\n/**\n * Detects and formats Markdown tables in text\n * @param {string} text - Text that may contain Markdown tables\n * @returns {string} - Text with tables converted to HTML\n */\nexport const formatMarkdownTables = (text) => {\n  if (!text) return '';\n  \n  // Regex to match markdown tables\n  const tableRegex = /(\\|[^\\n]+\\|\\n)((?:\\|[ :]*[-:]+[ :]*)+\\|)(\\n(?:\\|[^\\n]+\\|\\n?)*)/g;\n  \n  return text.replace(tableRegex, (match, headerRow, separatorRow, bodyRows) => {\n    // Process the header row\n    const headers = headerRow.trim().split('|').slice(1, -1).map(cell => cell.trim());\n    \n    // Process the alignment row (determines column alignment)\n    const alignments = separatorRow.trim().split('|').slice(1, -1).map(cell => {\n      const trimmed = cell.trim();\n      if (trimmed.startsWith(':') && trimmed.endsWith(':')) return 'center';\n      if (trimmed.endsWith(':')) return 'right';\n      return 'left';\n    });\n    \n    // Process the body rows\n    const rows = bodyRows.trim().split('\\n').map(row => \n      row.trim().split('|').slice(1, -1).map(cell => cell.trim())\n    );\n    \n    // Build the HTML table\n    let tableHtml = '<div class=\"table-wrapper\"><table>';\n    \n    // Add header\n    tableHtml += '<thead><tr>';\n    headers.forEach((header, index) => {\n      const align = alignments[index] || 'left';\n      tableHtml += `<th style=\"text-align: ${align}\">${escapeHtml(header)}</th>`;\n    });\n    tableHtml += '</tr></thead>';\n    \n    // Add body\n    tableHtml += '<tbody>';\n    rows.forEach(row => {\n      tableHtml += '<tr>';\n      row.forEach((cell, index) => {\n        const align = alignments[index] || 'left';\n        tableHtml += `<td style=\"text-align: ${align}\">${escapeHtml(cell)}</td>`;\n      });\n      tableHtml += '</tr>';\n    });\n    tableHtml += '</tbody></table></div>';\n    \n    return tableHtml;\n  });\n};\n\n/**\n * Complete message content formatting pipeline with enhanced markdown support\n * @param {string} content - Raw message content\n * @returns {string} - Fully formatted HTML\n */\nexport const formatMessageContent = (content) => {\n  if (!content) return '';\n  \n  // Process in a single pass through the content\n  const htmlEntities = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  \n  // URL regex pattern\n  const urlPattern = /(https?:\\/\\/[^\\s'\")<>]+)(?=[.,:;!?]*(\\s|$|<))/g;\n  const codeBlockRegex = /```([\\w-]*)\\n?([\\s\\S]*?)```/g;\n  \n  const parts = [];\n  let lastIndex = 0;\n  let match;\n  \n  // Find all code blocks\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    // Process text before code block: escape HTML and format URLs\n    if (match.index > lastIndex) {\n      const textBefore = content.substring(lastIndex, match.index);\n      const escapedText = textBefore.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n      const formattedText = escapedText.replace(urlPattern, (url) => {\n        const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n        return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n      });\n      parts.push(wrapTextInParagraphs(formattedText));\n    }\n    \n    // Get language and code\n    const language = match[1].trim() || 'plaintext';\n    const code = match[2].trim();\n    \n    // Normalize language identifier\n    const normalizedLanguage = normalizeLanguageId(language);\n    \n    // Add formatted code block with escaped code\n    parts.push(\n      `<pre><code class=\"language-${normalizedLanguage}\">${escapeHtml(code)}</code></pre>`\n    );\n    \n    lastIndex = match.index + match[0].length;\n  }\n  \n  // Process remaining text after last code block\n  if (lastIndex < content.length) {\n    const textAfter = content.substring(lastIndex);\n    const escapedText = textAfter.replace(/[&<>\"']/g, (char) => htmlEntities[char]);\n    const formattedText = escapedText.replace(urlPattern, (url) => {\n      const cleanUrl = url.replace(/[.,;:!?]+$/, ''); // Clean trailing punctuation\n      return `<a href=\"${cleanUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${cleanUrl}</a>`;\n    });\n    \n    // Format tables in the remaining text\n    const textWithTables = formatMarkdownTables(formattedText);\n    \n    parts.push(wrapTextInParagraphs(textWithTables));\n  }\n  \n  return parts.join('');\n};\n\n/**\n * Converts LaTeX-style math delimiters to Markdown-style dollar delimiters ($...$ and $$...$$).\n * Optimized for performance on larger inputs using a single regex pass.\n * Handles common LaTeX formats like \\(...\\) and \\[...\\], plus a custom block format [/.../].\n * Avoids conversion within ```code fences```.\n * Replaces block delimiters with $$...$$ exactly in place, preserving original outer indentation\n * and the exact whitespace/newline structure around the content for Markdown parser compatibility.\n * Removes text trailing the closing block delimiters (\\] or /]).\n *\n * @param {string} text The input text possibly containing LaTeX math.\n * @returns {string} Text with math delimiters converted for Markdown processors like KaTeX/MathJax.\n */\nexport const convertTeXToMathDollars = (text) => {\n  // Early exit for empty or non-string input\n  if (typeof text !== 'string' || text === '') {\n    return '';\n  }\n\n  // --- Regex Component Definitions ---\n  // Note: Escaping is doubled because these strings are passed to the RegExp constructor.\n\n  // Group 1: Code block (```...```)\n  const codeBlock = '(```[\\\\s\\\\S]*?```)';\n\n  // Group 2: Indent for \\[...], Group 3: Content for \\[...], Group 4: Trailing text for \\[...\\]\n  // eslint-disable-next-line no-useless-escape\n  const blockTex = '^(\\\\s*)\\\\\\\\\\\\\\[([\\\\s\\\\S]*?)\\\\\\\\\\\\](.*)'; // Matches \\[ content \\]\n\n  // Group 5: Indent for [/...], Group 6: Content for [/...], Group 7: Trailing text for [/...]\n  const blockCustom = '^(\\\\s*)\\\\[\\\\\\\\/([\\\\s\\\\S]*?)\\\\\\\\/](.*)'; // Matches [/ content /]\n\n  // Group 8: Content for \\(...) (handles surrounding whitespace)\n  const inlineTex = '\\\\\\\\\\\\(\\\\s*(.*?)\\\\s*\\\\\\\\\\\\)'; // Matches \\( content \\)\n\n  // --- Combined Regex ---\n  // Joins patterns with '|' (OR) for a single pass. 'gm' flags are crucial.\n  const combinedRegex = new RegExp(\n    `${codeBlock}|${blockTex}|${blockCustom}|${inlineTex}`,\n    'gm'\n  );\n\n  // --- Single Replace Operation ---\n  let result = text.replace(combinedRegex, (\n    match, // The entire matched string (unused but required by replace)\n    // Captured Groups (undefined if the corresponding pattern part didn't match):\n    g1_code,        // Group 1: Code block content\n    g2_bTexIndent,  // Group 2: Indentation before \\[\n    g3_bTexContent, // Group 3: Content inside \\[...]\n    g4_bTexTrail,   // Group 4: Trailing text after \\]\n    g5_bCustIndent, // Group 5: Indentation before [/\n    g6_bCustContent,// Group 6: Content inside [/...]\n    g7_bCustTrail,  // Group 7: Trailing text after /]\n    g8_inlineContent// Group 8: Content inside \\(...) including surrounding space captured by \\s*\n  ) => {\n    // Case 1: Code block matched - return unmodified\n    if (g1_code !== undefined) {\n      return g1_code;\n    }\n\n    // Case 2: Standard block math \\[...] matched - perform in-place replacement\n    if (g2_bTexIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g4 is discarded)\n      return `${g2_bTexIndent}$$${g3_bTexContent}$$`;\n    }\n\n    // Case 3: Custom block math [/...] matched - perform in-place replacement\n    if (g5_bCustIndent !== undefined) {\n      // Return: preserved indent + $$ + exact content + $$ (trailing text g7 is discarded)\n      return `${g5_bCustIndent}$$${g6_bCustContent}$$`;\n    }\n\n    // Case 4: Inline math \\(...) matched - trim content\n    if (g8_inlineContent !== undefined) {\n      // Return: $ + trimmed content + $\n      return `$${g8_inlineContent.trim()}$`;\n    }\n\n    // Fallback (should not happen with a correct regex, but safe practice)\n    return match;\n  });\n\n  // --- Final Cleanup ---\n  // Optional: Reduce excessive newlines (run last).\n  // This step is separate as it cleans up potentially pre-existing blank lines\n  // and doesn't depend on the specific match type from the main regex.\n  // Running it twice is a simple, usually sufficient way to handle sequences > 4 newlines.\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n  result = result.replace(/\\n{3,}/g, '\\n\\n');\n\n  return result;\n};","export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","import React, { lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\n\n// Lazy-load the heavy Markdown renderer only when first used\nconst MarkdownRenderer = lazy(() => import(/* webpackChunkName: \"markdown-renderer\", webpackPrefetch: true */ './MarkdownRenderer'));\n\nexport default function LazyMarkdownRenderer({ children }) {\n  return (\n    <Suspense fallback={<div>{children}</div>}>\n      <MarkdownRenderer>{children}</MarkdownRenderer>\n    </Suspense>\n  );\n}\n\nLazyMarkdownRenderer.propTypes = {\n  children: PropTypes.node.isRequired\n}; ","// eslint-disable import/first\nimport React, { memo, useMemo, useState, useEffect, useCallback, lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport { CopilotIcon, GearIcon, AlertIcon, CheckIcon, CopyIcon, ClockIcon, PulseIcon, PencilIcon } from '@primer/octicons-react';\nimport styles from './ChatMessage.module.css';\nimport { formatTime } from '../../../utils/messageHelpers';\nimport { convertTeXToMathDollars } from '../../../utils/formatters';\n// Lazy-load Markdown renderer for user/system/error messages\nimport LazyMarkdownRenderer from '../../common/LazyMarkdownRenderer';\n// Dynamically load StreamingMessage to defer heavy modules\nconst StreamingMessage = lazy(() => import(/* webpackChunkName: \"streaming-message\", webpackPrefetch: true */ './StreamingMessage'));\n\n// Add a module-level singleton for the TeX worker so we only load the worker script once\nlet texWorker;\nconst getTexWorker = () => {\n  if (typeof Worker !== 'undefined' && !texWorker) {\n    texWorker = new Worker(new URL('../../../workers/texProcessor.js', import.meta.url), { type: 'module' });\n  }\n  return texWorker;\n};\n\n/**\n * ChatMessage component with optimized rendering for streaming content\n * @param {Object} props - Component props\n * @param {string} props.role - Message role (user, assistant, system, error)\n * @param {string} props.content - Message content\n * @param {number} props.index - Message index in the chat history\n * @param {boolean} props.isStreaming - Whether this message is currently streaming\n * @param {string} props.avatarUrl - Optional URL for user avatar image\n * @returns {JSX.Element} - Rendered component\n */\nconst ChatMessage = ({ message, isStreaming = false, onEditMessage = null, overrideContent = null, avatarUrl = null }) => {\n  // Use overrideContent if provided, else fall back to message.content\n  const content = overrideContent != null ? overrideContent : message.content;\n\n  const [messageCopied, setMessageCopied] = useState(false);\n  const defaultProcessedMessage = useMemo(() => (\n    message.role === 'assistant'\n      ? content\n      : convertTeXToMathDollars(content)\n  ), [content, message.role]);\n  const [processedMessage, setProcessedMessage] = useState(defaultProcessedMessage);\n\n  // Update processedMessage whenever the underlying content changes (e.g., after editing)\n  useEffect(() => {\n    setProcessedMessage(defaultProcessedMessage);\n  }, [defaultProcessedMessage]);\n\n  useEffect(() => {\n    if (message.role !== 'assistant' || typeof content !== 'string' || typeof Worker === 'undefined') {\n      return;\n    }\n    const id = message.timestamp;\n    const worker = getTexWorker();\n    const handleMessage = (e) => {\n      if (e.data.id !== id) return;\n      if (e.data.success) setProcessedMessage(e.data.data);\n      else setProcessedMessage(content);\n    };\n    worker.addEventListener('message', handleMessage);\n    worker.postMessage({ id, content });\n    return () => {\n      worker.removeEventListener('message', handleMessage);\n    };\n  }, [content, message.role, message.timestamp]);\n  \n  // Choose appropriate icon based on message role\n  const icon = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return avatarUrl\n          ? <img src={avatarUrl} alt=\"User avatar\" className={styles.ChatMessage__avatarImg} />\n          : null;\n      case 'assistant':\n        return <CopilotIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'system':\n        return <GearIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'error':\n        return <AlertIcon size={16} className={styles.ChatMessage__icon} />;\n      default:\n        return null;\n    }\n  }, [message.role, avatarUrl]);\n  \n  // Select CSS classes based on message role\n  const messageClass = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return styles['ChatMessage--user'];\n      case 'assistant':\n        return styles['ChatMessage--assistant'];\n      case 'system':\n        return styles['ChatMessage--system'];\n      case 'error':\n        return styles['ChatMessage--error'];\n      default:\n        return '';\n    }\n  }, [message.role]);\n  \n  // Determine if we should show metrics (only for assistant messages)\n  const shouldShowMetrics = useMemo(() => {\n    // Show metrics if this is an assistant message with any metrics\n    if (message.role !== 'assistant' || !message.metrics) return false;\n    return true;\n  }, [message.role, message.metrics]);\n  \n  // Copy message content to clipboard\n  const handleCopyMessage = useCallback(() => {\n    const content = typeof message.content === 'string' \n      ? message.content \n      : Array.isArray(message.content) \n        ? message.content\n            .filter(part => part.type === 'text')\n            .map(part => part.text)\n            .join('\\n')\n        : '';\n    navigator.clipboard.writeText(content).then(() => {\n      setMessageCopied(true);\n      setTimeout(() => setMessageCopied(false), 2000);\n    });\n  }, [message.content]);\n  \n  // === BUTTON JSX (Moved here for reuse) ===\n  const copyButtonJsx = useMemo(() => (\n    <button\n      className={`${styles.ChatMessage__copyMessageButton} ${\n        (message.role === 'assistant' && shouldShowMetrics) ? styles.ChatMessage__copyMessageButtonInMetrics : styles.ChatMessage__copyMessageButtonBottomRight\n      }`}\n      onClick={handleCopyMessage}\n      aria-label=\"Copy message\"\n      title=\"Copy message\"\n    >\n      {messageCopied ? <CheckIcon size={16} /> : <CopyIcon size={16} />}\n    </button>\n  ), [handleCopyMessage, message.role, shouldShowMetrics, messageCopied]);\n\n  // Edit button only for user messages\n  const handleEditClick = useCallback(() => {\n    if (onEditMessage) onEditMessage(message);\n  }, [onEditMessage, message]);\n  const editButtonJsx = useMemo(() => message.role === 'user' ? (\n    <button\n      className={styles.ChatMessage__editMessageButton}\n      onClick={handleEditClick}\n      aria-label=\"Edit message\"\n      title=\"Edit message\"\n    >\n      <PencilIcon size={16} />\n    </button>\n  ) : null, [message.role, handleEditClick]);\n  // ==========================================\n  \n  // Render performance metrics (only for assistant messages)\n  const renderMetrics = () => {\n    if (!shouldShowMetrics || !message.metrics) return null;\n    \n    // Use the specific isStreaming prop passed down to determine if THIS message is generating\n    const isGenerating = isStreaming;\n    const { \n      elapsedTime, \n      tokenCount, \n      tokensPerSecond, \n      timeToFirstToken, \n      promptTokens, \n      completionTokens, \n      totalTokens,\n      finishReason \n    } = message.metrics;\n    \n    // Check if we have any valid metrics to show\n    const hasValidMetrics = \n      elapsedTime != null || \n      tokenCount != null || \n      tokensPerSecond != null || \n      timeToFirstToken != null ||\n      promptTokens != null ||\n      completionTokens != null ||\n      totalTokens != null ||\n      finishReason != null;\n      \n    // Don't render anything if no valid metrics are found\n    if (!hasValidMetrics) return null;\n    \n    return (\n      <div className={styles.ChatMessage__metricsContainer}>\n        {/* Time metrics */}\n        {timeToFirstToken != null && timeToFirstToken !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            First Token: {formatTime(timeToFirstToken)}\n          </span>\n        )}\n        {elapsedTime != null && elapsedTime !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total Time: {formatTime(elapsedTime)}\n          </span>\n        )}\n        \n        {/* Token metrics */}\n        {tokenCount != null && tokenCount !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Tokens: {tokenCount}\n          </span>\n        )}\n        {promptTokens != null && promptTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Prompt: {promptTokens}\n          </span>\n        )}\n        {completionTokens != null && completionTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Completion: {completionTokens}\n          </span>\n        )}\n        {totalTokens != null && totalTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total: {totalTokens}\n          </span>\n        )}\n        \n        {/* Speed metrics */}\n        {tokensPerSecond != null && tokensPerSecond !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <PulseIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Speed: {tokensPerSecond} t/s\n          </span>\n        )}\n        \n        {/* Status (only show if meaningful) */}\n        {finishReason != null && finishReason !== '' && finishReason.toLowerCase() !== 'stop' && finishReason.toLowerCase() !== 'unknown' && (\n          <span className={styles.ChatMessage__metric}>\n            <AlertIcon size={14} className={styles.ChatMessage__metricIcon} />\n            {finishReason}\n          </span>\n        )}\n        {isGenerating && (\n          <span className={`${styles.ChatMessage__metric} ${styles.ChatMessage__generatingIndicator}`}>\n            <span className={styles.ChatMessage__generatingDot}></span>\n            Generating...\n          </span>\n        )}\n        \n        {/* Copy button */}\n        {copyButtonJsx}\n      </div>\n    );\n  };\n  \n  // Main return\n  return (\n    <div className={styles.ChatMessage + ' ' + messageClass}>\n      <div className={styles.ChatMessage__body}>\n        {/* Avatar (only render if icon exists) */}\n        {icon && (\n          <div className={styles.ChatMessage__avatar}>{icon}</div>\n        )}\n\n        {/* Message content section */}\n        <div className={styles.ChatMessage__contentWrapper}>\n          <Suspense fallback={null}>\n            <div className={styles.ChatMessage__content}>\n              {message.role === 'assistant' ? (\n                <StreamingMessage\n                  content={processedMessage}\n                  isStreaming={isStreaming}\n                />\n              ) : (\n                // Render markdown lazily for user/system/error messages\n                <LazyMarkdownRenderer>\n                  {processedMessage}\n                </LazyMarkdownRenderer>\n              )}\n            </div>\n          </Suspense>\n\n          {/* Render performance metrics for assistant messages */}\n          {message.role === 'assistant' && renderMetrics()}\n\n          {/* Copy button for non-user messages, hide when assistant metrics exist */}\n          {message.role !== 'user' && (message.role !== 'assistant' || !shouldShowMetrics) && copyButtonJsx}\n        </div>\n      </div>\n\n      {message.role === 'user' && (\n        <div className={styles.ChatMessage__actions}>\n          {editButtonJsx}\n          {copyButtonJsx}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Display name\nChatMessage.displayName = 'ChatMessage';\n\n// PropTypes\nChatMessage.propTypes = {\n  message: PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    role: PropTypes.oneOf(['user', 'assistant', 'system', 'error']).isRequired,\n    content: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.shape({ // Support complex content\n        type: PropTypes.string.isRequired,\n        text: PropTypes.string,\n        image_url: PropTypes.shape({\n          url: PropTypes.string.isRequired\n        })\n      }))\n    ]).isRequired,\n    timestamp: PropTypes.number.isRequired,\n    metrics: PropTypes.shape({\n      elapsedTime: PropTypes.number,\n      tokenCount: PropTypes.number,\n      tokensPerSecond: PropTypes.number,\n      timeToFirstToken: PropTypes.number,\n      promptTokens: PropTypes.number,\n      completionTokens: PropTypes.number,\n      totalTokens: PropTypes.number,\n      finishReason: PropTypes.string\n    })\n  }).isRequired,\n  isStreaming: PropTypes.bool,\n  onEditMessage: PropTypes.func,\n  overrideContent: PropTypes.string, // Optional override for rendering previews\n  avatarUrl: PropTypes.string, // Optional URL for user avatar image\n};\n\nexport default memo(ChatMessage); ","import ReactDOM from 'react-dom'; // Import ReactDOM\nimport PropTypes from 'prop-types';\nimport styles from './ImageOverlay.module.css';\n\n/**\n * Full-screen overlay for displaying an image using React Portal.\n * Clicking anywhere on the overlay closes it.\n */\nconst ImageOverlay = ({ src, alt, onClose }) => {\n  if (!src) return null;\n\n  // Prevent clicks on the image itself from closing if needed (optional)\n  const handleImageClick = (e) => {\n    e.stopPropagation(); // Prevents the overlay click handler from firing\n    // Could potentially add other actions here, like zoom controls\n  };\n\n  // The overlay content\n  const overlayContent = (\n    <div className={styles.ImageOverlay} onClick={onClose} role=\"dialog\" aria-modal=\"true\" title=\"Click to close image\">\n      <img \n        src={src} \n        alt={alt} \n        className={styles.ImageOverlay__image}\n        onClick={handleImageClick} // Handle clicks on the image specifically\n      />\n    </div>\n  );\n\n  // Use ReactDOM.createPortal to render the overlay into document.body\n  return ReactDOM.createPortal(\n    overlayContent,\n    document.body \n  );\n};\n\nImageOverlay.propTypes = {\n  /** The URL of the image to display */\n  src: PropTypes.string.isRequired,\n  /** The alt text for the image */\n  alt: PropTypes.string.isRequired,\n  /** Function to call when the overlay should be closed */\n  onClose: PropTypes.func.isRequired,\n};\n\nexport default ImageOverlay; ","import { forwardRef, useState, useMemo, memo, useEffect } from 'react';\nimport styles from './MessageList.module.css';\nimport { useChatState } from '../../../contexts/ChatStateContext';\nimport ChatMessage from '../ChatMessage';\nimport ImageOverlay from '../../common/ImageOverlay';\nimport PropTypes from 'prop-types';\nimport { processMessageContent } from '../../../utils/messageHelpers';\nimport { useProfilePicture } from '../../../hooks/useProfilePicture';\n\n/**\n * Simple message list without virtualization\n * @param {Object} props - Component props\n * @param {Array} props.messages - Array of message objects\n * @param {string} props.error - Error message to display\n * @param {Function} props.onEditMessage - Function to handle message edit requests\n * @returns {JSX.Element} - Rendered component\n */\nconst MessageList = forwardRef(({ messages, error, onEditMessage }, ref) => {\n  const { isWaitingForResponse } = useChatState();\n  // Local state for dynamic auth values\n  const [avatarUrl, setAvatarUrl] = useState(null);\n  // Use hook to fetch and cache avatar Data URL\n  const { profilePicture: cachedAvatar } = useProfilePicture(avatarUrl);\n  const [idToken, setIdToken] = useState(() => localStorage.getItem('idToken'));\n\n  const [overlayImageSrc, setOverlayImageSrc] = useState(null);\n\n  // Dynamically import Firebase auth only if a token is already cached\n  useEffect(() => {\n    if (!idToken) return;\n    let unsubscribe;\n    (async () => {\n      const { getFirebaseAuth } = await import('../../../firebaseConfig');\n      const { onAuthStateChanged } = await import('firebase/auth');\n      const auth = getFirebaseAuth();\n      if (!auth) return;\n      unsubscribe = onAuthStateChanged(auth, async (user) => {\n        if (user) {\n          setAvatarUrl(user.photoURL || null);\n          try {\n            const token = await user.getIdToken();\n            setIdToken(token);\n          } catch {\n            setIdToken(null);\n          }\n        } else {\n          setAvatarUrl(null);\n          setIdToken(null);\n        }\n      });\n    })();\n    return () => { if (unsubscribe) unsubscribe(); };\n  }, [idToken]);\n\n  // Combine regular messages with error content (if any)\n  const finalMessages = useMemo(() => {\n    const result = [...messages];\n    \n    // Add error message if any\n    if (error) {\n      const errorTimestamp = Date.now();\n      result.push({\n        id: errorTimestamp,\n        role: 'error',\n        content: error,\n        timestamp: errorTimestamp\n      });\n    }\n    \n    return result;\n  }, [messages, error]);\n\n  // Handlers for overlay\n  const handleImageClick = (src) => {\n    setOverlayImageSrc(src);\n  };\n\n  const handleCloseOverlay = () => {\n    setOverlayImageSrc(null);\n  };\n\n  return (\n    <>\n      <div \n        className={styles.MessageList} \n        ref={ref}\n        aria-live=\"polite\"\n        aria-relevant=\"additions text\"\n      >\n        {finalMessages.map((message, index) => {\n          // Determine if this message is currently streaming\n          const isLastMessage = index === finalMessages.length - 1;\n          const isStreaming = message.role === 'assistant' && \n                              isLastMessage && \n                              isWaitingForResponse &&\n                              !message.metrics?.isComplete;\n          \n          // Process message content for images and text\n          const { images, text } = processMessageContent(message.content);\n          \n          // Generate a unique key using timestamp if available, fallback to role-index\n          const messageKey = message.timestamp \n            ? `${message.role}-${message.timestamp}-${index}`\n            : `${message.role}-${index}`;\n          \n          return (\n            <div key={messageKey} className={styles.MessageList__messageRow}>\n              {/* Render images first if it's a user message with images */}\n              {message.role === 'user' && images.length > 0 && (\n                <div className={styles.MessageList__imageContainer}>\n                  {images.map((image, imgIndex) => (\n                    <img \n                      key={`${messageKey}-img-${imgIndex}`}\n                      src={image.url}\n                      alt={image.alt || `Uploaded image ${imgIndex + 1}`}\n                      className={`${styles.MessageList__messageImage} ${styles.MessageList__clickableImage}`}\n                      onClick={() => handleImageClick(image.url)}\n                    />\n                  ))}\n                </div>\n              )}\n              {/* Render ChatMessage if there's text content or it's not a user message */}\n              {(text || message.role !== 'user') && (\n                <ChatMessage\n                  message={message}\n                  overrideContent={text || undefined}\n                  isStreaming={isStreaming}\n                  onEditMessage={message.role === 'user' ? onEditMessage : undefined}\n                  avatarUrl={message.role === 'user' && idToken ? (cachedAvatar || avatarUrl) : undefined}\n                />\n              )}\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Render the overlay component */}\n      {overlayImageSrc && (\n        <ImageOverlay\n          src={overlayImageSrc}\n          alt=\"Image preview\"\n          onClose={handleCloseOverlay}\n        />\n      )}\n    </>\n  );\n});\n\nMessageList.displayName = 'MessageList';\n\nMessageList.propTypes = {\n  messages: PropTypes.array.isRequired,\n  error: PropTypes.string,\n  onEditMessage: PropTypes.func\n};\n\nexport default memo(MessageList); "],"names":["useProfilePicture","imageUrl","cacheKey","cachedEntry","setCachedEntry","useLocalStorage","profilePicture","setProfilePicture","useState","loading","setLoading","error","setError","useEffect","isMounted","entry","wrapped","data","timestamp","Date","now","fetch","then","response","ok","Error","status","blob","Promise","resolve","reject","reader","FileReader","onloadend","result","onerror","readAsDataURL","dataUrl","entryToCache","catch","err","finally","convertTeXToMathDollars","text","combinedRegex","RegExp","replace","match","g1_code","g2_bTexIndent","g3_bTexContent","g4_bTexTrail","g5_bCustIndent","g6_bCustContent","g7_bCustTrail","g8_inlineContent","undefined","trim","formatTime","ms","toFixed","MarkdownRenderer","lazy","LazyMarkdownRenderer","_ref","children","_jsx","Suspense","fallback","StreamingMessage","texWorker","ChatMessage","message","isStreaming","onEditMessage","overrideContent","avatarUrl","content","messageCopied","setMessageCopied","defaultProcessedMessage","useMemo","role","processedMessage","setProcessedMessage","Worker","id","worker","URL","type","handleMessage","e","success","addEventListener","postMessage","removeEventListener","icon","src","alt","className","styles","ChatMessage__avatarImg","CopilotIcon","size","ChatMessage__icon","GearIcon","AlertIcon","messageClass","shouldShowMetrics","metrics","handleCopyMessage","useCallback","Array","isArray","filter","part","map","join","navigator","clipboard","writeText","setTimeout","copyButtonJsx","ChatMessage__copyMessageButton","ChatMessage__copyMessageButtonInMetrics","ChatMessage__copyMessageButtonBottomRight","onClick","title","CheckIcon","CopyIcon","handleEditClick","editButtonJsx","ChatMessage__editMessageButton","PencilIcon","_jsxs","ChatMessage__body","ChatMessage__avatar","ChatMessage__contentWrapper","ChatMessage__content","renderMetrics","isGenerating","elapsedTime","tokenCount","tokensPerSecond","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","ChatMessage__metricsContainer","ChatMessage__metric","ClockIcon","ChatMessage__metricIcon","PulseIcon","toLowerCase","ChatMessage__generatingIndicator","ChatMessage__generatingDot","ChatMessage__actions","displayName","memo","onClose","overlayContent","ImageOverlay","ImageOverlay__image","stopPropagation","ReactDOM","document","body","MessageList","forwardRef","ref","messages","isWaitingForResponse","useChatState","setAvatarUrl","cachedAvatar","idToken","setIdToken","localStorage","getItem","overlayImageSrc","setOverlayImageSrc","unsubscribe","getFirebaseAuth","onAuthStateChanged","auth","async","user","photoURL","token","getIdToken","finalMessages","errorTimestamp","push","_Fragment","index","_message$metrics","isLastMessage","length","isComplete","images","texts","reduce","acc","url","image_url","processMessageContent","messageKey","MessageList__messageRow","MessageList__imageContainer","image","imgIndex","MessageList__messageImage","MessageList__clickableImage","handleImageClick","handleCloseOverlay"],"sourceRoot":""}
{"version":3,"file":"static/js/markdown-renderer.dd942e8e0f.chunk.v1_9_0.js","mappings":"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","sources":["components/common/LazyMarkdownRenderer/MarkdownRenderer.js","../node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/unist-util-visit/lib/index.js","../node_modules/mdast-util-math/lib/index.js","../node_modules/longest-streak/index.js"],"sourcesContent":["import React from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport remarkGfm from 'remark-gfm';\nimport remarkMath from 'remark-math';\nimport rehypeKatex from 'rehype-katex';\nimport 'katex/dist/katex.min.css';\n\nexport default function MarkdownRenderer({ children }) {\n  return (\n    <ReactMarkdown\n      remarkPlugins={[remarkGfm, remarkMath]}\n      rehypePlugins={[rehypeKatex]}\n    >\n      {children}\n    </ReactMarkdown>\n  );\n} ","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n"],"names":["MarkdownRenderer","_ref","children","_jsx","ReactMarkdown","remarkPlugins","remarkGfm","remarkMath","rehypePlugins","rehypeKatex","convert","test","ok","check","castFactory","type","node","typeFactory","Array","isArray","tests","checks","index","length","any","_len","arguments","parameters","_key","call","this","anyFactory","all","key","propsFactory","Error","_len2","_key2","Boolean","CONTINUE","EXIT","visitParents","tree","visitor","reverse","is","step","factory","parents","value","name","tagName","undefined","Object","defineProperty","visit","subresult","offset","grandparents","result","toResult","concat","parent","indexOf","mathFromMarkdown","enter","mathFlow","token","meta","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","mathText","exit","resume","replace","setData","mathFlowFence","getData","stack","mathFlowValue","exitMathData","mathTextData","config","mathToMarkdown","options","single","singleDollarTextMath","inlineMath","peek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","tracker","track","sequence","repeat","Math","max","substring","source","String","expected","count","TypeError","longestStreak","move","subexit","safe","before","encode","current","size","RegExp","pattern","expression","patternCompile","match","exec","position","codePointAt","slice"],"sourceRoot":""}
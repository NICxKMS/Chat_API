{"version":3,"file":"static/js/5398.be81ea75.chunk.js","mappings":"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","sources":["../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-chunked/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-character/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-classify-character/index.js","../node_modules/micromark-extension-gfm-strikethrough/node_modules/micromark-util-resolve-all/index.js","../node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../node_modules/micromark-extension-gfm-footnote/node_modules/micromark-util-character/index.js","../node_modules/micromark-extension-gfm-footnote/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../node_modules/micromark-extension-gfm-footnote/node_modules/micromark-core-commonmark/lib/blank-line.js","../node_modules/micromark-extension-gfm-footnote/node_modules/micromark-util-normalize-identifier/index.js","../node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"sourcesContent":["/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {void}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if there’s only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, it’s fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, it’s fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde.\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of blank line.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *     ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'linePrefix')(code)\n      : after(code)\n  }\n\n  /**\n   * At eof/eol, after optional whitespace.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *       ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered “uppercase”, such as U+03F4 (`ϴ`), but if their\n * lowercase counterpart (U+03B8 (`θ`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Θ`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ')\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered “uppercase”, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if we’ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We can’t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"names":["splice","list","start","remove","items","end","length","parameters","chunkStart","Array","from","unshift","slice","regexCheck","unicodePunctuation","unicodeWhitespace","regex","code","test","String","fromCharCode","classifyCharacter","markdownLineEndingOrSpace","resolveAll","constructs","events","context","called","index","resolve","includes","push","gfmStrikethrough","options","single","singleTilde","tokenizer","tokenize","effects","ok","nok","previous","this","size","type","enter","more","before","consume","token","exit","after","_open","Boolean","_close","open","offset","strikethrough","Object","assign","text","nextEvents","insideSpan","parser","null","attentionMarkers","blankLine","markdownSpace","factorySpace","markdownLineEnding","partial","normalizeIdentifier","value","replace","toLowerCase","toUpperCase","indent","self","tail","sliceSerialize","gfmFootnote","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","gfmFootnoteDefinitionEnd","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","defined","gfmFootnotes","labelStart","_balanced","id","now","codePointAt","call","marker","column","_bufferIndex","string","chunk","contentType","replacement","data","callStart","callData","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","whitespaceAfter","check","attempt"],"sourceRoot":""}
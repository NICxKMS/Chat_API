{"version":3,"file":"static/js/6572.f872a713.chunk.js","mappings":";uHAmBO,SAASA,EAAoBC,GAClC,OACEA,EAEGC,QAAQ,cAAe,KAEvBA,QAAQ,SAAU,IAOlBC,cACAC,aAEP,mFCLO,SAASC,IACd,MAAO,CACLC,MAAO,CACLC,sBAAuBC,EACvBC,iCAAkCC,EAClCC,gBAAiBC,EACjBC,sBAAuBC,GAEzBC,KAAM,CACJR,sBAAuBS,EACvBP,iCAAkCQ,EAClCN,gBAAiBO,EACjBL,sBAAuBM,GAG7B,CASO,SAASC,IACd,MAAO,CAELC,OAAQ,CAAC,CAACC,UAAW,IAAKC,YAAa,CAAC,WAAY,QAAS,eAC7DC,SAAU,CAACC,qBAAoBC,qBAEnC,CAMA,SAASlB,EAAwBmB,GAC/BC,KAAKtB,MACH,CAACuB,KAAM,qBAAsBC,WAAY,GAAIC,MAAO,GAAIC,SAAU,IAClEL,EAEJ,CAMA,SAASjB,IACPkB,KAAKK,QACP,CAMA,SAAShB,EAAkCU,GACzC,MAAMI,EAAQH,KAAKM,SACbC,EACJP,KAAKQ,MAAMR,KAAKQ,MAAMC,OAAS,GAEjCF,EAAKJ,MAAQA,EACbI,EAAKL,WAAa9B,EAChB4B,KAAKU,eAAeX,IACpBxB,aACJ,CAMA,SAASa,EAAuBW,GAC9BC,KAAKb,KAAKY,EACZ,CAMA,SAASf,EAAkBe,GACzBC,KAAKtB,MAAM,CAACuB,KAAM,oBAAqBC,WAAY,GAAIC,MAAO,IAAKJ,EACrE,CAMA,SAASb,IACPc,KAAKK,QACP,CAMA,SAASd,EAAuBQ,GAC9B,MAAMI,EAAQH,KAAKM,SACbC,EACJP,KAAKQ,MAAMR,KAAKQ,MAAMC,OAAS,GAEjCF,EAAKJ,MAAQA,EACbI,EAAKL,WAAa9B,EAChB4B,KAAKU,eAAeX,IACpBxB,aACJ,CAMA,SAASe,EAAiBS,GACxBC,KAAKb,KAAKY,EACZ,CAMA,SAASD,EAAkBS,EAAMI,EAAGC,EAASC,GAC3C,MAAMC,GAAUC,EAAAA,EAAAA,GAAMF,GACtB,IAAIxC,EAAQyC,EAAQE,KAAK,MACzB,MAAM7B,EAAOyB,EAAQlC,MAAM,qBACrBuC,EAAUL,EAAQlC,MAAM,aAW9B,OAVAL,GAASyC,EAAQE,MACfE,EAAAA,EAAAA,GAAKN,GAASO,EAAAA,EAAAA,GAAYZ,GAAO,IAC5BO,EAAQM,UACXC,OAAQhD,EACRiD,MAAO,OAGXL,IACA9B,IACAd,GAASyC,EAAQE,KAAK,KACf3C,CACT,CAWA,SAASwB,EAAmBU,EAAMI,EAAGC,EAASC,GAC5C,MAAMC,GAAUC,EAAAA,EAAAA,GAAMF,GACtB,IAAIxC,EAAQyC,EAAQE,KAAK,MACzB,MAAM7B,EAAOyB,EAAQlC,MAAM,sBACrBuC,EAAUL,EAAQlC,MAAM,SAkB9B,OAjBAL,GAASyC,EAAQE,MACfE,EAAAA,EAAAA,GAAKN,GAASO,EAAAA,EAAAA,GAAYZ,GAAO,IAC5BO,EAAQM,UACXC,OAAQhD,EACRiD,MAAO,OAGXL,IACA5C,GAASyC,EAAQE,KACf,MAAQT,EAAKH,UAAYG,EAAKH,SAASK,OAAS,EAAI,IAAM,KAE5DK,EAAQS,MAAM,GACdlD,GAASyC,EAAQE,MACfQ,EAAAA,EAAAA,IAAYC,EAAAA,EAAAA,GAAclB,EAAMK,EAASE,EAAQM,WAAYM,IAE/DvC,IAEOd,CACT,CAGA,SAASqD,EAAIC,EAAMC,EAAOC,GACxB,OAAc,IAAVD,EACKD,GAGDE,EAAQ,GAAK,QAAUF,CACjC,CA5LA7B,EAAkBgC,KAoJlB,WACE,MAAO,GACT,iDC5EO,MAyEMC,EAYT,SAAUC,GACR,GAAIA,QACF,OAAOC,EAGT,GAAoB,iBAATD,EACT,OA8ER,SAAqBE,GACnB,OAAOC,EAAYlC,GAKnB,SAASA,EAAKM,GACZ,OAAOA,GAAQA,EAAKN,OAASiC,CAC/B,CACF,CAvFeE,CAAYJ,GAGrB,GAAoB,iBAATA,EACT,OAAOK,MAAMC,QAAQN,GAe7B,SAAoBO,GAElB,MAAMC,EAAS,GACf,IAAIZ,GAAS,EAEb,OAASA,EAAQW,EAAM9B,QACrB+B,EAAOZ,GAASG,EAAQQ,EAAMX,IAGhC,OAAOO,EAAYM,GAOnB,SAASA,IACP,IAAIb,GAAS,EAAC,QAAAc,EAAAC,UAAAlC,OADAmC,EAAU,IAAAP,MAAAK,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAVD,EAAUC,GAAAF,UAAAE,GAGxB,OAASjB,EAAQY,EAAO/B,QACtB,GAAI+B,EAAOZ,GAAOkB,KAAK9C,QAAS4C,GAAa,OAAO,EAGtD,OAAO,CACT,CACF,CAxCqCG,CAAWf,GAgDhD,SAAsBE,GACpB,OAAOC,EAAYa,GAMnB,SAASA,EAAIzC,GAEX,IAAI0C,EAEJ,IAAKA,KAAOf,EAEV,GAAI3B,EAAK0C,KAASf,EAAMe,GAAM,OAAO,EAGvC,OAAO,CACT,CACF,CAlEwDC,CAAalB,GAG/D,GAAoB,mBAATA,EACT,OAAOG,EAAYH,GAGrB,MAAM,IAAImB,MAAM,+CAClB,EAmFJ,SAAShB,EAAYD,GACnB,OAQA,SAAmB3B,GAAqB,QAAA6C,EAAAT,UAAAlC,OAAZmC,EAAU,IAAAP,MAAAe,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAVT,EAAUS,EAAA,GAAAV,UAAAU,GACpC,OAAOC,QACL/C,GACkB,iBAATA,GACP,SAAUA,GAEV+C,QAAQpB,EAAMY,KAAK9C,KAAMO,KAASqC,IAExC,CACF,CAEA,SAASX,IACP,OAAO,CACT,CC5NO,MAAMsB,GAAW,EAKXC,GAAO,EAoCPC,EAeT,SAAUC,EAAM1B,EAAM2B,EAASC,GACT,mBAAT5B,GAA0C,mBAAZ2B,IACvCC,EAAUD,EAEVA,EAAU3B,EACVA,EAAO,MAGT,MAAM6B,EAAK9B,EAAQC,GACb8B,EAAOF,GAAW,EAAI,GAS5B,SAASG,EAAQxD,EAAMqB,EAAOoC,GAG5B,MAAM3F,EAAQkC,GAAwB,iBAATA,EAAoBA,EAAO,CAAC,EAEzD,GAA0B,iBAAflC,EAAM4B,KAAmB,CAClC,MAAMgE,EAEqB,iBAAlB5F,EAAM6F,QACT7F,EAAM6F,QAEc,iBAAf7F,EAAM4F,KACX5F,EAAM4F,UACNE,EAENC,OAAOC,eAAeC,EAAO,OAAQ,CACnCjG,MACE,SAAiBkC,EAAKN,MAAQgE,EAAO,IAAMA,EAAO,IAAM,IAAO,KAErE,CAEA,OAAOK,EAEP,SAASA,IAEP,IAEIC,EAEAC,EAEAC,EANAC,EAAS,GAQb,KAAK1C,GAAQ6B,EAAGtD,EAAMqB,EAAOoC,EAAQA,EAAQvD,OAAS,IAAM,SAC1DiE,EA0CZ,SAAkBrG,GAChB,GAAIgE,MAAMC,QAAQjE,GAChB,OAAOA,EAGT,GAAqB,iBAAVA,EACT,MAAO,CAACkF,EAAUlF,GAGpB,MAAO,CAACA,EACV,CApDqBsG,CAAShB,EAAQpD,EAAMyD,IAE5BU,EAAO,KAAOlB,GAChB,OAAOkB,EAKX,GAAInE,EAAKH,UA1GC,SA0GWsE,EAAO,GAO1B,IALAF,GAAUZ,EAAUrD,EAAKH,SAASK,QAAU,GAAKqD,EAEjDW,EAAeT,EAAQY,OAAOrE,GAGvBiE,GAAU,GAAKA,EAASjE,EAAKH,SAASK,QAAQ,CAInD,GAFA8D,EAAYR,EAAQxD,EAAKH,SAASoE,GAASA,EAAQC,EAAvCV,GAERQ,EAAU,KAAOf,EACnB,OAAOe,EAGTC,EAC0B,iBAAjBD,EAAU,GAAkBA,EAAU,GAAKC,EAASV,CAC/D,CAGF,OAAOY,CACT,CACF,CAvEAX,CAAQL,OAAMS,EAAW,GAAzBJ,EAwEF,EC7EG,MAAMO,EAeT,SAAUZ,EAAM1B,EAAM2B,EAASC,GACT,mBAAT5B,GAA0C,mBAAZ2B,IACvCC,EAAUD,EACVA,EAAU3B,EACVA,EAAO,MAGTyB,EAAaC,EAAM1B,GAMnB,SAAkBzB,EAAMyD,GACtB,MAAMa,EAASb,EAAQA,EAAQvD,OAAS,GACxC,OAAOkD,EACLpD,EACAsE,EAASA,EAAOzE,SAAS0E,QAAQvE,GAAQ,KACzCsE,EAEJ,GAbmCjB,EAcrC,EC/JEmB,EAAM,CAAC,EAAEC,eAaR,SAASC,EAAYvB,GAE1B,MAAMwB,EAAQd,OAAOe,OAAO,MAE5B,IAAKzB,IAASA,EAAKzD,KACjB,MAAM,IAAIkD,MAAM,wCAUlB,OAPAmB,EAAMZ,EAAM,cAAe0B,IACzB,MAAMC,EAAKC,EAAMF,EAAWlF,YACxBmF,IAAON,EAAIjC,KAAKoC,EAAOG,KACzBH,EAAMG,GAAMD,EACd,IAMF,SAAoBlF,GAClB,MAAMmF,EAAKC,EAAMpF,GAEjB,OAAOmF,GAAMN,EAAIjC,KAAKoC,EAAOG,GAAMH,EAAMG,GAAM,IACjD,CACF,CAMA,SAASC,EAAMjH,GACb,OAAOkH,OAAOlH,GAAS,IAAIG,aAC7B,mFC1BAgH,EAAa1D,KAgEb,WACE,MAAO,GACT,EA3DO,MAAM2D,EAA+B,CAC1CC,eAAgB,CAAC,UACjBhH,MAAO,CAACiH,cAwBV,SAA4B5F,GAC1BC,KAAKtB,MAAM,CAACuB,KAAM,SAAUG,SAAU,IAAKL,EAC7C,GAzBEZ,KAAM,CAACwG,cA+BT,SAA2B5F,GACzBC,KAAKb,KAAKY,EACZ,IAzBa6F,EAA6B,CACxCnG,OAAQ,CACN,CACEC,UAAW,IACXC,YAAa,WACbkG,eAhCiC,CACrC,WACA,qBACA,iBACA,YACA,aACA,qBA6BAjG,SAAU,CAACkG,OAAQN,IAuBrB,SAASA,EAAajF,EAAMI,EAAGC,EAASC,GACtC,MAAMC,GAAUC,EAAAA,EAAAA,GAAMF,GAChB1B,EAAOyB,EAAQlC,MAAM,iBAC3B,IAAIL,EAAQyC,EAAQE,KAAK,MAQzB,OAPA3C,IAAS0H,EAAAA,EAAAA,GAAkBxF,EAAMK,EAAS,IACrCE,EAAQM,UACXC,OAAQhD,EACRiD,MAAO,MAETjD,GAASyC,EAAQE,KAAK,MACtB7B,IACOd,CACT,aC3FA2H,EAAOC,QAAU,SAAmBC,GAClC,OAAc,MAAPA,GAAkC,MAAnBA,EAAIC,aACY,mBAA7BD,EAAIC,YAAYC,UAA2BF,EAAIC,YAAYC,SAASF,EAC/E,gCC+IA,SAASG,EAAoBhI,GAC3B,OAAOA,EAAMoC,MACf,CAcO,SAAS6F,EAAcC,EAAOC,GACnC,MAAMC,EAAWD,GAAW,CAAC,EAEvBE,GAASD,EAASC,OAAS,IAAI9B,SAC/B+B,EAAeF,EAASE,cAAgBN,EAExCO,EAAa,GAEbC,EAAa,GAEbC,EAAa,GAEbC,EAAsB,GAC5B,IAAIC,EAAkB,EAClBC,GAAY,EAIhB,OAASA,EAAWV,EAAM9F,QAAQ,CAEhC,MAAMyG,EAAM,GAENC,EAAQ,GACd,IAAIC,GAAe,EAMnB,IAJIb,EAAMU,GAAUxG,OAASuG,IAC3BA,EAAkBT,EAAMU,GAAUxG,UAG3B2G,EAAcb,EAAMU,GAAUxG,QAAQ,CAC7C,MAAM4G,EA8KHhJ,OADUA,EA7KUkI,EAAMU,GAAUG,IA8KI,GAAK7B,OAAOlH,GA5KvD,IAAiC,IAA7BoI,EAASa,gBAA2B,CACtC,MAAMC,EAAOZ,EAAaU,GAC1BF,EAAMC,GAAeG,QAGkBpD,IAArC4C,EAAoBK,IACpBG,EAAOR,EAAoBK,MAE3BL,EAAoBK,GAAeG,EAEvC,CAEAL,EAAIM,KAAKH,EACX,CAEAR,EAAWI,GAAYC,EACvBJ,EAAWG,GAAYE,CACzB,CA0JF,IAAmB9I,EAvJjB,IAAI+I,GAAe,EAEnB,GAAqB,iBAAVV,GAAsB,WAAYA,EAC3C,OAASU,EAAcJ,GACrBJ,EAAWQ,GAAeK,EAAYf,EAAMU,QAEzC,CACL,MAAMM,EAAOD,EAAYf,GAEzB,OAASU,EAAcJ,GACrBJ,EAAWQ,GAAeM,CAE9B,CAGAN,GAAe,EAEf,MAAMF,EAAM,GAENC,EAAQ,GAEd,OAASC,EAAcJ,GAAiB,CACtC,MAAMU,EAAOd,EAAWQ,GACxB,IAAI/F,EAAS,GACTC,EAAQ,GAEC,KAAToG,GACFrG,EAAS,IACTC,EAAQ,KACU,MAAToG,EACTrG,EAAS,IACS,MAATqG,IACTpG,EAAQ,KAIV,IAAIiG,GAC2B,IAA7Bd,EAASa,gBACL,EACAK,KAAKC,IACH,EACAb,EAAoBK,GAAe/F,EAAOZ,OAASa,EAAMb,QAGjE,MAAM4G,EAAOhG,EAAS,IAAIwG,OAAON,GAAQjG,GAER,IAA7BmF,EAASa,kBACXC,EAAOlG,EAAOZ,OAAS8G,EAAOjG,EAAMb,OAEhC8G,EAAOR,EAAoBK,KAC7BL,EAAoBK,GAAeG,GAGrCJ,EAAMC,GAAeG,GAGvBL,EAAIE,GAAeC,CACrB,CAGAR,EAAWiB,OAAO,EAAG,EAAGZ,GACxBJ,EAAWgB,OAAO,EAAG,EAAGX,GAExBF,GAAY,EAEZ,MAAMc,EAAQ,GAEd,OAASd,EAAWJ,EAAWpG,QAAQ,CACrC,MAAMyG,EAAML,EAAWI,GACjBE,EAAQL,EAAWG,GACzBG,GAAe,EAEf,MAAMzF,EAAO,GAEb,OAASyF,EAAcJ,GAAiB,CACtC,MAAMK,EAAOH,EAAIE,IAAgB,GACjC,IAAI/F,EAAS,GACTC,EAAQ,GAEZ,IAAiC,IAA7BmF,EAASa,gBAA2B,CACtC,MAAMC,EACJR,EAAoBK,IAAgBD,EAAMC,IAAgB,GACtDM,EAAOd,EAAWQ,GAEX,MAATM,EACFrG,EAAS,IAAIwG,OAAON,GACF,KAATG,EACLH,EAAO,GACTlG,EAAS,IAAIwG,OAAON,EAAO,EAAI,IAC/BjG,EAAQ,IAAIuG,OAAON,EAAO,EAAI,MAE9BlG,EAAS,IAAIwG,OAAON,EAAO,GAC3BjG,EAAQD,GAGVC,EAAQ,IAAIuG,OAAON,EAEvB,EAEgC,IAA5Bd,EAASuB,gBAA6BZ,GACxCzF,EAAK6F,KAAK,MAIW,IAArBf,EAASwB,UAGsB,IAA7BxB,EAASa,iBAAsC,KAATD,IACX,IAA5BZ,EAASuB,iBAA4BZ,GAEtCzF,EAAK6F,KAAK,MAGqB,IAA7Bf,EAASa,iBACX3F,EAAK6F,KAAKnG,GAGZM,EAAK6F,KAAKH,IAEuB,IAA7BZ,EAASa,iBACX3F,EAAK6F,KAAKlG,IAGa,IAArBmF,EAASwB,SACXtG,EAAK6F,KAAK,MAIgB,IAA1Bf,EAASyB,cACTd,IAAgBJ,EAAkB,GAElCrF,EAAK6F,KAAK,IAEd,CAEAO,EAAMP,MACsB,IAA1Bf,EAASyB,aACLvG,EAAKwG,KAAK,IAAI7J,QAAQ,MAAO,IAC7BqD,EAAKwG,KAAK,IAElB,CAEA,OAAOJ,EAAMI,KAAK,KACpB,CAkBA,SAASV,EAAYpJ,GACnB,MAAMqJ,EAAwB,iBAAVrJ,EAAqBA,EAAM+J,YAAY,GAAK,EAEhE,OAAgB,KAATV,GAAkC,KAATA,EAC5B,GACS,KAATA,GAAkC,MAATA,EACvB,IACS,KAATA,GAAkC,MAATA,EACvB,IACA,CACV,gDC9XO,SAASW,EAAchK,EAAOiK,GACnC,MAAMC,EAAShD,OAAOlH,GACtB,IAAIuD,EAAQ2G,EAAOzD,QAAQwD,GACvBE,EAAW5G,EACX6G,EAAQ,EACRb,EAAM,EAEV,GAAyB,iBAAdU,EACT,MAAM,IAAII,UAAU,sBAGtB,MAAkB,IAAX9G,GACDA,IAAU4G,IACNC,EAAQb,IACZA,EAAMa,GAGRA,EAAQ,EAGVD,EAAW5G,EAAQ0G,EAAU7H,OAC7BmB,EAAQ2G,EAAOzD,QAAQwD,EAAWE,GAGpC,OAAOZ,CACT","sources":["../node_modules/mdast-util-gfm-footnote/node_modules/micromark-util-normalize-identifier/index.js","../node_modules/mdast-util-gfm-footnote/lib/index.js","../node_modules/mdast-util-definitions/node_modules/unist-util-is/lib/index.js","../node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-definitions/node_modules/unist-util-visit/lib/index.js","../node_modules/mdast-util-definitions/lib/index.js","../node_modules/mdast-util-gfm-strikethrough/lib/index.js","../node_modules/is-buffer/index.js","../node_modules/markdown-table/index.js","../node_modules/longest-streak/index.js"],"sourcesContent":["/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered ‚Äúuppercase‚Äù, such as U+03F4 (`œ¥`), but if their\n * lowercase counterpart (U+03B8 (`Œ∏`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Œò`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ')\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered ‚Äúuppercase‚Äù, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node‚Äôs position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node‚Äôs parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node‚Äôs position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node‚Äôs parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node‚Äôs position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node‚Äôs parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node‚Äôs position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node‚Äôs parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node‚Äôs position in its parent.\n * @param parent\n *   The node‚Äôs parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you‚Äôre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node‚Äôs children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesn‚Äôt place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its ‚Äúvisible‚Äù size;\n *   note that what is and isn‚Äôt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['‰∏≠Êñá', 'Charlie'],\n *     ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | ‰∏≠Êñá | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë© | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['‰∏≠Êñá', 'Charlie'],\n *       ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | ‰∏≠Êñá  | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë©    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don‚Äôt align delimiters, but otherwise we‚Äôd\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don‚Äôt add the opening space if we‚Äôre not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n","/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n"],"names":["normalizeIdentifier","value","replace","toLowerCase","toUpperCase","gfmFootnoteFromMarkdown","enter","gfmFootnoteDefinition","enterFootnoteDefinition","gfmFootnoteDefinitionLabelString","enterFootnoteDefinitionLabelString","gfmFootnoteCall","enterFootnoteCall","gfmFootnoteCallString","enterFootnoteCallString","exit","exitFootnoteDefinition","exitFootnoteDefinitionLabelString","exitFootnoteCall","exitFootnoteCallString","gfmFootnoteToMarkdown","unsafe","character","inConstruct","handlers","footnoteDefinition","footnoteReference","token","this","type","identifier","label","children","buffer","resume","node","stack","length","sliceSerialize","_","context","safeOptions","tracker","track","move","subexit","safe","association","current","before","after","shift","indentLines","containerFlow","map","line","index","blank","peek","convert","test","ok","check","castFactory","typeFactory","Array","isArray","tests","checks","any","_len","arguments","parameters","_key","call","anyFactory","all","key","propsFactory","Error","_len2","_key2","Boolean","CONTINUE","EXIT","visitParents","tree","visitor","reverse","is","step","factory","parents","name","tagName","undefined","Object","defineProperty","visit","subresult","offset","grandparents","result","toResult","concat","parent","indexOf","own","hasOwnProperty","definitions","cache","create","definition","id","clean","String","handleDelete","gfmStrikethroughFromMarkdown","canContainEols","strikethrough","gfmStrikethroughToMarkdown","notInConstruct","delete","containerPhrasing","module","exports","obj","constructor","isBuffer","defaultStringLength","markdownTable","table","options","settings","align","stringLength","alignments","cellMatrix","sizeMatrix","longestCellByColumn","mostCellsPerRow","rowIndex","row","sizes","columnIndex","cell","alignDelimiters","size","push","toAlignment","code","Math","max","repeat","splice","lines","delimiterStart","padding","delimiterEnd","join","codePointAt","longestStreak","substring","source","expected","count","TypeError"],"sourceRoot":""}
{"version":3,"file":"static/js/5100.124e16f7.chunk.js","mappings":"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","sources":["../node_modules/unist-util-generated/lib/index.js","../node_modules/trough/lib/index.js","../node_modules/space-separated-tokens/index.js","../node_modules/style-to-object/index.js","../node_modules/style-to-object/index.mjs","../node_modules/unist-util-find-after/lib/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/trim-lines/index.js"],"sourcesContent":["/**\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef NodeLike\n * @property {PositionLike | null | undefined} [position]\n */\n\n/**\n * Check if `node` is generated.\n *\n * @param {NodeLike | null | undefined} [node]\n *   Node to check.\n * @returns {boolean}\n *   Whether `node` is generated (does not have positional info).\n */\nexport function generated(node) {\n  return (\n    !node ||\n    !node.position ||\n    !node.position.start ||\n    !node.position.start.line ||\n    !node.position.start.column ||\n    !node.position.end ||\n    !node.position.end.line ||\n    !node.position.end.column\n  )\n}\n","// To do: remove `void`s\n// To do: remove `null` from output of our APIs, allow it as user APIs.\n\n/**\n * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback\n *   Callback.\n *\n * @typedef {(...input: Array<any>) => any} Middleware\n *   Ware.\n *\n * @typedef Pipeline\n *   Pipeline.\n * @property {Run} run\n *   Run the pipeline.\n * @property {Use} use\n *   Add middleware.\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n *\n *   Calls `done` on completion with either an error or the output of the\n *   last middleware.\n *\n *   > ðŸ‘‰ **Note**: as the length of input defines whether async functions get a\n *   > `next` function,\n *   > itâ€™s recommended to keep `input` at one value normally.\n\n *\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n *   Pipeline.\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or weâ€™re done.\n     *\n     * @param {Error | null | undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware` into a uniform interface.\n *\n * You can pass all input to the resulting function.\n * `callback` is then called with the output of `middleware`.\n *\n * If `middleware` accepts more arguments than the later given in input,\n * an extra `done` function is passed to it after that input,\n * which must be called by `middleware`.\n *\n * The first value in `input` is the main input value.\n * All other input values are the rest input values.\n * The values given to `callback` are the input values,\n * merged with every non-nullish output value.\n *\n * * if `middleware` throws an error,\n *   returns a promise that is rejected,\n *   or calls the given `done` function with an error,\n *   `callback` is called with that error\n * * if `middleware` returns a value or returns a promise that is resolved,\n *   that value is the main output value\n * * if `middleware` calls `done`,\n *   all non-nullish values except for the first one (the error) overwrite the\n *   output values\n *\n * @param {Middleware} middleware\n *   Function to wrap.\n * @param {Callback} callback\n *   Callback called with the output of `middleware`.\n * @returns {Run}\n *   Wrapped middleware.\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result && result.then && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   *\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * Parse space-separated tokens to an array of strings.\n *\n * @param {string} value\n *   Space-separated tokens.\n * @returns {Array<string>}\n *   List of tokens.\n */\nexport function parse(value) {\n  const input = String(value || '').trim()\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : []\n}\n\n/**\n * Serialize an array of strings as space separated-tokens.\n *\n * @param {Array<string|number>} values\n *   List of tokens.\n * @returns {string}\n *   Space-separated tokens.\n */\nexport function stringify(values) {\n  return values.join(' ').trim()\n}\n","var parse = require('inline-style-parser');\n\n/**\n * Parses inline style to object.\n *\n * @example\n * // returns { 'line-height': '42' }\n * StyleToObject('line-height: 42;');\n *\n * @param  {String}      style      - The inline style.\n * @param  {Function}    [iterator] - The iterator function.\n * @return {null|Object}\n */\nfunction StyleToObject(style, iterator) {\n  var output = null;\n  if (!style || typeof style !== 'string') {\n    return output;\n  }\n\n  var declaration;\n  var declarations = parse(style);\n  var hasIterator = typeof iterator === 'function';\n  var property;\n  var value;\n\n  for (var i = 0, len = declarations.length; i < len; i++) {\n    declaration = declarations[i];\n    property = declaration.property;\n    value = declaration.value;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      output || (output = {});\n      output[property] = value;\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = StyleToObject;\nmodule.exports.default = StyleToObject; // ESM support\n","import StyleToObject from './index.js';\n\nexport default StyleToObject;\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnâ€™t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodeâ€™s parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n"],"names":["generated","node","position","start","line","column","end","trough","fns","pipeline","run","_len","arguments","length","values","Array","_key","middlewareIndex","callback","pop","TypeError","next","error","fn","index","_len2","output","_key2","undefined","middleware","called","wrapped","_len3","parameters","_key3","fnExpectsCallback","result","push","done","apply","this","then","Error","_len4","_key4","value","wrap","use","middelware","parse","input","String","trim","split","stringify","join","require","StyleToObject","style","iterator","declaration","property","declarations","hasIterator","i","len","module","exports","findAfter","parent","test","is","convert","type","children","Number","POSITIVE_INFINITY","indexOf","ok","castFactory","isArray","tests","checks","any","anyFactory","check","checkAsRecord","all","nodeAsRecord","key","propsFactory","typeFactory","testFunction","Boolean","looksLikeANode","call","tab","space","trimLines","source","search","match","exec","last","lines","trimLine","slice","startIndex","endIndex","code","codePointAt"],"sourceRoot":""}
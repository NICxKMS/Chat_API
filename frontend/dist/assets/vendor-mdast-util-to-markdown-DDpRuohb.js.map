{"version":3,"file":"vendor-mdast-util-to-markdown-DDpRuohb.js","sources":["../../node_modules/mdast-util-to-markdown/lib/util/association.js","../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../node_modules/mdast-util-to-markdown/lib/util/safe.js","../../node_modules/mdast-util-to-markdown/lib/util/track.js","../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../../node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../node_modules/mdast-util-to-markdown/lib/util/check-bullet.js"],"sourcesContent":["/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n"],"names":["association","node","label","identifier","decodeString","containerFlow","parent","state","info","indexStack","children","tracker","createTracker","results","index","push","length","child","move","handle","before","after","current","type","bulletLastUsed","between","pop","join","left","right","result","repeat","eol","indentLines","value","map","match","start","line","exec","one","slice","patternCompile","pattern","_compiled","atBreak","RegExp","test","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","safe","input","config","positions","infos","unsafe","expression","Boolean","position","sort","numerical","end","escapeBackslashes","charAt","encode","charCodeAt","toString","toUpperCase","a","b","whole","track","options","now","lineShift","column","chunks","split","tail","shift","containerPhrasing","handlers","peek","replace","inlineCode","_","sequence","listItem","listItemIndent","style","Error","checkListItemIndent","bullet","bulletCurrent","marker","checkBullet","ordered","incrementListMarker","indexOf","size","spread","Math","ceil","exit","enter","blank"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}
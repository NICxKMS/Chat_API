{"version":3,"mappings":"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","names":["ImagePreviewList","lazy","__vitePreload","import","__VITE_PRELOAD__","ChatInputTextArea","ChatInputActionRow","readFileAsBase64","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","error","readAsDataURL","ChatInput","memo","disabled","selectedModel","isStaticLayout","editingMessage","onCancelEdit","isStreaming","toggleModelSelector","onFocus","isInitialChat","onSendMessage","message","setMessage","useState","selectedImages","setSelectedImages","textareaRef","useRef","fileInputRef","isEditing","isMobile","setIsMobile","window","innerWidth","isWaitingForResponse","useChatState","stopGeneration","newChat","useChatControl","inputError","setInputError","errorTimeoutRef","useEffect","handleResize","addEventListener","removeEventListener","current","focus","textContent","images","content","Array","isArray","forEach","part","type","text","image_url","url","push","name","setTimeout","adjustTextareaHeight","useCallback","textarea","style","height","newHeight","Math","min","scrollHeight","inputContainer","closest","styles","setProperty","detectKeyboard","isKeyboard","innerHeight","outerHeight","document","body","classList","toggle","handleFocus","add","handleBlur","remove","showError","clearTimeout","handleChange","e","target","value","prepareAndSendMessage","hasText","trim","length","hasImages","contentPayload","img","handleKeyDown","key","shiftKey","preventDefault","handleImageSelection","async","event","files","from","imagePromises","map","startsWith","Error","size","MAX_SIZE_MB","base64","newImages","all","prev","handlePaste","items","clipboardData","imageItems","filter","item","getAsFile","Date","now","removeImage","indexToRemove","_","index","triggerFileInput","capabilities","includes","click","handleCancelEdit","handleStop","handleInlineSendClick","stopPropagation","blur","placeholderText","jsxRuntimeExports","jsxs","Fragment","children","jsx","Suspense","fallback","onRemoveImage","className","Boolean","join","ChatInput__error","role","ref","display","accept","multiple","onChange","onKeyDown","onPaste","placeholder","onSendClick","onNewChat","onUploadClick","onToggleModelSelector","displayName"],"ignoreList":[],"sources":["../../src/components/chat/ChatInput/index.jsx"],"sourcesContent":["import { useState, useRef, useEffect, useCallback, memo, lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './ChatInput.module.css';\nimport { useChatState } from '../../../contexts/ChatStateContext';\nimport { useChatControl } from '../../../contexts/ChatControlContext';\n\n// Lazy-load sub-components\nconst ImagePreviewList = lazy(() => import('./subcomponents/ImagePreviewList'));\nconst ChatInputTextArea = lazy(() => import('./subcomponents/ChatInputTextArea'));\nconst ChatInputActionRow = lazy(() => import('./subcomponents/ChatInputActionRow'));\n\n/**\n * Reads a file and returns its base64 representation.\n * @param {File} file - The file to read.\n * @returns {Promise<string>} A promise resolving with the base64 data URL.\n */\nconst readFileAsBase64 = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = (error) => reject(error);\n    reader.readAsDataURL(file);\n  });\n};\n\n/**\n * Auto-resizing chat input component (Refactored)\n */\nconst ChatInput = memo(({ \n  disabled = false, \n  selectedModel = null, \n  isStaticLayout = false,\n  editingMessage = null,\n  onCancelEdit = () => {},\n  isStreaming = false,\n  toggleModelSelector = () => {},\n  onFocus = () => {},\n  isInitialChat = false,\n  onSendMessage,\n}) => {\n  const [message, setMessage] = useState('');\n  const [selectedImages, setSelectedImages] = useState([]);\n  const textareaRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const isEditing = !!editingMessage;\n  const [isMobile, setIsMobile] = useState(window.innerWidth <= 600);\n  const { isWaitingForResponse } = useChatState();\n  const { stopGeneration, newChat } = useChatControl();\n  const [inputError, setInputError] = useState(null);\n  const errorTimeoutRef = useRef(null); // Ref to manage error timeout\n  \n  // Mobile detection\n  useEffect(() => {\n    const handleResize = () => setIsMobile(window.innerWidth <= 600);\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Focus input on mount\n  useEffect(() => {\n    textareaRef.current?.focus();\n  }, []);\n  \n  // Set message/images when entering edit mode\n  useEffect(() => {\n    if (editingMessage) {\n      let textContent = '';\n      const images = [];\n      if (typeof editingMessage.content === 'string') {\n        textContent = editingMessage.content;\n      } else if (Array.isArray(editingMessage.content)) {\n        editingMessage.content.forEach(part => {\n          if (part.type === 'text') textContent += part.text || '';\n          if (part.type === 'image_url' && part.image_url?.url) {\n            images.push({ name: '', url: part.image_url.url });\n          }\n        });\n      }\n      setMessage(textContent);\n      setSelectedImages(images);\n      setTimeout(() => textareaRef.current?.focus(), 0);\n    } else {\n      // Clear state if exiting edit mode (e.g., via prop change)\n      setMessage('');\n      setSelectedImages([]);\n    }\n  }, [editingMessage]);\n  \n  // Auto-resize textarea\n  const adjustTextareaHeight = useCallback(() => {\n    const textarea = textareaRef.current;\n    if (!textarea) return;\n    textarea.style.height = 'auto';\n    const newHeight = Math.min(textarea.scrollHeight + 2, 200);\n    textarea.style.height = `${newHeight}px`;\n    const inputContainer = textarea.closest(`.${styles.ChatInput}`);\n    if (inputContainer) {\n      inputContainer.style.setProperty('--textarea-height', `${newHeight}px`); // Use CSS var\n    }\n  }, []);\n  \n  useEffect(() => {\n    adjustTextareaHeight();\n  }, [message, adjustTextareaHeight]);\n\n  // Mobile keyboard detection (Keep this logic here as it affects body class)\n  useEffect(() => {\n    if (!isMobile) return;\n    const detectKeyboard = () => {\n      const isKeyboard = window.innerHeight < window.outerHeight * 0.75;\n      document.body.classList.toggle('keyboard-open', isKeyboard);\n    };\n    const handleFocus = () => {\n      if (isMobile) {\n        document.body.classList.add('keyboard-open');\n        window.addEventListener('resize', detectKeyboard);\n      }\n      if (onFocus) onFocus();\n    };\n    const handleBlur = () => {\n      if (isMobile) {\n        document.body.classList.remove('keyboard-open');\n        window.removeEventListener('resize', detectKeyboard);\n      }\n    };\n    const textarea = textareaRef.current;\n    if (textarea) {\n      textarea.addEventListener('focus', handleFocus);\n      textarea.addEventListener('blur', handleBlur);\n    }\n    return () => {\n      if (textarea) {\n        textarea.removeEventListener('focus', handleFocus);\n        textarea.removeEventListener('blur', handleBlur);\n      }\n      window.removeEventListener('resize', detectKeyboard);\n      document.body.classList.remove('keyboard-open'); // Cleanup on unmount\n    };\n  }, [isMobile, onFocus]);\n\n  // Helper to show error message temporarily\n  const showError = useCallback((message) => {\n    setInputError(message);\n    // Clear previous timeout if any\n    if (errorTimeoutRef.current) {\n      clearTimeout(errorTimeoutRef.current);\n    }\n    // Set new timeout to clear error\n    errorTimeoutRef.current = setTimeout(() => {\n      setInputError(null);\n      errorTimeoutRef.current = null;\n    }, 3000); // Show error for 3 seconds\n  }, []);\n  \n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (errorTimeoutRef.current) {\n        clearTimeout(errorTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  // Event Handlers\n  \n  const handleChange = useCallback((e) => {\n    setMessage(e.target.value);\n  }, []);\n\n  const prepareAndSendMessage = useCallback(() => {\n    const hasText = message.trim().length > 0;\n    const hasImages = selectedImages.length > 0;\n    if ((!hasText && !hasImages) || disabled) return;\n\n    if (!selectedModel && toggleModelSelector) {\n      toggleModelSelector();\n      return;\n    }\n\n    const contentPayload = [];\n    if (hasText) contentPayload.push({ type: 'text', text: message.trim() });\n    if (hasImages) selectedImages.forEach(img => contentPayload.push({ type: 'image_url', image_url: { url: img.url } }));\n\n    if (contentPayload.length > 0) {\n      onSendMessage(contentPayload, isEditing ? editingMessage : null);\n    }\n\n    setMessage('');\n    setSelectedImages([]);\n    if (isEditing && onCancelEdit) onCancelEdit();\n\n    if (textareaRef.current) {\n      textareaRef.current.style.height = 'auto'; // Reset height immediately\n      setTimeout(() => textareaRef.current?.focus(), 0);\n    }\n  }, [message, selectedImages, disabled, selectedModel, toggleModelSelector, onSendMessage, isEditing, editingMessage, onCancelEdit]);\n\n  const handleKeyDown = useCallback((e) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      if (!isWaitingForResponse) prepareAndSendMessage(); // Call renamed handler\n    } else if (isEditing && e.key === 'Escape') {\n      e.preventDefault();\n      if (onCancelEdit) onCancelEdit(); // Use onCancelEdit prop\n      setMessage(''); // Also clear message state\n      setSelectedImages([]);\n    }\n  }, [isWaitingForResponse, prepareAndSendMessage, isEditing, onCancelEdit]);\n\n  const handleImageSelection = useCallback(async (event) => {\n    const files = Array.from(event.target.files);\n    if (!files.length) return;\n    const MAX_IMAGES = 5;\n    if (selectedImages.length + files.length > MAX_IMAGES) {\n      showError(`Max ${MAX_IMAGES} images allowed.`); // Use showError\n      if (fileInputRef.current) fileInputRef.current.value = \"\";\n      return;\n    }\n    try {\n      const imagePromises = files.map(async (file) => {\n        if (!file.type.startsWith('image/')) throw new Error(`${file.name} invalid type.`);\n        const MAX_SIZE_MB = 5;\n        if (file.size > MAX_SIZE_MB * 1024 * 1024) throw new Error(`${file.name} > ${MAX_SIZE_MB}MB.`);\n        const base64 = await readFileAsBase64(file);\n        return { name: file.name, url: base64 };\n      });\n      const newImages = await Promise.all(imagePromises);\n      setSelectedImages((prev) => [...prev, ...newImages]);\n    } catch (error) {\n      console.error(\"Image processing error:\", error);\n      showError(`Image error: ${error.message}`); // Use showError\n    }\n    if (fileInputRef.current) fileInputRef.current.value = \"\";\n  }, [selectedImages.length, showError]);\n\n  const handlePaste = useCallback(async (e) => {\n    if (isEditing) return;\n    const items = e.clipboardData?.items;\n    if (!items) return;\n    const imageItems = Array.from(items).filter(item => item.type.startsWith('image/'));\n    if (imageItems.length === 0) return;\n    const MAX_IMAGES = 5;\n    if (selectedImages.length + imageItems.length > MAX_IMAGES) {\n      showError(`Max ${MAX_IMAGES} images allowed.`); // Use showError\n      return;\n    }\n    try {\n      const imagePromises = imageItems.map(async (item) => {\n        const file = item.getAsFile();\n        const MAX_SIZE_MB = 5;\n        if (file.size > MAX_SIZE_MB * 1024 * 1024) throw new Error(`Pasted image > ${MAX_SIZE_MB}MB.`);\n        const base64 = await readFileAsBase64(file);\n        return { name: 'pasted-' + Date.now(), url: base64 };\n      });\n      const newImages = await Promise.all(imagePromises);\n      if (newImages.length > 0) {\n         setSelectedImages((prev) => [...prev, ...newImages]);\n         e.preventDefault(); // Prevent pasting as text\n      }\n    } catch (error) {\n      console.error(\"Paste processing error:\", error);\n      showError(`Paste error: ${error.message}`); // Use showError\n    }\n  }, [isEditing, selectedImages.length, showError]);\n\n  const removeImage = useCallback((indexToRemove) => {\n    setSelectedImages((prev) => prev.filter((_, index) => index !== indexToRemove));\n  }, []);\n\n  const triggerFileInput = useCallback(() => {\n    // Logic for triggering file input based on model selection\n    if (!selectedModel && toggleModelSelector) {\n      toggleModelSelector();\n    } else if (selectedModel?.capabilities?.includes('vision')) {\n       fileInputRef.current?.click();\n    } else {\n      showError('Select a model with vision capabilities to upload images.'); // Use showError\n    }\n  }, [selectedModel, toggleModelSelector, showError]);\n\n  const handleCancelEdit = useCallback(() => {\n    if (onCancelEdit) onCancelEdit();\n    setMessage('');\n    setSelectedImages([]);\n  }, [onCancelEdit]);\n\n  const handleStop = useCallback(() => {\n    stopGeneration();\n  }, [stopGeneration]);\n\n  // Wrapper for the inline send/stop button click\n  const handleInlineSendClick = useCallback((e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (isWaitingForResponse) {\n      handleStop();\n    } else {\n      prepareAndSendMessage(); // Call renamed handler\n    }\n    if (isMobile && textareaRef.current) textareaRef.current.blur();\n  }, [isWaitingForResponse, handleStop, prepareAndSendMessage, isMobile]);\n\n  // Render Logic\n  \n  const placeholderText = isEditing \n    ? 'Edit your message...' \n    : isWaitingForResponse\n      ? 'Type your next message while waiting...'\n      : 'Ask anything';\n\n  return (\n    <>\n      {/* Image Previews */} \n      <Suspense fallback={null}>\n        <ImagePreviewList images={selectedImages} onRemoveImage={removeImage} />\n      </Suspense>\n\n      <div className={[\n          styles.ChatInput, \n          isEditing ? styles['ChatInput--editing'] : '', \n          isWaitingForResponse ? styles['ChatInput--waitingForResponse'] : '', \n          isMobile ? styles['ChatInput__mobileView'] : '',\n          isMobile ? (isInitialChat ? styles['ChatInput--mobileInitial'] : styles['ChatInput--mobileWithMessages']) : '',\n        ].filter(Boolean).join(' ')}\n      >\n        {/* Inline Error Message */} \n        {inputError && (\n          <div className={styles.ChatInput__error} role=\"alert\">\n            {inputError}\n          </div>\n        )}\n\n        {/* Hidden file input */} \n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          style={{ display: 'none' }}\n          accept=\"image/jpeg, image/png, image/gif, image/webp\"\n          multiple\n          onChange={handleImageSelection}\n        />\n\n        {/* Text Area and Inline Button */} \n        <Suspense fallback={null}>\n          <ChatInputTextArea \n             ref={textareaRef}\n             value={message}\n             onChange={handleChange}\n             onKeyDown={handleKeyDown}\n             onPaste={handlePaste}\n             placeholder={placeholderText}\n             disabled={disabled}\n             isEditing={isEditing}\n             isWaitingForResponse={isWaitingForResponse}\n             selectedModel={selectedModel}\n             onSendClick={handleInlineSendClick}\n          />\n        </Suspense>\n        \n        {/* Action Button Row */} \n        <Suspense fallback={null}>\n          <ChatInputActionRow \n             isMobile={isMobile}\n             isEditing={isEditing}\n             disabled={disabled}\n             selectedModel={selectedModel}\n             onNewChat={newChat}\n             onUploadClick={triggerFileInput}\n             onCancelEdit={handleCancelEdit}\n             onToggleModelSelector={toggleModelSelector}\n          />\n        </Suspense>\n      </div>\n    </>\n  );\n});\n\n// Display name\nChatInput.displayName = 'ChatInput';\n\n// PropTypes\nChatInput.propTypes = {\n  disabled: PropTypes.bool,\n  selectedModel: PropTypes.shape({ // Define model shape if needed\n    // Add specific model properties here if known/required\n    id: PropTypes.string,\n    name: PropTypes.string,\n    // ... other properties\n  }), \n  isStaticLayout: PropTypes.bool,\n  editingMessage: PropTypes.shape({ // Define message shape for editing\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    content: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.shape({ // Support complex content\n        type: PropTypes.string.isRequired,\n        text: PropTypes.string,\n        image_url: PropTypes.shape({\n          url: PropTypes.string.isRequired\n        })\n      }))\n    ]).isRequired\n  }),\n  onCancelEdit: PropTypes.func,\n  isStreaming: PropTypes.bool,\n  toggleModelSelector: PropTypes.func,\n  onFocus: PropTypes.func,\n  isInitialChat: PropTypes.bool,\n  onSendMessage: PropTypes.func.isRequired,\n};\n\nexport default ChatInput; "],"file":"assets/index-C-FADSuX.js"}
{"version":3,"file":"vendor-micromark-extension-gfm-footnote-BMow1uuh.js","sources":["../../node_modules/micromark-extension-gfm-footnote/node_modules/micromark-util-character/index.js","../../node_modules/micromark-extension-gfm-footnote/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if weâ€™ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We canâ€™t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error Itâ€™s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > ðŸ‘‰ **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n"],"names":["markdownLineEndingOrSpace","code","indent","tokenize","effects","ok","nok","self","this","factorySpace","tail","events","length","type","sliceSerialize","partial","gfmFootnote","document","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","index","defined","parser","gfmFootnotes","labelStart","token","_balanced","id","normalizeIdentifier","start","end","now","codePointAt","includes","slice","enter","consume","context","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","contentType","replacement","splice","data","size","callStart","callData","callEscape","identifier","_container","labelAtMarker","labelInside","labelAfter","labelEscape","push","whitespaceAfter","check","blankLine","attempt"],"mappings":"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","x_google_ignoreList":[0,1]}
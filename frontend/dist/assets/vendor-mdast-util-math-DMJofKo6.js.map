{"version":3,"file":"vendor-mdast-util-math-DMJofKo6.js","sources":["../../node_modules/mdast-util-math/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('../index.js').Math} Math\n * @typedef {import('../index.js').InlineMath} InlineMath\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\nimport {patternCompile} from 'mdast-util-to-markdown/lib/util/pattern-compile.js'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // To do: next major: rename `context` to state, `safeOptions` to info.\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const tracker = track(safeOptions)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          before: value,\n          after: '\\n',\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  //\n  // To do: next major: rename `context` to state.\n  // To do: next major: use `state` (`safe`, `track`, `patternCompile`).\n  function inlineMath(node, _, context) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < context.unsafe.length) {\n      const pattern = context.unsafe[index]\n      const expression = patternCompile(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"],"names":["mathFromMarkdown","enter","mathFlow","token","this","type","meta","value","data","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","mathText","exit","resume","replace","node","setData","mathFlowFence","getData","stack","length","mathFlowValue","exitMathData","mathTextData","config","call","mathToMarkdown","options","single","singleDollarTextMath","inlineMath","peek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","tracker","track","sequence","repeat","Math","max","longestStreak","move","subexit","safe","before","encode","current","size","RegExp","test","index","pattern","expression","patternCompile","match","exec","position","codePointAt","slice"],"mappings":"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","x_google_ignoreList":[0]}
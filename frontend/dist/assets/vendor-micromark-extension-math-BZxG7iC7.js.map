{"version":3,"file":"vendor-micromark-extension-math-BZxG7iC7.js","sources":["../../node_modules/micromark-extension-math/node_modules/micromark-util-character/index.js","../../node_modules/micromark-extension-math/lib/math-flow.js","../../node_modules/micromark-extension-math/lib/math-text.js","../../node_modules/micromark-extension-math/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar.\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can use two or more dollars for text math.\n\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * @param {Options | null | undefined} [options]\n * @returns {Construct}\n */\nexport function mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === null) {\n        return nok(code)\n      }\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text.js').Options} Options\n */\n\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n"],"names":["markdownLineEnding","code","mathFlow","tokenize","effects","ok","nok","self","this","tail","events","length","initialSize","type","sliceSerialize","sizeOpen","enter","sequenceOpen","consume","exit","factorySpace","metaBefore","metaAfter","contentType","meta","interrupt","attempt","nonLazyContinuation","beforeNonLazyContinuation","after","tokenizeClosingFence","partial","contentStart","beforeContentChunk","contentChunk","size","sequenceClose","parser","constructs","disable","null","includes","afterSequenceClose","concrete","lineStart","lazy","now","line","mathText","options","single","singleDollarTextMath","token","between","data","resolve","resolveMathText","previous","index","tailExitIndex","headEnterIndex","end","splice","math","flow","text"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}
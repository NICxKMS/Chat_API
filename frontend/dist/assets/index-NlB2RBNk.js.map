{"version":3,"mappings":";8YAsBO,SAASA,EAAWC,GACrB,OAACA,EACDA,EAAK,IAAa,GAAGA,MAClB,IAAIA,EAAK,KAAMC,QAAQ,MAFd,MAGlB,CCnBA,MAAMC,EAAcC,QAAK,IAAMC,GAAA,IAAAC,OAAO,wBAAgBC,sMAChDC,EAAeJ,QAAK,IAAMC,GAAA,IAAAC,OAAO,wBAA2BC,sIAU5DE,EAAcC,cAAW,EAAGC,WAAUC,QAAOC,iBAAiBC,KAC5D,MAAAC,qBAAEA,GAAyBC,KAE1BC,EAAWC,GAAgBC,WAAS,OAEnCC,eAAgBC,GAAiBC,EAAkBL,IACpDM,EAASC,GAAcL,YAAS,IAAMM,aAAaC,QAAQ,cAE3DC,EAAiBC,GAAsBT,WAAS,MAGvDU,aAAU,KACR,IAAKN,EAAS,OACVO,MAqBJ,MApBA,WACQ,MAAAC,gBAAEA,SAA0B1B,GAAA2B,UAAA,+BAAA1B,OAAO,gCAAyB,4BAAAC,iCAC5D0B,mBAAEA,SAA6B5B,GAAA2B,UAAA,kCAAA1B,OAAO,0BAAe,+BAAAC,6BACrD2B,EAAOH,IACRG,IACSD,IAAmBC,GAAMF,MAAOG,IAC5C,GAAIA,EAAM,CACKA,IAAKC,UAAY,MAC1B,IACIC,cAAcF,EAAKG,aACzBd,EAAWa,EAAK,CACV,MACNb,EAAW,KAAI,CACjB,MAEAN,EAAa,MACbM,EAAW,KAAI,IAGlB,EAnBH,GAoBO,KAAYM,GAAyBA,GAAA,CAAG,GAC9C,CAACP,IAGEgB,QAAgBC,WAAQ,KACtBC,QAAS,IAAI9B,GAGnB,GAAIC,EAAO,CACH8B,QAAiBC,KAAKC,MAC5BH,EAAOI,KAAK,CACVC,GAAIJ,EACJK,KAAM,QACNC,QAASpC,EACTqC,UAAWP,GACZ,CAGID,WACN,CAAC9B,EAAUC,IAWd,OAEIsC,EAAAC,KAAAC,WAAA,CAAAC,SAAA,GAAAC,IAAC,MACC,CAAAC,UAAWC,EACX1C,MACA,YAAU,SACV,gBAAc,iBAEbyB,WAAckB,KAAI,CAACC,EAASC,WAErBC,QAAgBD,IAAUpB,EAAcsB,OAAS,EACjDC,EAA+B,cAAjBJ,EAAQX,MACRa,GACA7C,KACC2C,SAAQK,gBAASC,iBAGhCC,OAAEA,OAAQC,GDnGnB,SAA+BlB,GAChC,IAACA,EAAgB,OAAEiB,OAAQ,GAAIC,KAAMlB,GACrCmB,SAAMC,QAAQpB,GAAU,CACpB,MAAAiB,OAAEA,QAAQI,GAAUrB,EAAQsB,QAChC,CAACC,EAAKC,KACc,cAAdA,EAAKC,KACPF,EAAIN,OAAOpB,KAAK,CACd6B,IAAKF,EAAKG,UAAUD,IACpBE,IAAKJ,EAAKG,UAAUC,KAAOJ,EAAKI,KAAO,OAElB,SAAdJ,EAAKC,MACVJ,QAAMxB,KAAK2B,EAAKN,MAEfK,IAET,CAAEN,OAAQ,GAAII,MAAO,KAEhB,OAAEJ,SAAQC,KAAMG,EAAMQ,KAAK,KAAK,CAElC,OAAEZ,OAAQ,GAAIC,KAAMlB,EAC7B,CC+EmC8B,CAAsBpB,EAAQV,SAGjD+B,EAAarB,EAAQT,UACvB,GAAGS,EAAQX,QAAQW,EAAQT,aAAaU,IACxC,GAAGD,EAAQX,QAAQY,IAEvB,SACGR,KAAA,OAAqBI,UAAWC,EAE9BE,UAAiB,SAATX,QAAmBkB,EAAOJ,OAAS,GACzCP,MAAA,OAAIC,UAAWC,EACbS,WAAOR,KAAI,CAACuB,EAAOC,IAClB/B,EAAAI,IAAC,OAEC4B,IAAKF,EAAMN,IACXE,IAAKI,EAAMJ,KAAO,kBAAkBK,EAAW,IAC/C1B,UAAW,GAAGC,KAAoCA,IAClD2B,QAAS,KAAMC,OA3CDF,EA2CkBF,EAAMN,SA1CxD9C,EAAmBsD,GADKA,IAAQA,CAuCT,MAAGH,SAAkBE,UAUhCf,GAAyB,SAAjBR,EAAQX,OACfO,MAAA+B,WAAA,CAASC,SAAU,KAClBjC,SAACC,MAAAnD,EAAA,CACCuD,UACA6B,gBAAiBrB,QAAQsB,EACzB1B,cACAjD,cAAgC,SAAjB6C,EAAQX,KAAkBlC,OAAgB2E,EACzDvE,UAA4B,SAAjByC,EAAQX,MAAmBxB,EAAWF,GAAgBJ,OAAauE,QAvB5ET,EA2BV,MAMLpD,KACC2B,IAAC+B,EAASA,SAAA,CAAAC,SAAU,KAClBjC,SAAAC,MAAC9C,EACC,CAAA0E,IAAKvD,EACLiD,IAAI,gBACJa,QAnEiBC,KACzB9D,EAAmB,KAAI,QAsEvB,IAIJnB,EAAYkF,YAAc,cAQ1B,MAAeC,SAAKnF","names":["formatTime","ms","toFixed","ChatMessage","lazy","__vitePreload","import","__VITE_PRELOAD__","ImageOverlay","MessageList","forwardRef","messages","error","onEditMessage","ref","isWaitingForResponse","useChatState","avatarUrl","setAvatarUrl","useState","profilePicture","cachedAvatar","useProfilePicture","idToken","setIdToken","localStorage","getItem","overlayImageSrc","setOverlayImageSrc","useEffect","unsubscribe","getFirebaseAuth","async","onAuthStateChanged","auth","user","photoURL","token","getIdToken","finalMessages","useMemo","result","errorTimestamp","Date","now","push","id","role","content","timestamp","jsxRuntimeExports","jsxs","Fragment","children","jsx","className","styles","map","message","index","isLastMessage","length","isStreaming","metrics","isComplete","images","text","Array","isArray","texts","reduce","acc","part","type","url","image_url","alt","join","processMessageContent","messageKey","image","imgIndex","src","onClick","handleImageClick","Suspense","fallback","overrideContent","undefined","onClose","handleCloseOverlay","displayName","memo"],"ignoreList":[],"sources":["../../src/utils/messageHelpers.jsx","../../src/components/chat/MessageList/index.jsx"],"sourcesContent":["export function processMessageContent(content) {\n  if (!content) return { images: [], text: content };\n  if (Array.isArray(content)) {\n    const { images, texts } = content.reduce(\n      (acc, part) => {\n        if (part.type === 'image_url') {\n          acc.images.push({\n            url: part.image_url.url,\n            alt: part.image_url.alt || part.alt || null\n          });\n        } else if (part.type === 'text') {\n          acc.texts.push(part.text);\n        }\n        return acc;\n      },\n      { images: [], texts: [] }\n    );\n    return { images, text: texts.join(' ') };\n  }\n  return { images: [], text: content };\n}\n\nexport function formatTime(ms) {\n  if (!ms) return '0.0s';\n  if (ms < 1000) return `${ms}ms`;\n  return `${(ms / 1000).toFixed(1)}s`;\n} ","import { forwardRef, useState, useMemo, memo, useEffect, lazy, Suspense } from 'react';\nimport styles from './MessageList.module.css';\nimport { useChatState } from '../../../contexts/ChatStateContext';\nimport PropTypes from 'prop-types';\nimport { processMessageContent } from '../../../utils/messageHelpers';\nimport { useProfilePicture } from '../../../hooks/useProfilePicture';\n// Lazy-load sub-components\nconst ChatMessage = lazy(() => import('../ChatMessage'));\nconst ImageOverlay = lazy(() => import('../../common/ImageOverlay'));\n\n/**\n * Simple message list without virtualization\n * @param {Object} props - Component props\n * @param {Array} props.messages - Array of message objects\n * @param {string} props.error - Error message to display\n * @param {Function} props.onEditMessage - Function to handle message edit requests\n * @returns {JSX.Element} - Rendered component\n */\nconst MessageList = forwardRef(({ messages, error, onEditMessage }, ref) => {\n  const { isWaitingForResponse } = useChatState();\n  // Local state for dynamic auth values\n  const [avatarUrl, setAvatarUrl] = useState(null);\n  // Use hook to fetch and cache avatar Data URL\n  const { profilePicture: cachedAvatar } = useProfilePicture(avatarUrl);\n  const [idToken, setIdToken] = useState(() => localStorage.getItem('idToken'));\n\n  const [overlayImageSrc, setOverlayImageSrc] = useState(null);\n\n  // Dynamically import Firebase auth only if a token is already cached\n  useEffect(() => {\n    if (!idToken) return;\n    let unsubscribe;\n    (async () => {\n      const { getFirebaseAuth } = await import('../../../firebaseConfig');\n      const { onAuthStateChanged } = await import('firebase/auth');\n      const auth = getFirebaseAuth();\n      if (!auth) return;\n      unsubscribe = onAuthStateChanged(auth, async (user) => {\n        if (user) {\n          setAvatarUrl(user.photoURL || null);\n          try {\n            const token = await user.getIdToken();\n            setIdToken(token);\n          } catch {\n            setIdToken(null);\n          }\n        } else {\n          setAvatarUrl(null);\n          setIdToken(null);\n        }\n      });\n    })();\n    return () => { if (unsubscribe) unsubscribe(); };\n  }, [idToken]);\n\n  // Combine regular messages with error content (if any)\n  const finalMessages = useMemo(() => {\n    const result = [...messages];\n    \n    // Add error message if any\n    if (error) {\n      const errorTimestamp = Date.now();\n      result.push({\n        id: errorTimestamp,\n        role: 'error',\n        content: error,\n        timestamp: errorTimestamp\n      });\n    }\n    \n    return result;\n  }, [messages, error]);\n\n  // Handlers for overlay\n  const handleImageClick = (src) => {\n    setOverlayImageSrc(src);\n  };\n\n  const handleCloseOverlay = () => {\n    setOverlayImageSrc(null);\n  };\n\n  return (\n    <>\n      <div \n        className={styles.MessageList} \n        ref={ref}\n        aria-live=\"polite\"\n        aria-relevant=\"additions text\"\n      >\n        {finalMessages.map((message, index) => {\n          // Determine if this message is currently streaming\n          const isLastMessage = index === finalMessages.length - 1;\n          const isStreaming = message.role === 'assistant' && \n                              isLastMessage && \n                              isWaitingForResponse &&\n                              !message.metrics?.isComplete;\n          \n          // Process message content for images and text\n          const { images, text } = processMessageContent(message.content);\n          \n          // Generate a unique key using timestamp if available, fallback to role-index\n          const messageKey = message.timestamp \n            ? `${message.role}-${message.timestamp}-${index}`\n            : `${message.role}-${index}`;\n          \n          return (\n            <div key={messageKey} className={styles.MessageList__messageRow}>\n              {/* Render images first if it's a user message with images */}\n              {message.role === 'user' && images.length > 0 && (\n                <div className={styles.MessageList__imageContainer}>\n                  {images.map((image, imgIndex) => (\n                    <img \n                      key={`${messageKey}-img-${imgIndex}`}\n                      src={image.url}\n                      alt={image.alt || `Uploaded image ${imgIndex + 1}`}\n                      className={`${styles.MessageList__messageImage} ${styles.MessageList__clickableImage}`}\n                      onClick={() => handleImageClick(image.url)}\n                    />\n                  ))}\n                </div>\n              )}\n              {/* Render ChatMessage if there's text content or it's not a user message */}\n              {(text || message.role !== 'user') && (\n                <Suspense fallback={null}>\n                  <ChatMessage\n                    message={message}\n                    overrideContent={text || undefined}\n                    isStreaming={isStreaming}\n                    onEditMessage={message.role === 'user' ? onEditMessage : undefined}\n                    avatarUrl={message.role === 'user' && idToken ? (cachedAvatar || avatarUrl) : undefined}\n                  />\n                </Suspense>\n              )}\n            </div>\n          );\n        })}\n      </div>\n      \n      {/* Render the overlay component */}\n      {overlayImageSrc && (\n        <Suspense fallback={null}>\n          <ImageOverlay\n            src={overlayImageSrc}\n            alt=\"Image preview\"\n            onClose={handleCloseOverlay}\n          />\n        </Suspense>\n      )}\n    </>\n  );\n});\n\nMessageList.displayName = 'MessageList';\n\nMessageList.propTypes = {\n  messages: PropTypes.array.isRequired,\n  error: PropTypes.string,\n  onEditMessage: PropTypes.func\n};\n\nexport default memo(MessageList); "],"file":"assets/index-NlB2RBNk.js"}
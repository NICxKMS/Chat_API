{"version":3,"mappings":";u3FAIA,MAAMA,EAAmBC,QAAK,WAAMC,OAA0E,mCAAoBC,0OAElI,SAAwBC,GAAqBC,SAAEA,IAE3CC,aAACC,WAAS,CAAAC,SAAWF,MAAA,OAAKD,aACxBA,SAAAC,MAACN,EAAkBK,eAGzB,CCFA,MAAMI,EAAmBR,QAAK,WAAMC,OAA0E,mCAAoBC,6SAGlI,IAAIO,EACJ,MAiBMC,EAAcA,EAAGC,UAASC,eAAc,EAAOC,gBAAgB,KAAMC,kBAAkB,KAAMC,YAAY,SAE7G,MAAMC,EAA6B,MAAnBF,EAA0BA,EAAkBH,EAAQK,SAE7DC,EAAeC,GAAoBC,YAAS,GAC7CC,EAA0BC,WAAQ,IACrB,cAAjBV,EAAQW,KACJN,EACAO,EAAwBP,IAC3B,CAACA,EAASL,EAAQW,QACdE,EAAkBC,GAAuBN,WAASC,GAGzDM,aAAU,KACRD,EAAoBL,EAAuB,GAC1C,CAACA,IAEJM,aAAU,KACJf,GAAiB,cAAjBA,EAAQW,MAA2C,iBAAZN,GAA0C,oBAAXW,OACxE,OAEF,MAAMC,EAAKjB,EAAQkB,UACbC,GAtCc,oBAAXH,QAA2BlB,IACxBA,EAAA,IAAIkB,OAAO,IAAAI,IAAA,+CAAAC,KAA+D,CAAEC,KAAM,YAEzFxB,GAoCCyB,EAAuBC,IACvBA,EAAEC,KAAKR,KAAOA,IACdO,EAAEC,KAAKC,QAA6BF,IAAEC,KAAKA,QACtBpB,GAAO,EAIlC,OAFOsB,mBAAiB,UAAWJ,GACnCJ,EAAOS,YAAY,CAAEX,KAAIZ,YAClB,KACEwB,sBAAoB,UAAWN,EAAa,CACrD,GACC,CAAClB,EAASL,EAAQW,KAAMX,EAAQkB,YAG7BY,QAAOpB,WAAQ,KACnB,OAAQV,EAAQW,MACd,IAAK,OACIP,SACFV,MAAA,OAAIqC,IAAK3B,EAAW4B,IAAI,cAAcC,UAAWC,EAAOC,yBACzD,KACN,IAAK,yBACKC,EAAY,CAAAC,KAAM,GAAIJ,UAAWC,EAAOI,oBAClD,IAAK,sBACKC,EAAS,CAAAF,KAAM,GAAIJ,UAAWC,EAAOI,oBAC/C,IAAK,qBACKE,EAAU,CAAAH,KAAM,GAAIJ,UAAWC,EAAOI,oBAChD,QACS,eAEV,CAACtC,EAAQW,KAAMP,IAGZqC,EAAe/B,WAAQ,KAC3B,OAAQV,EAAQW,MACd,IAAK,OACH,OAAOuB,EAAO,qBAChB,IAAK,YACH,OAAOA,EAAO,0BAChB,IAAK,SACH,OAAOA,EAAO,uBAChB,IAAK,QACH,OAAOA,EAAO,sBAChB,QACS,YAEV,CAAClC,EAAQW,OAGN+B,EAAoBhC,WAAQ,MAEX,cAAjBV,EAAQW,OAAyBX,EAAQ2C,UAE5C,CAAC3C,EAAQW,KAAMX,EAAQ2C,UAGpBC,EAAoBC,eAAY,KAC9BxC,QAAqC,iBAApBL,EAAQK,QAC3BL,EAAQK,QACRyC,MAAMC,QAAQ/C,EAAQK,SACpBL,EAAQK,QACL2C,QAAeC,GAAc,SAAdA,EAAK3B,OACpB4B,KAAYD,KAAKE,OACjBC,KAAK,MACR,GACNC,UAAUC,UAAUC,UAAUlD,GAASmD,MAAK,KAC1CjD,GAAiB,GACjBkD,YAAW,IAAMlD,GAAiB,IAAQ,IAAI,GAC/C,GACA,CAACP,EAAQK,UAGNqD,EAAgBhD,WAAQ,UAC3B,SACC,CAAAuB,UAAW,GAAGC,EAAOyB,kCACD,cAAjB3D,EAAQW,MAAwB+B,EAAqBR,EAAO0B,wCAA0C1B,EAAO2B,4CAEhHC,QAASlB,EACT,aAAW,eACXmB,MAAM,eAELzD,SAAgBA,EAAAZ,MAACsE,GAAU3B,KAAM,KAAU3C,MAAAuE,EAAA,CAAS5B,KAAM,QAE5D,CAACO,EAAmB5C,EAAQW,KAAM+B,EAAmBpC,IAGlD4D,EAAkBrB,eAAY,KAC9B3C,KAA6BF,EAAO,GACvC,CAACE,EAAeF,IACbmE,EAAgBzD,WAAQ,IAAuB,SAAjBV,EAAQW,KACzCjB,MAAA,UACCuC,UAAWC,EAAOkC,+BAClBN,QAASI,EACT,aAAW,eACXH,MAAM,eAENtE,SAAA4E,EAAA3E,IAAC4E,EAAW,CAAAjC,KAAM,OAElB,MAAM,CAACrC,EAAQW,KAAMuD,kBA0GtB,MAAI,CAAAjC,UAAWC,EAAOnC,YAAc,IAAM0C,EACzChD,SAAA,GAAC8E,KAAA,OAAItC,UAAWC,EAAOsC,kBAEpB1C,aACEpC,MAAA,OAAIuC,UAAWC,EAAOuC,oBAAsB3C,SAAKA,MAInDyC,KAAA,OAAItC,UAAWC,EAAOwC,4BACrBjF,SAAA,CAAAC,MAACC,WAAS,CAAAC,SAAU,KAClBH,SAAAC,MAAC,OAAIuC,UAAWC,EAAOyC,qBACpB3E,SAAiB,cAAjBA,EAAQW,KACPjB,MAACG,EACC,CAAAQ,QAASQ,EACTZ,kBAIFP,IAACF,GACEqB,SACHA,QAMY,cAAjBb,EAAQW,MAhIKiE,MACpB,IAAKlC,IAAsB1C,EAAQ2C,QAAgB,YAGnD,MAAMkC,EAAe5E,GACf6E,YACJA,aACAC,kBACAC,mBACAC,eACAC,mBACAC,cACAC,eACAC,GACErF,EAAQ2C,QAcR,OAVa,MAAfmC,GACc,MAAdC,GACmB,MAAnBC,GACoB,MAApBC,GACgB,MAAhBC,GACoB,MAApBC,GACe,MAAfC,GACgB,MAAhBC,IAMCd,KAAA,OAAItC,UAAWC,EAAOoD,8BAEpBL,UAAoB,MAApBA,GAAiD,IAArBA,UAC1B,OAAK,CAAAhD,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC8F,EAAU,CAAAnD,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,gBACjDC,EAAWT,MAGb,MAAfH,GAAuC,IAAhBA,UACrB,OAAK,CAAA7C,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC8F,EAAU,CAAAnD,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,eAClDC,EAAWZ,MAKb,MAAdC,GAAqC,IAAfA,UACpB,OAAK,CAAA9C,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC0C,EAAY,CAAAC,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,WACxDV,KAGI,MAAhBG,GAAyC,IAAjBA,UACtB,OAAK,CAAAjD,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC0C,EAAY,CAAAC,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,WACxDP,KAGQ,MAApBC,GAAiD,IAArBA,UAC1B,OAAK,CAAAlD,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC0C,EAAY,CAAAC,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,eACpDN,KAGD,MAAfC,GAAuC,IAAhBA,UACrB,OAAK,CAAAnD,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC0C,EAAY,CAAAC,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,UACzDL,KAKQ,MAAnBJ,GAA+C,IAApBA,UACzB,OAAK,CAAA/C,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAACiG,EAAU,CAAAtD,KAAM,GAAIJ,UAAWC,EAAOuD,0BAAwB,UACvDT,EAAgB,UAKX,MAAhBK,GAAyC,KAAjBA,GAAsD,SAA/BA,EAAaO,eAA2D,YAA/BP,EAAaO,iBACpGrB,KAAC,OAAK,CAAAtC,UAAWC,EAAOqD,oBACtB9F,SAAA,CAAAC,MAAC8C,EAAU,CAAAH,KAAM,GAAIJ,UAAWC,EAAOuD,0BACtCJ,KAGJR,GACEN,OAAA,QAAKtC,UAAW,GAAGC,EAAOqD,uBAAuBrD,EAAO2D,mCACvDpG,SAAA,GAACC,IAAA,QAAKuC,UAAWC,EAAO4D,6BAAkC,mBAM7DpC,KAnEwB,IAoE3B,EAgCqCkB,GAGf,SAAjB5E,EAAQW,OAAqC,cAAjBX,EAAQW,OAAyB+B,IAAsBgB,QAItE,SAAjB1D,EAAQW,aACN,MAAI,CAAAsB,UAAWC,EAAO6D,qBACpB5B,YACAT,OAGP,EAKJ3D,EAAYiG,YAAc,cAmC1B,MAAeC,SAAKlG","names":["MarkdownRenderer","lazy","import","__VITE_PRELOAD__","LazyMarkdownRenderer","children","jsx","Suspense","fallback","StreamingMessage","texWorker","ChatMessage","message","isStreaming","onEditMessage","overrideContent","avatarUrl","content","messageCopied","setMessageCopied","useState","defaultProcessedMessage","useMemo","role","convertTeXToMathDollars","processedMessage","setProcessedMessage","useEffect","Worker","id","timestamp","worker","URL","url","type","handleMessage","e","data","success","addEventListener","postMessage","removeEventListener","icon","src","alt","className","styles","ChatMessage__avatarImg","CopilotIcon","size","ChatMessage__icon","GearIcon","AlertIcon","messageClass","shouldShowMetrics","metrics","handleCopyMessage","useCallback","Array","isArray","filter","part","map","text","join","navigator","clipboard","writeText","then","setTimeout","copyButtonJsx","ChatMessage__copyMessageButton","ChatMessage__copyMessageButtonInMetrics","ChatMessage__copyMessageButtonBottomRight","onClick","title","CheckIcon","CopyIcon","handleEditClick","editButtonJsx","ChatMessage__editMessageButton","jsxRuntimeExports","PencilIcon","jsxs","ChatMessage__body","ChatMessage__avatar","ChatMessage__contentWrapper","ChatMessage__content","renderMetrics","isGenerating","elapsedTime","tokenCount","tokensPerSecond","timeToFirstToken","promptTokens","completionTokens","totalTokens","finishReason","ChatMessage__metricsContainer","ChatMessage__metric","ClockIcon","ChatMessage__metricIcon","formatTime","PulseIcon","toLowerCase","ChatMessage__generatingIndicator","ChatMessage__generatingDot","ChatMessage__actions","displayName","memo"],"ignoreList":[],"sources":["../../src/components/common/LazyMarkdownRenderer/index.jsx","../../src/components/chat/ChatMessage/index.jsx"],"sourcesContent":["import React, { lazy, Suspense } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n// Lazy-load the heavy Markdown renderer only when first used\r\nconst MarkdownRenderer = lazy(() => import(/* webpackChunkName: \"markdown-renderer\", webpackPrefetch: true */ './MarkdownRenderer'));\r\n\r\nexport default function LazyMarkdownRenderer({ children }) {\r\n  return (\r\n    <Suspense fallback={<div>{children}</div>}>\r\n      <MarkdownRenderer>{children}</MarkdownRenderer>\r\n    </Suspense>\r\n  );\r\n}\r\n\r\nLazyMarkdownRenderer.propTypes = {\r\n  children: PropTypes.node.isRequired\r\n}; ","// eslint-disable import/first\nimport React, { memo, useMemo, useState, useEffect, useCallback, lazy, Suspense } from 'react';\nimport PropTypes from 'prop-types';\nimport { CopilotIcon, GearIcon, AlertIcon, CheckIcon, CopyIcon, ClockIcon, PulseIcon, PencilIcon } from '@primer/octicons-react';\nimport styles from './ChatMessage.module.css';\nimport { formatTime } from '../../../utils/messageHelpers';\nimport { convertTeXToMathDollars } from '../../../utils/formatters';\n// Lazy-load Markdown renderer for user/system/error messages\nimport LazyMarkdownRenderer from '../../common/LazyMarkdownRenderer';\n// Dynamically load StreamingMessage to defer heavy modules\nconst StreamingMessage = lazy(() => import(/* webpackChunkName: \"streaming-message\", webpackPrefetch: true */ './StreamingMessage'));\n\n// Add a module-level singleton for the TeX worker so we only load the worker script once\nlet texWorker;\nconst getTexWorker = () => {\n  if (typeof Worker !== 'undefined' && !texWorker) {\n    texWorker = new Worker(new URL('../../../workers/texProcessor.jsx', import.meta.url), { type: 'module' });\n  }\n  return texWorker;\n};\n\n/**\n * ChatMessage component with optimized rendering for streaming content\n * @param {Object} props - Component props\n * @param {string} props.role - Message role (user, assistant, system, error)\n * @param {string} props.content - Message content\n * @param {number} props.index - Message index in the chat history\n * @param {boolean} props.isStreaming - Whether this message is currently streaming\n * @param {string} props.avatarUrl - Optional URL for user avatar image\n * @returns {JSX.Element} - Rendered component\n */\nconst ChatMessage = ({ message, isStreaming = false, onEditMessage = null, overrideContent = null, avatarUrl = null }) => {\n  // Use overrideContent if provided, else fall back to message.content\n  const content = overrideContent != null ? overrideContent : message.content;\n\n  const [messageCopied, setMessageCopied] = useState(false);\n  const defaultProcessedMessage = useMemo(() => (\n    message.role === 'assistant'\n      ? content\n      : convertTeXToMathDollars(content)\n  ), [content, message.role]);\n  const [processedMessage, setProcessedMessage] = useState(defaultProcessedMessage);\n\n  // Update processedMessage whenever the underlying content changes (e.g., after editing)\n  useEffect(() => {\n    setProcessedMessage(defaultProcessedMessage);\n  }, [defaultProcessedMessage]);\n\n  useEffect(() => {\n    if (message.role !== 'assistant' || typeof content !== 'string' || typeof Worker === 'undefined') {\n      return;\n    }\n    const id = message.timestamp;\n    const worker = getTexWorker();\n    const handleMessage = (e) => {\n      if (e.data.id !== id) return;\n      if (e.data.success) setProcessedMessage(e.data.data);\n      else setProcessedMessage(content);\n    };\n    worker.addEventListener('message', handleMessage);\n    worker.postMessage({ id, content });\n    return () => {\n      worker.removeEventListener('message', handleMessage);\n    };\n  }, [content, message.role, message.timestamp]);\n  \n  // Choose appropriate icon based on message role\n  const icon = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return avatarUrl\n          ? <img src={avatarUrl} alt=\"User avatar\" className={styles.ChatMessage__avatarImg} />\n          : null;\n      case 'assistant':\n        return <CopilotIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'system':\n        return <GearIcon size={16} className={styles.ChatMessage__icon} />;\n      case 'error':\n        return <AlertIcon size={16} className={styles.ChatMessage__icon} />;\n      default:\n        return null;\n    }\n  }, [message.role, avatarUrl]);\n  \n  // Select CSS classes based on message role\n  const messageClass = useMemo(() => {\n    switch (message.role) {\n      case 'user':\n        return styles['ChatMessage--user'];\n      case 'assistant':\n        return styles['ChatMessage--assistant'];\n      case 'system':\n        return styles['ChatMessage--system'];\n      case 'error':\n        return styles['ChatMessage--error'];\n      default:\n        return '';\n    }\n  }, [message.role]);\n  \n  // Determine if we should show metrics (only for assistant messages)\n  const shouldShowMetrics = useMemo(() => {\n    // Show metrics if this is an assistant message with any metrics\n    if (message.role !== 'assistant' || !message.metrics) return false;\n    return true;\n  }, [message.role, message.metrics]);\n  \n  // Copy message content to clipboard\n  const handleCopyMessage = useCallback(() => {\n    const content = typeof message.content === 'string' \n      ? message.content \n      : Array.isArray(message.content) \n        ? message.content\n            .filter(part => part.type === 'text')\n            .map(part => part.text)\n            .join('\\n')\n        : '';\n    navigator.clipboard.writeText(content).then(() => {\n      setMessageCopied(true);\n      setTimeout(() => setMessageCopied(false), 2000);\n    });\n  }, [message.content]);\n  \n  // === BUTTON JSX (Moved here for reuse) ===\n  const copyButtonJsx = useMemo(() => (\n    <button\n      className={`${styles.ChatMessage__copyMessageButton} ${\n        (message.role === 'assistant' && shouldShowMetrics) ? styles.ChatMessage__copyMessageButtonInMetrics : styles.ChatMessage__copyMessageButtonBottomRight\n      }`}\n      onClick={handleCopyMessage}\n      aria-label=\"Copy message\"\n      title=\"Copy message\"\n    >\n      {messageCopied ? <CheckIcon size={16} /> : <CopyIcon size={16} />}\n    </button>\n  ), [handleCopyMessage, message.role, shouldShowMetrics, messageCopied]);\n\n  // Edit button only for user messages\n  const handleEditClick = useCallback(() => {\n    if (onEditMessage) onEditMessage(message);\n  }, [onEditMessage, message]);\n  const editButtonJsx = useMemo(() => message.role === 'user' ? (\n    <button\n      className={styles.ChatMessage__editMessageButton}\n      onClick={handleEditClick}\n      aria-label=\"Edit message\"\n      title=\"Edit message\"\n    >\n      <PencilIcon size={16} />\n    </button>\n  ) : null, [message.role, handleEditClick]);\n  // ==========================================\n  \n  // Render performance metrics (only for assistant messages)\n  const renderMetrics = () => {\n    if (!shouldShowMetrics || !message.metrics) return null;\n    \n    // Use the specific isStreaming prop passed down to determine if THIS message is generating\n    const isGenerating = isStreaming;\n    const { \n      elapsedTime, \n      tokenCount, \n      tokensPerSecond, \n      timeToFirstToken, \n      promptTokens, \n      completionTokens, \n      totalTokens,\n      finishReason \n    } = message.metrics;\n    \n    // Check if we have any valid metrics to show\n    const hasValidMetrics = \n      elapsedTime != null || \n      tokenCount != null || \n      tokensPerSecond != null || \n      timeToFirstToken != null ||\n      promptTokens != null ||\n      completionTokens != null ||\n      totalTokens != null ||\n      finishReason != null;\n      \n    // Don't render anything if no valid metrics are found\n    if (!hasValidMetrics) return null;\n    \n    return (\n      <div className={styles.ChatMessage__metricsContainer}>\n        {/* Time metrics */}\n        {timeToFirstToken != null && timeToFirstToken !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            First Token: {formatTime(timeToFirstToken)}\n          </span>\n        )}\n        {elapsedTime != null && elapsedTime !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <ClockIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total Time: {formatTime(elapsedTime)}\n          </span>\n        )}\n        \n        {/* Token metrics */}\n        {tokenCount != null && tokenCount !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Tokens: {tokenCount}\n          </span>\n        )}\n        {promptTokens != null && promptTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Prompt: {promptTokens}\n          </span>\n        )}\n        {completionTokens != null && completionTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Completion: {completionTokens}\n          </span>\n        )}\n        {totalTokens != null && totalTokens !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <CopilotIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Total: {totalTokens}\n          </span>\n        )}\n        \n        {/* Speed metrics */}\n        {tokensPerSecond != null && tokensPerSecond !== 0 && (\n          <span className={styles.ChatMessage__metric}>\n            <PulseIcon size={14} className={styles.ChatMessage__metricIcon} />\n            Speed: {tokensPerSecond} t/s\n          </span>\n        )}\n        \n        {/* Status (only show if meaningful) */}\n        {finishReason != null && finishReason !== '' && finishReason.toLowerCase() !== 'stop' && finishReason.toLowerCase() !== 'unknown' && (\n          <span className={styles.ChatMessage__metric}>\n            <AlertIcon size={14} className={styles.ChatMessage__metricIcon} />\n            {finishReason}\n          </span>\n        )}\n        {isGenerating && (\n          <span className={`${styles.ChatMessage__metric} ${styles.ChatMessage__generatingIndicator}`}>\n            <span className={styles.ChatMessage__generatingDot}></span>\n            Generating...\n          </span>\n        )}\n        \n        {/* Copy button */}\n        {copyButtonJsx}\n      </div>\n    );\n  };\n  \n  // Main return\n  return (\n    <div className={styles.ChatMessage + ' ' + messageClass}>\n      <div className={styles.ChatMessage__body}>\n        {/* Avatar (only render if icon exists) */}\n        {icon && (\n          <div className={styles.ChatMessage__avatar}>{icon}</div>\n        )}\n\n        {/* Message content section */}\n        <div className={styles.ChatMessage__contentWrapper}>\n          <Suspense fallback={null}>\n            <div className={styles.ChatMessage__content}>\n              {message.role === 'assistant' ? (\n                <StreamingMessage\n                  content={processedMessage}\n                  isStreaming={isStreaming}\n                />\n              ) : (\n                // Render markdown lazily for user/system/error messages\n                <LazyMarkdownRenderer>\n                  {processedMessage}\n                </LazyMarkdownRenderer>\n              )}\n            </div>\n          </Suspense>\n\n          {/* Render performance metrics for assistant messages */}\n          {message.role === 'assistant' && renderMetrics()}\n\n          {/* Copy button for non-user messages, hide when assistant metrics exist */}\n          {message.role !== 'user' && (message.role !== 'assistant' || !shouldShowMetrics) && copyButtonJsx}\n        </div>\n      </div>\n\n      {message.role === 'user' && (\n        <div className={styles.ChatMessage__actions}>\n          {editButtonJsx}\n          {copyButtonJsx}\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Display name\nChatMessage.displayName = 'ChatMessage';\n\n// PropTypes\nChatMessage.propTypes = {\n  message: PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    role: PropTypes.oneOf(['user', 'assistant', 'system', 'error']).isRequired,\n    content: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.arrayOf(PropTypes.shape({ // Support complex content\n        type: PropTypes.string.isRequired,\n        text: PropTypes.string,\n        image_url: PropTypes.shape({\n          url: PropTypes.string.isRequired\n        })\n      }))\n    ]).isRequired,\n    timestamp: PropTypes.number.isRequired,\n    metrics: PropTypes.shape({\n      elapsedTime: PropTypes.number,\n      tokenCount: PropTypes.number,\n      tokensPerSecond: PropTypes.number,\n      timeToFirstToken: PropTypes.number,\n      promptTokens: PropTypes.number,\n      completionTokens: PropTypes.number,\n      totalTokens: PropTypes.number,\n      finishReason: PropTypes.string\n    })\n  }).isRequired,\n  isStreaming: PropTypes.bool,\n  onEditMessage: PropTypes.func,\n  overrideContent: PropTypes.string, // Optional override for rendering previews\n  avatarUrl: PropTypes.string, // Optional URL for user avatar image\n};\n\nexport default memo(ChatMessage); "],"file":"assets/index-Ct4k9cTk.js"}
{"version":3,"mappings":"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","names":["useChatLogic","chatHistory","isWaitingForResponse","error","currentMessageMetrics","metrics","useChatState","sendMessage","submitMessage","clearChat","resetChat","downloadChatHistory","useChatControl","selectedModel","useModel","settings","useSettings","handleSendMessage","useCallback","async","message","editedMessage","isEditing","Array","isArray","map","part","type","text","join","trim","editMsgId","uniqueId","id","timestamp","editIndex","findIndex","msg","includes","content","role","finalMessage","Date","now","Math","random","toString","substring","err","MessageList","lazy","import","then","n","i","__VITE_PRELOAD__","ChatInput","GlobalMetricsBar","ModelSelectorButton","ChatContainer","memo","passedSelectedModel","isLoadingModels","toggleModelSelector","onToggleSettings","isSidebarOpen","isSettingsOpen","isModelSelectorOpen","modelFromLogic","editingMessage","setEditingMessage","useState","messageListRef","useRef","scrollContainerRef","containerRef","isActiveChat","length","showScrollToBottomButton","setShowScrollToBottomButton","prevWaitingForResponse","scrollToBottom","behavior","current","scrollTo","top","scrollHeight","handleScroll","container","atBottom","scrollTop","clientHeight","throttledHandleScroll","useMemo","throttle","focusInputField","setTimeout","inputField","document","querySelector","styles","chatInput","focus","useEffect","addEventListener","passive","removeEventListener","cancel","handleScroll2","timeout","clearTimeout","displayModelName","name","displayProviderName","provider","handleEditMessage","ChatContainer__fixedInputArea","handleCancelEdit","chatContainerClasses","renderInputAreaContents","isFixedLayout","isInitialChat","jsx","Suspense","fallback","className","globalMetricsPlaceholder","children","jsxRuntimeExports","session","modelName","ChatContainer__inputControlsWrapper","ChatContainer__inputPlaceholder","onSendMessage","disabled","onCancelEdit","isStreaming","onFocus","jsxs","updateInputHeight","inputArea","height","getBoundingClientRect","style","setProperty","window","ref","ChatContainer__modelButtonContainer","selectedModelName","providerName","onClick","ChatContainer__chatAreaWrapper","ChatContainer__chatArea","ChatContainer__scrollContainer","ChatContainer__scrollInner","messagePlaceholder","messages","onEditMessage","ChatContainer__emptyChatContent","ChatContainer__greetingMessage","ChatContainer__inputArea","ChatContainer__staticInputArea","ChatContainer__scrollToBottomButton","title","ChevronDownIcon","size","displayName"],"ignoreList":[],"sources":["../../src/hooks/useChatLogic.jsx","../../src/components/chat/ChatContainer/index.jsx"],"sourcesContent":["import { useCallback } from 'react';\nimport { useChatState } from '../contexts/ChatStateContext';\nimport { useChatControl } from '../contexts/ChatControlContext';\nimport { useModel } from '../contexts/ModelContext';\nimport { useSettings } from '../contexts/SettingsContext';\n\n// Helper to generate unique IDs\nconst generateUniqueId = () => {\n  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n};\n\n/**\n * Custom Hook for Chat Container Logic\n * Encapsulates state management, API calls, and event handlers \n * related to the chat interface.\n */\nexport const useChatLogic = () => {\n  const {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    currentMessageMetrics: metrics\n  } = useChatState();\n  const { sendMessage: submitMessage, clearChat: resetChat, downloadChatHistory } = useChatControl();\n  \n  const { selectedModel } = useModel();\n  const { settings } = useSettings();\n  \n  // Enhanced function to handle sending messages, including edits\n  const handleSendMessage = useCallback(async (message, editedMessage = null) => {\n    const isEditing = !!editedMessage;\n    \n    // Handle both string and array payloads for content validation\n    const messageContent = Array.isArray(message) \n      ? message.map(part => part.type === 'text' ? part.text : '').join(' ').trim()\n      : message;\n\n    if (!messageContent && !Array.isArray(message)) return;\n    if (!selectedModel) return;\n    \n    try {\n      if (isEditing) {\n        // Get or create unique identifier for the message\n        const editMsgId = editedMessage.uniqueId || editedMessage.id || editedMessage.timestamp;\n        // Find the index of the message being edited with a single pass\n        const editIndex = chatHistory.findIndex(msg =>\n          [msg.uniqueId, msg.id, msg.timestamp].includes(editMsgId) ||\n          (typeof msg.content === 'string' && msg.content === editedMessage.content && msg.role === 'user')\n        );\n        if (editIndex === -1) {\n          return;\n        }\n        // Ensure the message to be submitted has the correct uniqueId\n        const finalMessage = Array.isArray(message) ? message : { type: 'text', text: message };\n        \n        // Add uniqueId to message\n        if (Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = editMsgId;\n        } else {\n          finalMessage.uniqueId = editMsgId;\n        }\n        \n        // Call the submitMessage function with the truncated history index\n        await submitMessage(finalMessage, editIndex);\n      } else {\n        // For new messages, generate a unique ID\n        const uniqueId = generateUniqueId();\n        \n        // Add uniqueId to new message\n        const finalMessage = Array.isArray(message) \n          ? message.map(part => ({...part, uniqueId}))\n          : message;\n          \n        if (!Array.isArray(finalMessage)) {\n          finalMessage.uniqueId = uniqueId;\n        }\n        \n        // Normal message submission with uniqueId\n        await submitMessage(finalMessage);\n      }\n    } catch (err) {\n      console.error(`Error ${isEditing ? 'editing' : 'submitting'} message:`, err);\n    }\n  }, [selectedModel, submitMessage, chatHistory]);\n\n  // Return values needed by the ChatContainer component\n  return {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics,\n    selectedModel,\n    settings,\n    handleSendMessage,\n    resetChat, \n    downloadChatHistory,\n  };\n}; ","import { memo, lazy, useRef, useEffect, useState, useCallback, useMemo, Suspense } from 'react';\nimport { useChatLogic } from '../../../hooks/useChatLogic';\nimport { ChevronDownIcon } from '@primer/octicons-react';\nimport styles from './ChatContainer.module.css';\nimport throttle from 'lodash.throttle';\nimport PropTypes from 'prop-types';\n\n// Lazy-loaded components\nconst MessageList = lazy(() => import(/* webpackChunkName: \"chat-messagelist\" */ '../MessageList'));\nconst ChatInput = lazy(() => import(/* webpackChunkName: \"chat-input\" */ '../ChatInput'));\nconst GlobalMetricsBar = lazy(() => import(/* webpackChunkName: \"chat-globalmetrics\" */ '../GlobalMetricsBar'));\nconst ModelSelectorButton = lazy(() => import(/* webpackChunkName: \"model-selector-button\" */ '../../models/ModelSelectorButton'));\n\n/**\n * Main chat container component\n */\nconst ChatContainer = memo(({ \n  selectedModel: passedSelectedModel,\n  isLoadingModels, \n  toggleModelSelector,\n  onToggleSettings,\n  isSidebarOpen,\n  isSettingsOpen,\n  isModelSelectorOpen\n}) => {\n  const {\n    chatHistory,\n    isWaitingForResponse,\n    error,\n    metrics, \n    selectedModel: modelFromLogic,\n    handleSendMessage,\n  } = useChatLogic();\n\n  // Add state to track which message is being edited\n  const [editingMessage, setEditingMessage] = useState(null);\n\n  const messageListRef = useRef(null);\n  const scrollContainerRef = useRef(null);\n  const containerRef = useRef(null);\n  const isActiveChat = chatHistory.length > 0;\n  const [showScrollToBottomButton, setShowScrollToBottomButton] = useState(false);\n  const prevWaitingForResponse = useRef(isWaitingForResponse);\n\n  // === Performance-tuned handlers ===\n  // Smooth scroll to bottom, memoized\n  const scrollToBottom = useCallback((behavior = 'smooth') => {\n    if (scrollContainerRef.current) {\n      scrollContainerRef.current.scrollTo({ top: scrollContainerRef.current.scrollHeight, behavior });\n      setShowScrollToBottomButton(false);\n    }\n  }, []);\n\n  // Scroll handler for showing/hiding the scroll-to-bottom button, throttled\n  const handleScroll = useCallback(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    const scrollThreshold = 10;\n    const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;\n    setShowScrollToBottomButton(!atBottom);\n  }, []);\n  const throttledHandleScroll = useMemo(\n    () => throttle(handleScroll, 100),\n    [handleScroll]\n  );\n\n  // Focus input helper, memoized\n  const focusInputField = useCallback(() => {\n    // Use a timeout to ensure the component is fully rendered and mounted\n    setTimeout(() => {\n      // Try to find the textarea within the ChatInput component\n      const inputField = document.querySelector('textarea.'+styles.chatInput) || \n                         document.querySelector('textarea[aria-label=\"Chat message input\"]');\n      if (inputField) {\n        inputField.focus();\n      }\n    }, 100);\n  }, []);\n\n  // Focus the input field when the component is mounted\n  useEffect(() => {\n    focusInputField();\n  }, [focusInputField]);\n\n  // Focus input when response is completed, only if UI elements aren't open\n  useEffect(() => {\n    // Check if response has just completed (was waiting, now not waiting)\n    if (prevWaitingForResponse.current && !isWaitingForResponse) {\n      // Only focus if no UI elements are open\n      const noUIElementsOpen = !isSidebarOpen && !isSettingsOpen && !isModelSelectorOpen && !editingMessage;\n      \n      if (noUIElementsOpen) {\n        focusInputField();\n      }\n    }\n    \n    // Update the ref for the next check\n    prevWaitingForResponse.current = isWaitingForResponse;\n  }, [isWaitingForResponse, isSidebarOpen, isSettingsOpen, isModelSelectorOpen, editingMessage, focusInputField]);\n\n  // Effect to handle manual scrolling by the user (NOW MANAGES BUTTON VISIBILITY)\n  useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n    // Initial check\n    throttledHandleScroll();\n    container.addEventListener('scroll', throttledHandleScroll, { passive: true });\n    return () => {\n      container.removeEventListener('scroll', throttledHandleScroll);\n      throttledHandleScroll.cancel();\n    };\n  }, [throttledHandleScroll]);\n\n  // Effect to handle manual scrolling by the user (NOW MANAGES BUTTON VISIBILITY)\n  useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (!container) return;\n\n    const handleScroll = () => {\n      const scrollThreshold = 10; // Pixels from bottom to consider \"at bottom\"\n      const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < scrollThreshold;\n      // Show the button if user is NOT at the bottom\n      setShowScrollToBottomButton(!atBottom);\n    };\n\n    // Run handler once initially to set correct state\n    handleScroll();\n\n    container.addEventListener('scroll', handleScroll, { passive: true });\n    return () => container.removeEventListener('scroll', handleScroll);\n\n  }, [showScrollToBottomButton]); // Dependency helps re-attach listener if needed, though primary logic is inside\n\n  // Need another effect to check scroll position when chatHistory length changes,\n  // as new content might make the button necessary even if user didn't scroll.\n  useEffect(() => {\n    // React to new messages by re-checking scroll only once after DOM update\n    const timeout = setTimeout(() => throttledHandleScroll(), 100);\n    return () => clearTimeout(timeout);\n  }, [chatHistory, throttledHandleScroll]);\n\n  // Use the selected model passed down for the button, but model from logic elsewhere\n  const displayModelName = passedSelectedModel?.name;\n  const displayProviderName = passedSelectedModel?.provider;\n\n  // Handle edit message request from a message\n  const handleEditMessage = useCallback((message) => {\n    // Can't edit while waiting for response\n    if (isWaitingForResponse) return;\n    setEditingMessage(message);\n    // Scroll to input area if needed\n    setTimeout(() => {\n      const inputArea = document.querySelector(`.${styles.ChatContainer__fixedInputArea}`);\n      if (inputArea) {\n        // inputArea.scrollIntoView({ behavior: 'smooth' }); // Commented out to prevent scroll\n      }\n    }, 100);\n  }, [isWaitingForResponse]);\n\n  // Handle cancel edit\n  const handleCancelEdit = useCallback(() => {\n    setEditingMessage(null);\n  }, []);\n\n  // Disable editing if the model starts responding\n  useEffect(() => {\n    if (isWaitingForResponse && editingMessage) {\n      setEditingMessage(null);\n    }\n  }, [isWaitingForResponse, editingMessage]);\n\n  // Classes for the main container\n  const chatContainerClasses = `${styles.ChatContainer} ${isActiveChat ? styles['ChatContainer--activeChat'] : styles['ChatContainer--emptyChat']} ${editingMessage ? styles['ChatContainer--editingMode'] : ''}`;\n\n  // Helper function to render the input area contents\n  const renderInputAreaContents = (isFixedLayout) => {\n    // Determine if it's the initial chat state\n    const isInitialChat = !isActiveChat;\n\n    return (\n      <>\n        {/* Global Metrics: Only show when fixed */}\n        {isFixedLayout && !editingMessage && (\n          <Suspense fallback={<div className={styles.globalMetricsPlaceholder} />}>\n            <GlobalMetricsBar \n              metrics={metrics?.session}\n              modelName={modelFromLogic?.name} \n            />\n          </Suspense>\n        )}\n\n        <div className={styles.ChatContainer__inputControlsWrapper}> \n          <Suspense fallback={<div className={styles.ChatContainer__inputPlaceholder} />}>\n            <ChatInput\n              isInitialChat={isInitialChat}\n              onSendMessage={handleSendMessage}\n              disabled={isWaitingForResponse} \n              selectedModel={modelFromLogic} \n              editingMessage={editingMessage}\n              onCancelEdit={handleCancelEdit}\n              isStreaming={isWaitingForResponse}\n              toggleModelSelector={toggleModelSelector}\n              onFocus={focusInputField}\n            />\n          </Suspense>\n        </div>\n      </>\n    );\n  };\n\n  // Update CSS var for input height\n  useEffect(() => {\n    if (!chatHistory.length) return;\n    const container = containerRef.current;\n    if (!container) return;\n    const updateInputHeight = () => {\n      const inputArea = container.querySelector(`.${styles.ChatContainer__fixedInputArea}`);\n      if (inputArea) {\n        const height = inputArea.getBoundingClientRect().height;\n        container.style.setProperty('--input-height', `${height}px`);\n      }\n    };\n    updateInputHeight();\n    window.addEventListener('resize', updateInputHeight);\n    return () => window.removeEventListener('resize', updateInputHeight);\n  }, [chatHistory]);\n\n  return (\n    <div ref={containerRef} className={chatContainerClasses}>\n      {/* Container for the Model Selector Button */}\n      <div className={styles.ChatContainer__modelButtonContainer}>\n        <Suspense fallback={null}> \n          <ModelSelectorButton \n            selectedModelName={displayModelName}\n            providerName={displayProviderName}\n            onClick={toggleModelSelector}\n            disabled={isLoadingModels}\n          />\n        </Suspense>\n      </div>\n\n      <div className={styles.ChatContainer__chatAreaWrapper}>\n        <div className={styles.ChatContainer__chatArea}>\n          {isActiveChat ? (\n            // Active Chat: Render MessageList inside scroll container\n            <div className={styles.ChatContainer__scrollContainer} ref={scrollContainerRef}>\n              <div className={styles.ChatContainer__scrollInner}>\n                <Suspense fallback={<div className={styles.messagePlaceholder} />}>\n                  <MessageList\n                    ref={messageListRef}\n                    messages={chatHistory}\n                    error={error}\n                    onEditMessage={handleEditMessage}\n                  />\n                </Suspense>\n              </div>\n            </div>\n          ) : (\n            // Empty Chat: Render Greeting and Input Area (Static Layout)\n            <div className={styles.ChatContainer__emptyChatContent}>\n              <div className={styles.ChatContainer__greetingMessage}>\n                <h2>Welcome to AI Chat!</h2>\n                <p>Select a model above and start your conversation.</p>\n              </div>\n              {/* Render input area directly below greeting */}\n              <div className={`${styles.ChatContainer__inputArea} ${styles.ChatContainer__staticInputArea}`}> \n                {renderInputAreaContents(false)} \n              </div>\n            </div>\n          )}\n        </div>\n\n        {/* Scroll to Bottom Button */}\n        {showScrollToBottomButton && isActiveChat && (\n          <button\n            className={styles.ChatContainer__scrollToBottomButton}\n            onClick={() => scrollToBottom('smooth')}\n            aria-label=\"Scroll to bottom\"\n            title=\"Scroll to bottom\"\n          >\n            <ChevronDownIcon size={20} />\n          </button>\n        )}\n      </div>\n\n      {/* Fixed Input Area Wrapper (Only rendered when chat is active) */}\n      {isActiveChat && (\n        <div className={`${styles.ChatContainer__inputArea} ${styles.ChatContainer__fixedInputArea}`}> \n          {renderInputAreaContents(true)} \n        </div>\n      )}\n    </div>\n  );\n});\n\nChatContainer.displayName = 'ChatContainer';\n\nChatContainer.propTypes = {\n  selectedModel: PropTypes.object, // Shape could be refined\n  isLoadingModels: PropTypes.bool,\n  toggleModelSelector: PropTypes.func.isRequired,\n  onToggleSettings: PropTypes.func.isRequired,\n  isSidebarOpen: PropTypes.bool,\n  isSettingsOpen: PropTypes.bool,\n  isModelSelectorOpen: PropTypes.bool\n};\n\nexport default ChatContainer; "],"file":"assets/index-y8PTocmW.js"}